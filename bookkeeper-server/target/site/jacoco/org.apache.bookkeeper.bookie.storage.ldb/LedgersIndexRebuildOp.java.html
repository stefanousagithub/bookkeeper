<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgersIndexRebuildOp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie.storage.ldb</a> &gt; <span class="el_source">LedgersIndexRebuildOp.java</span></div><h1>LedgersIndexRebuildOp.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.bookie.storage.ldb;

import com.google.common.collect.Lists;
import com.google.protobuf.ByteString;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.apache.bookkeeper.bookie.BookieImpl;
import org.apache.bookkeeper.bookie.DefaultEntryLogger;
import org.apache.bookkeeper.bookie.Journal;
import org.apache.bookkeeper.bookie.LedgerDirsManager;
import org.apache.bookkeeper.bookie.storage.EntryLogScanner;
import org.apache.bookkeeper.bookie.storage.ldb.KeyValueStorageFactory.DbConfigType;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.util.BookKeeperConstants;
import org.apache.bookkeeper.util.DiskChecker;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Scan all entries in the journal and entry log files then rebuilds the ledgers index.
 * Notable stuff:
 * - Fences every ledger as even if we check the metadata, we cannot guarantee that
 *   a fence request was served while the rebuild was taking place (even if the bookie
 *   is running in read-only mode).
 *   Losing the fenced status of a ledger is UNSAFE.
 * - Sets the master key as an empty byte array. This is correct as empty master keys
 *   are overwritten and we cannot use the password from metadata, and cannot know 100%
 *   for sure how a digest for the password was generated.
 */
public class LedgersIndexRebuildOp {
<span class="nc" id="L63">    private static final Logger LOG = LoggerFactory.getLogger(LedgersIndexRebuildOp.class);</span>

    private final ServerConfiguration conf;
    private final boolean verbose;
    private static final String LedgersSubPath = &quot;ledgers&quot;;

<span class="nc" id="L69">    public LedgersIndexRebuildOp(ServerConfiguration conf, boolean verbose) {</span>
<span class="nc" id="L70">        this.conf = conf;</span>
<span class="nc" id="L71">        this.verbose = verbose;</span>
<span class="nc" id="L72">    }</span>

    @SuppressFBWarnings(&quot;RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE&quot;)
    public boolean initiate()  {
<span class="nc" id="L76">        LOG.info(&quot;Starting ledger index rebuilding&quot;);</span>
<span class="nc" id="L77">        File[] indexDirs = conf.getIndexDirs();</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (indexDirs == null) {</span>
<span class="nc" id="L79">            indexDirs = conf.getLedgerDirs();</span>
        }
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (indexDirs.length != conf.getLedgerDirs().length) {</span>
<span class="nc" id="L82">            LOG.error(&quot;ledger and index dirs size not matched&quot;);</span>
<span class="nc" id="L83">            return false;</span>
        }

<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (int i = 0; i &lt; indexDirs.length; i++) {</span>
<span class="nc" id="L87">            File indexDir = indexDirs[i];</span>
<span class="nc" id="L88">            File ledgerDir = conf.getLedgerDirs()[i];</span>

<span class="nc" id="L90">            String timestamp = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;).format(new Date());</span>
<span class="nc" id="L91">            String indexBasePath = BookieImpl.getCurrentDirectory(indexDir).toString();</span>
<span class="nc" id="L92">            String tempLedgersSubPath = LedgersSubPath + &quot;.TEMP-&quot; + timestamp;</span>
<span class="nc" id="L93">            Path indexTempPath = FileSystems.getDefault().getPath(indexBasePath, tempLedgersSubPath);</span>
<span class="nc" id="L94">            Path indexCurrentPath = FileSystems.getDefault().getPath(indexBasePath, LedgersSubPath);</span>

<span class="nc" id="L96">            LOG.info(&quot;Starting scan phase (scans journal and entry log files)&quot;);</span>

            try {
<span class="nc" id="L99">                Set&lt;Long&gt; ledgers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L100">                scanJournals(ledgers);</span>
<span class="nc" id="L101">                File[] lDirs = new File[1];</span>
<span class="nc" id="L102">                lDirs[0] = ledgerDir;</span>
<span class="nc" id="L103">                scanEntryLogFiles(ledgers, lDirs);</span>

<span class="nc" id="L105">                LOG.info(&quot;Scan complete, found {} ledgers. &quot;</span>
<span class="nc" id="L106">                        + &quot;Starting to build a new ledgers index&quot;, ledgers.size());</span>

<span class="nc" id="L108">                try (KeyValueStorage newIndex = KeyValueStorageRocksDB.factory.newKeyValueStorage(</span>
                        indexBasePath, tempLedgersSubPath, DbConfigType.Default, conf)) {
<span class="nc" id="L110">                    LOG.info(&quot;Created ledgers index at temp location {}&quot;, indexTempPath);</span>

<span class="nc bnc" id="L112" title="All 2 branches missed.">                    for (Long ledgerId : ledgers) {</span>
                        DbLedgerStorageDataFormats.LedgerData ledgerData =
<span class="nc" id="L114">                                DbLedgerStorageDataFormats.LedgerData.newBuilder()</span>
<span class="nc" id="L115">                                        .setExists(true)</span>
<span class="nc" id="L116">                                        .setFenced(true)</span>
<span class="nc" id="L117">                                        .setMasterKey(ByteString.EMPTY).build();</span>

<span class="nc" id="L119">                        byte[] ledgerArray = new byte[16];</span>
<span class="nc" id="L120">                        ArrayUtil.setLong(ledgerArray, 0, ledgerId);</span>
<span class="nc" id="L121">                        newIndex.put(ledgerArray, ledgerData.toByteArray());</span>
<span class="nc" id="L122">                    }</span>

<span class="nc" id="L124">                    newIndex.sync();</span>
                }
<span class="nc" id="L126">            } catch (Throwable t) {</span>
<span class="nc" id="L127">                LOG.error(&quot;Error during rebuild, the original index remains unchanged&quot;, t);</span>
<span class="nc" id="L128">                delete(indexTempPath);</span>
<span class="nc" id="L129">                return false;</span>
<span class="nc" id="L130">            }</span>

            // replace the existing index
            try {
<span class="nc" id="L134">                Path prevPath = FileSystems.getDefault().getPath(indexBasePath,</span>
                        LedgersSubPath + &quot;.PREV-&quot; + timestamp);
<span class="nc" id="L136">                LOG.info(&quot;Moving original index from original location: {} up to back-up location: {}&quot;,</span>
                        indexCurrentPath, prevPath);
<span class="nc" id="L138">                Files.move(indexCurrentPath, prevPath);</span>
<span class="nc" id="L139">                LOG.info(&quot;Moving rebuilt index from: {} to: {}&quot;, indexTempPath, indexCurrentPath);</span>
<span class="nc" id="L140">                Files.move(indexTempPath, indexCurrentPath);</span>
<span class="nc" id="L141">                LOG.info(&quot;Original index has been replaced with the new index. &quot;</span>
                        + &quot;The original index has been moved to {}&quot;, prevPath);
<span class="nc" id="L143">            } catch (IOException e) {</span>
<span class="nc" id="L144">                LOG.error(&quot;Could not replace original index with rebuilt index. &quot;</span>
                        + &quot;To return to the original state, ensure the original index is in its original location&quot;, e);
<span class="nc" id="L146">                return false;</span>
<span class="nc" id="L147">            }</span>
        }

<span class="nc" id="L150">        return true;</span>
    }

    private void scanEntryLogFiles(Set&lt;Long&gt; ledgers, File[] lDirs) throws IOException {
<span class="nc" id="L154">        DefaultEntryLogger entryLogger = new DefaultEntryLogger(conf, new LedgerDirsManager(conf, lDirs,</span>
<span class="nc" id="L155">                new DiskChecker(conf.getDiskUsageThreshold(), conf.getDiskUsageWarnThreshold())));</span>
<span class="nc" id="L156">        Set&lt;Long&gt; entryLogs = entryLogger.getEntryLogsSet();</span>

<span class="nc" id="L158">        int totalEntryLogs = entryLogs.size();</span>
<span class="nc" id="L159">        int completedEntryLogs = 0;</span>
<span class="nc" id="L160">        LOG.info(&quot;Scanning {} entry logs&quot;, totalEntryLogs);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">        for (long entryLogId : entryLogs) {</span>
<span class="nc" id="L163">            entryLogger.scanEntryLog(entryLogId, new EntryLogScanner() {</span>
                @Override
                public void process(long ledgerId, long offset, ByteBuf entry) throws IOException {
<span class="nc bnc" id="L166" title="All 2 branches missed.">                    if (ledgers.add(ledgerId)) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                        if (verbose) {</span>
<span class="nc" id="L168">                            LOG.info(&quot;Found ledger {} in entry log&quot;, ledgerId);</span>
                        }
                    }
<span class="nc" id="L171">                }</span>

                @Override
                public boolean accept(long ledgerId) {
<span class="nc" id="L175">                    return true;</span>
                }
            });

<span class="nc" id="L179">            ++completedEntryLogs;</span>
<span class="nc" id="L180">            LOG.info(&quot;Completed scanning of log {}.log -- {} / {}&quot;, Long.toHexString(entryLogId), completedEntryLogs,</span>
<span class="nc" id="L181">                    totalEntryLogs);</span>
<span class="nc" id="L182">        }</span>
<span class="nc" id="L183">    }</span>

    private void scanJournals(Set&lt;Long&gt; ledgers) throws IOException {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        for (Journal journal : getJournals(conf)) {</span>
<span class="nc" id="L187">            List&lt;Long&gt; journalIds = Journal.listJournalIds(journal.getJournalDirectory(),</span>
<span class="nc" id="L188">                    new Journal.JournalIdFilter() {</span>
                @Override
                public boolean accept(long journalId) {
<span class="nc" id="L191">                    return true;</span>
                }
            });

<span class="nc bnc" id="L195" title="All 2 branches missed.">            for (Long journalId : journalIds) {</span>
<span class="nc" id="L196">                scanJournal(journal, journalId, ledgers);</span>
<span class="nc" id="L197">            }</span>
<span class="nc" id="L198">        }</span>
<span class="nc" id="L199">    }</span>

    private List&lt;Journal&gt; getJournals(ServerConfiguration conf) throws IOException {
<span class="nc" id="L202">        List&lt;Journal&gt; journals = Lists.newArrayListWithCapacity(conf.getJournalDirs().length);</span>
<span class="nc" id="L203">        int idx = 0;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        for (File journalDir : conf.getJournalDirs()) {</span>
<span class="nc" id="L205">            journals.add(new Journal(idx++, new File(journalDir, BookKeeperConstants.CURRENT_DIR), conf,</span>
<span class="nc" id="L206">                    new LedgerDirsManager(conf, conf.getLedgerDirs(),</span>
<span class="nc" id="L207">                            new DiskChecker(conf.getDiskUsageThreshold(), conf.getDiskUsageWarnThreshold()))));</span>
        }

<span class="nc" id="L210">        return journals;</span>
    }

    private void scanJournal(Journal journal, long journalId, Set&lt;Long&gt; ledgers) throws IOException {
<span class="nc" id="L214">        LOG.info(&quot;Scanning journal &quot; + journalId + &quot; (&quot; + Long.toHexString(journalId) + &quot;.txn)&quot;);</span>
<span class="nc" id="L215">        journal.scanJournal(journalId, 0L, new Journal.JournalScanner() {</span>
            @Override
            public void process(int journalVersion, long offset, ByteBuffer entry) {
<span class="nc" id="L218">                ByteBuf buf = Unpooled.wrappedBuffer(entry);</span>
<span class="nc" id="L219">                long ledgerId = buf.readLong();</span>

<span class="nc bnc" id="L221" title="All 4 branches missed.">                if (ledgers.add(ledgerId) &amp;&amp; verbose) {</span>
<span class="nc" id="L222">                    LOG.info(&quot;Found ledger {} in journal&quot;, ledgerId);</span>
                }
<span class="nc" id="L224">            }</span>
        });
<span class="nc" id="L226">    }</span>

    private void delete(Path path) {
        try {
<span class="nc" id="L230">            Files.delete(path);</span>
<span class="nc" id="L231">        } catch (IOException e) {</span>
<span class="nc" id="L232">            LOG.warn(&quot;Unable to delete {}&quot;, path.toAbsolutePath(), e);</span>
<span class="nc" id="L233">        }</span>
<span class="nc" id="L234">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>