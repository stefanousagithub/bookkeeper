<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WriteCache.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie.storage.ldb</a> &gt; <span class="el_source">WriteCache.java</span></div><h1>WriteCache.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.bookie.storage.ldb;

import static com.google.common.base.Preconditions.checkArgument;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import java.io.Closeable;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;
import java.util.concurrent.locks.ReentrantLock;
import org.apache.bookkeeper.common.util.MathUtils;
import org.apache.bookkeeper.util.collections.ConcurrentLongHashSet;
import org.apache.bookkeeper.util.collections.ConcurrentLongLongHashMap;
import org.apache.bookkeeper.util.collections.ConcurrentLongLongPairHashMap;
import org.apache.bookkeeper.util.collections.ConcurrentLongLongPairHashMap.LongPair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Write cache implementation.
 *
 * &lt;p&gt;The write cache will allocate the requested size from direct memory and it
 * will break it down into multiple segments.
 *
 * &lt;p&gt;The entries are appended in a common buffer and indexed though a hashmap,
 * until the cache is cleared.
 *
 * &lt;p&gt;There is the possibility to iterate through the stored entries in an ordered
 * way, by (ledgerId, entry).
 */
public class WriteCache implements Closeable {

    /**
     * Consumer that is used to scan the entire write cache.
     */
    public interface EntryConsumer {
        void accept(long ledgerId, long entryId, ByteBuf entry) throws IOException;
    }

<span class="nc" id="L62">    private final ConcurrentLongLongPairHashMap index = ConcurrentLongLongPairHashMap.newBuilder()</span>
<span class="nc" id="L63">            .expectedItems(4096)</span>
<span class="nc" id="L64">            .concurrencyLevel(2 * Runtime.getRuntime().availableProcessors())</span>
<span class="nc" id="L65">            .build();</span>

<span class="nc" id="L67">    private final ConcurrentLongLongHashMap lastEntryMap = ConcurrentLongLongHashMap.newBuilder()</span>
<span class="nc" id="L68">            .expectedItems(4096)</span>
<span class="nc" id="L69">            .concurrencyLevel(2 * Runtime.getRuntime().availableProcessors())</span>
<span class="nc" id="L70">            .build();</span>

    private final ByteBuf[] cacheSegments;
    private final int segmentsCount;

    private final long maxCacheSize;
    private final int maxSegmentSize;
    private final long segmentOffsetMask;
    private final long segmentOffsetBits;

<span class="nc" id="L80">    private final AtomicLong cacheSize = new AtomicLong(0);</span>
<span class="nc" id="L81">    private final AtomicLong cacheOffset = new AtomicLong(0);</span>
<span class="nc" id="L82">    private final LongAdder cacheCount = new LongAdder();</span>

<span class="nc" id="L84">    private final ConcurrentLongHashSet deletedLedgers = ConcurrentLongHashSet.newBuilder().build();</span>

    private final ByteBufAllocator allocator;

    public WriteCache(ByteBufAllocator allocator, long maxCacheSize) {
        // Default maxSegmentSize set to 1Gb
<span class="nc" id="L90">        this(allocator, maxCacheSize, 1 * 1024 * 1024 * 1024);</span>
<span class="nc" id="L91">    }</span>

<span class="nc" id="L93">    public WriteCache(ByteBufAllocator allocator, long maxCacheSize, int maxSegmentSize) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        checkArgument(maxSegmentSize &gt; 0);</span>

<span class="nc" id="L96">        long alignedMaxSegmentSize = alignToPowerOfTwo(maxSegmentSize);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        checkArgument(maxSegmentSize == alignedMaxSegmentSize, &quot;Max segment size needs to be in form of 2^n&quot;);</span>

<span class="nc" id="L99">        this.allocator = allocator;</span>
<span class="nc" id="L100">        this.maxCacheSize = maxCacheSize;</span>
<span class="nc" id="L101">        this.maxSegmentSize = (int) maxSegmentSize;</span>
<span class="nc" id="L102">        this.segmentOffsetMask = maxSegmentSize - 1;</span>
<span class="nc" id="L103">        this.segmentOffsetBits = 63 - Long.numberOfLeadingZeros(maxSegmentSize);</span>

<span class="nc" id="L105">        this.segmentsCount = 1 + (int) (maxCacheSize / maxSegmentSize);</span>

<span class="nc" id="L107">        this.cacheSegments = new ByteBuf[segmentsCount];</span>

<span class="nc bnc" id="L109" title="All 2 branches missed.">        for (int i = 0; i &lt; segmentsCount - 1; i++) {</span>
            // All intermediate segments will be full-size
<span class="nc" id="L111">            cacheSegments[i] = Unpooled.directBuffer(maxSegmentSize, maxSegmentSize);</span>
        }

<span class="nc" id="L114">        int lastSegmentSize = (int) (maxCacheSize % maxSegmentSize);</span>
<span class="nc" id="L115">        cacheSegments[segmentsCount - 1] = Unpooled.directBuffer(lastSegmentSize, lastSegmentSize);</span>
<span class="nc" id="L116">    }</span>

    public void clear() {
<span class="nc" id="L119">        cacheSize.set(0L);</span>
<span class="nc" id="L120">        cacheOffset.set(0L);</span>
<span class="nc" id="L121">        cacheCount.reset();</span>
<span class="nc" id="L122">        index.clear();</span>
<span class="nc" id="L123">        lastEntryMap.clear();</span>
<span class="nc" id="L124">        deletedLedgers.clear();</span>
<span class="nc" id="L125">    }</span>

    @Override
    public void close() {
<span class="nc bnc" id="L129" title="All 2 branches missed.">        for (ByteBuf buf : cacheSegments) {</span>
<span class="nc" id="L130">            buf.release();</span>
        }
<span class="nc" id="L132">    }</span>

    public boolean put(long ledgerId, long entryId, ByteBuf entry) {
<span class="nc" id="L135">        int size = entry.readableBytes();</span>

        // Align to 64 bytes so that different threads will not contend the same L1
        // cache line
<span class="nc" id="L139">        int alignedSize = align64(size);</span>

        long offset;
        int localOffset;
        int segmentIdx;

        while (true) {
<span class="nc" id="L146">            offset = cacheOffset.getAndAdd(alignedSize);</span>
<span class="nc" id="L147">            localOffset = (int) (offset &amp; segmentOffsetMask);</span>
<span class="nc" id="L148">            segmentIdx = (int) (offset &gt;&gt;&gt; segmentOffsetBits);</span>

<span class="nc bnc" id="L150" title="All 2 branches missed.">            if ((offset + size) &gt; maxCacheSize) {</span>
                // Cache is full
<span class="nc" id="L152">                return false;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            } else if (maxSegmentSize - localOffset &lt; size) {</span>
                // If an entry is at the end of a segment, we need to get a new offset and try
                // again in next segment
<span class="nc" id="L156">                continue;</span>
            } else {
                // Found a good offset
                break;
            }
        }

<span class="nc" id="L163">        cacheSegments[segmentIdx].setBytes(localOffset, entry, entry.readerIndex(), entry.readableBytes());</span>

        // Update last entryId for ledger. This logic is to handle writes for the same
        // ledger coming out of order and from different thread, though in practice it
        // should not happen and the compareAndSet should be always uncontended.
        while (true) {
<span class="nc" id="L169">            long currentLastEntryId = lastEntryMap.get(ledgerId);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (currentLastEntryId &gt; entryId) {</span>
                // A newer entry is already there
<span class="nc" id="L172">                break;</span>
            }

<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (lastEntryMap.compareAndSet(ledgerId, currentLastEntryId, entryId)) {</span>
<span class="nc" id="L176">                break;</span>
            }
<span class="nc" id="L178">        }</span>

<span class="nc" id="L180">        index.put(ledgerId, entryId, offset, size);</span>
<span class="nc" id="L181">        cacheCount.increment();</span>
<span class="nc" id="L182">        cacheSize.addAndGet(size);</span>
<span class="nc" id="L183">        return true;</span>
    }

    public ByteBuf get(long ledgerId, long entryId) {
<span class="nc" id="L187">        LongPair result = index.get(ledgerId, entryId);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L189">            return null;</span>
        }

<span class="nc" id="L192">        long offset = result.first;</span>
<span class="nc" id="L193">        int size = (int) result.second;</span>
<span class="nc" id="L194">        ByteBuf entry = allocator.buffer(size, size);</span>

<span class="nc" id="L196">        int localOffset = (int) (offset &amp; segmentOffsetMask);</span>
<span class="nc" id="L197">        int segmentIdx = (int) (offset &gt;&gt;&gt; segmentOffsetBits);</span>
<span class="nc" id="L198">        entry.writeBytes(cacheSegments[segmentIdx], localOffset, size);</span>
<span class="nc" id="L199">        return entry;</span>
    }

    public boolean hasEntry(long ledgerId, long entryId) {
<span class="nc bnc" id="L203" title="All 2 branches missed.">        return index.get(ledgerId, entryId) != null;</span>
    }

    public ByteBuf getLastEntry(long ledgerId) {
<span class="nc" id="L207">        long lastEntryId = lastEntryMap.get(ledgerId);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (lastEntryId == -1) {</span>
            // Ledger not found in write cache
<span class="nc" id="L210">            return null;</span>
        } else {
<span class="nc" id="L212">            return get(ledgerId, lastEntryId);</span>
        }
    }

    public void deleteLedger(long ledgerId) {
<span class="nc" id="L217">        deletedLedgers.add(ledgerId);</span>
<span class="nc" id="L218">    }</span>

    public void forEach(EntryConsumer consumer) throws IOException {
<span class="nc" id="L221">        sortedEntriesLock.lock();</span>

        try {
<span class="nc" id="L224">            int entriesToSort = (int) index.size();</span>
<span class="nc" id="L225">            int arrayLen = entriesToSort * 4;</span>
<span class="nc bnc" id="L226" title="All 4 branches missed.">            if (sortedEntries == null || sortedEntries.length &lt; arrayLen) {</span>
<span class="nc" id="L227">                sortedEntries = new long[(int) (arrayLen * 2)];</span>
            }

<span class="nc" id="L230">            long startTime = MathUtils.nowInNano();</span>

<span class="nc" id="L232">            sortedEntriesIdx = 0;</span>
<span class="nc" id="L233">            index.forEach((ledgerId, entryId, offset, length) -&gt; {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (deletedLedgers.contains(ledgerId)) {</span>
                    // Ignore deleted ledgers
<span class="nc" id="L236">                    return;</span>
                }

<span class="nc" id="L239">                sortedEntries[sortedEntriesIdx] = ledgerId;</span>
<span class="nc" id="L240">                sortedEntries[sortedEntriesIdx + 1] = entryId;</span>
<span class="nc" id="L241">                sortedEntries[sortedEntriesIdx + 2] = offset;</span>
<span class="nc" id="L242">                sortedEntries[sortedEntriesIdx + 3] = length;</span>
<span class="nc" id="L243">                sortedEntriesIdx += 4;</span>
<span class="nc" id="L244">            });</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L247">                log.debug(&quot;iteration took {} ms&quot;, MathUtils.elapsedNanos(startTime) / 1e6);</span>
            }
<span class="nc" id="L249">            startTime = MathUtils.nowInNano();</span>

            // Sort entries by (ledgerId, entryId) maintaining the 4 items groups
<span class="nc" id="L252">            ArrayGroupSort.sort(sortedEntries, 0, sortedEntriesIdx);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L254">                log.debug(&quot;sorting {} ms&quot;, (MathUtils.elapsedNanos(startTime) / 1e6));</span>
            }
<span class="nc" id="L256">            startTime = MathUtils.nowInNano();</span>

<span class="nc" id="L258">            ByteBuf[] entrySegments = new ByteBuf[segmentsCount];</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            for (int i = 0; i &lt; segmentsCount; i++) {</span>
<span class="nc" id="L260">                entrySegments[i] = cacheSegments[i].slice(0, cacheSegments[i].capacity());</span>
            }

<span class="nc bnc" id="L263" title="All 2 branches missed.">            for (int i = 0; i &lt; sortedEntriesIdx; i += 4) {</span>
<span class="nc" id="L264">                long ledgerId = sortedEntries[i];</span>
<span class="nc" id="L265">                long entryId = sortedEntries[i + 1];</span>
<span class="nc" id="L266">                long offset = sortedEntries[i + 2];</span>
<span class="nc" id="L267">                long length = sortedEntries[i + 3];</span>

<span class="nc" id="L269">                int localOffset = (int) (offset &amp; segmentOffsetMask);</span>
<span class="nc" id="L270">                int segmentIdx = (int) (offset &gt;&gt;&gt; segmentOffsetBits);</span>
<span class="nc" id="L271">                ByteBuf entry = entrySegments[segmentIdx];</span>
<span class="nc" id="L272">                entry.setIndex(localOffset, localOffset + (int) length);</span>
<span class="nc" id="L273">                consumer.accept(ledgerId, entryId, entry);</span>
            }

<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L277">                log.debug(&quot;entry log adding {} ms&quot;, MathUtils.elapsedNanos(startTime) / 1e6);</span>
            }
        } finally {
<span class="nc" id="L280">            sortedEntriesLock.unlock();</span>
        }
<span class="nc" id="L282">    }</span>

    public long size() {
<span class="nc" id="L285">        return cacheSize.get();</span>
    }

    public long count() {
<span class="nc" id="L289">        return cacheCount.sum();</span>
    }

    public boolean isEmpty() {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        return cacheSize.get() == 0L;</span>
    }

    private static final int ALIGN_64_MASK = ~(64 - 1);

    static int align64(int size) {
<span class="nc" id="L299">        return (size + 64 - 1) &amp; ALIGN_64_MASK;</span>
    }

    private static long alignToPowerOfTwo(long n) {
<span class="nc" id="L303">        return (long) Math.pow(2, 64 - Long.numberOfLeadingZeros(n - 1));</span>
    }

<span class="nc" id="L306">    private final ReentrantLock sortedEntriesLock = new ReentrantLock();</span>
    private long[] sortedEntries;
    private int sortedEntriesIdx;

<span class="nc" id="L310">    private static final Logger log = LoggerFactory.getLogger(WriteCache.class);</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>