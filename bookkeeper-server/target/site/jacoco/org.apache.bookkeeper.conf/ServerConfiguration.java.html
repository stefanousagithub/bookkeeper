<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServerConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.conf</a> &gt; <span class="el_source">ServerConfiguration.java</span></div><h1>ServerConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.conf;

import static org.apache.bookkeeper.util.BookKeeperConstants.MAX_LOG_SIZE_LIMIT;

import com.google.common.annotations.Beta;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import java.io.File;
import java.net.URL;
import java.util.concurrent.TimeUnit;
import org.apache.bookkeeper.bookie.FileChannelProvider;
import org.apache.bookkeeper.bookie.InterleavedLedgerStorage;
import org.apache.bookkeeper.bookie.LedgerStorage;
import org.apache.bookkeeper.bookie.SortedLedgerStorage;
import org.apache.bookkeeper.bookie.storage.ldb.DbLedgerStorage;
import org.apache.bookkeeper.common.conf.ConfigDef;
import org.apache.bookkeeper.common.conf.ConfigException;
import org.apache.bookkeeper.common.conf.ConfigKey;
import org.apache.bookkeeper.common.conf.ConfigKeyGroup;
import org.apache.bookkeeper.common.conf.Type;
import org.apache.bookkeeper.common.conf.validators.ClassValidator;
import org.apache.bookkeeper.common.conf.validators.RangeValidator;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.discover.RegistrationManager;
import org.apache.bookkeeper.discover.ZKRegistrationManager;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.stats.NullStatsProvider;
import org.apache.bookkeeper.stats.StatsProvider;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.lang3.StringUtils;

/**
 * Configuration manages server-side settings.
 */
public class ServerConfiguration extends AbstractConfiguration&lt;ServerConfiguration&gt; {

    private static final int SECOND = 1000;
    // Ledger Storage Settings

<span class="nc" id="L57">    private static final ConfigKeyGroup GROUP_LEDGER_STORAGE = ConfigKeyGroup.builder(&quot;ledgerstorage&quot;)</span>
<span class="nc" id="L58">        .description(&quot;Ledger Storage related settings&quot;)</span>
<span class="nc" id="L59">        .order(10) // place a place holder here</span>
<span class="nc" id="L60">        .build();</span>

    protected static final String LEDGER_STORAGE_CLASS = &quot;ledgerStorageClass&quot;;
<span class="nc" id="L63">    protected static final ConfigKey LEDGER_STORAGE_CLASS_KEY = ConfigKey.builder(LEDGER_STORAGE_CLASS)</span>
<span class="nc" id="L64">        .type(Type.CLASS)</span>
<span class="nc" id="L65">        .description(&quot;Ledger storage implementation class&quot;)</span>
<span class="nc" id="L66">        .defaultValue(SortedLedgerStorage.class)</span>
<span class="nc" id="L67">        .optionValues(Lists.newArrayList(</span>
<span class="nc" id="L68">            InterleavedLedgerStorage.class.getName(),</span>
<span class="nc" id="L69">            SortedLedgerStorage.class.getName(),</span>
<span class="nc" id="L70">            DbLedgerStorage.class.getName()</span>
        ))
<span class="nc" id="L72">        .validator(ClassValidator.of(LedgerStorage.class))</span>
<span class="nc" id="L73">        .group(GROUP_LEDGER_STORAGE)</span>
<span class="nc" id="L74">        .build();</span>

    // Entry Log Parameters

<span class="nc" id="L78">    private static final ConfigKeyGroup GROUP_LEDGER_STORAGE_ENTRY_LOGGER = ConfigKeyGroup.builder(&quot;entrylogger&quot;)</span>
<span class="nc" id="L79">        .description(&quot;EntryLogger related settings&quot;)</span>
<span class="nc" id="L80">        .order(11)</span>
<span class="nc" id="L81">        .build();</span>

    protected static final String ENTRY_LOG_SIZE_LIMIT = &quot;logSizeLimit&quot;;
<span class="nc" id="L84">    protected static final ConfigKey ENTRY_LOG_SIZE_LIMIT_KEY = ConfigKey.builder(ENTRY_LOG_SIZE_LIMIT)</span>
<span class="nc" id="L85">        .type(Type.LONG)</span>
<span class="nc" id="L86">        .description(&quot;Max file size of entry logger, in bytes&quot;)</span>
<span class="nc" id="L87">        .documentation(&quot;A new entry log file will be created when the old one reaches this file size limitation&quot;)</span>
<span class="nc" id="L88">        .defaultValue(MAX_LOG_SIZE_LIMIT)</span>
<span class="nc" id="L89">        .validator(RangeValidator.between(0, MAX_LOG_SIZE_LIMIT))</span>
<span class="nc" id="L90">        .group(GROUP_LEDGER_STORAGE_ENTRY_LOGGER)</span>
<span class="nc" id="L91">        .build();</span>

    protected static final String ENTRY_LOG_FILE_PREALLOCATION_ENABLED = &quot;entryLogFilePreallocationEnabled&quot;;


    protected static final String FORCE_ALLOW_COMPACTION = &quot;forceAllowCompaction&quot;;
    protected static final String MINOR_COMPACTION_INTERVAL = &quot;minorCompactionInterval&quot;;
    protected static final String MINOR_COMPACTION_THRESHOLD = &quot;minorCompactionThreshold&quot;;
    protected static final String MINOR_COMPACTION_MAX_TIME_MILLIS = &quot;minorCompactionMaxTimeMillis&quot;;
    protected static final String MAJOR_COMPACTION_INTERVAL = &quot;majorCompactionInterval&quot;;
    protected static final String MAJOR_COMPACTION_THRESHOLD = &quot;majorCompactionThreshold&quot;;
    protected static final String MAJOR_COMPACTION_MAX_TIME_MILLIS = &quot;majorCompactionMaxTimeMillis&quot;;
    protected static final String IS_THROTTLE_BY_BYTES = &quot;isThrottleByBytes&quot;;
    protected static final String COMPACTION_MAX_OUTSTANDING_REQUESTS = &quot;compactionMaxOutstandingRequests&quot;;
    protected static final String COMPACTION_RATE = &quot;compactionRate&quot;;
    protected static final String COMPACTION_RATE_BY_ENTRIES = &quot;compactionRateByEntries&quot;;
    protected static final String COMPACTION_RATE_BY_BYTES = &quot;compactionRateByBytes&quot;;

    // Gc Parameters
    protected static final String GC_WAIT_TIME = &quot;gcWaitTime&quot;;
    protected static final String IS_FORCE_GC_ALLOW_WHEN_NO_SPACE = &quot;isForceGCAllowWhenNoSpace&quot;;
    protected static final String GC_OVERREPLICATED_LEDGER_WAIT_TIME = &quot;gcOverreplicatedLedgerWaitTime&quot;;
    protected static final String GC_OVERREPLICATED_LEDGER_MAX_CONCURRENT_REQUESTS =
            &quot;gcOverreplicatedLedgerMaxConcurrentRequests&quot;;
    protected static final String USE_TRANSACTIONAL_COMPACTION = &quot;useTransactionalCompaction&quot;;
    protected static final String VERIFY_METADATA_ON_GC = &quot;verifyMetadataOnGC&quot;;
    protected static final String GC_ENTRYLOGMETADATA_CACHE_ENABLED = &quot;gcEntryLogMetadataCacheEnabled&quot;;
    protected static final String GC_ENTRYLOG_METADATA_CACHE_PATH = &quot;gcEntryLogMetadataCachePath&quot;;
    protected static final String USE_TARGET_ENTRYLOG_SIZE_FOR_GC = &quot;useTargetEntryLogSizeForGc&quot;;
    // Scrub Parameters
    protected static final String LOCAL_SCRUB_PERIOD = &quot;localScrubInterval&quot;;
    protected static final String LOCAL_SCRUB_RATE_LIMIT = &quot;localScrubRateLimit&quot;;
    // Sync Parameters
    protected static final String FLUSH_INTERVAL = &quot;flushInterval&quot;;
    protected static final String FLUSH_ENTRYLOG_INTERVAL_BYTES = &quot;flushEntrylogBytes&quot;;
    // Bookie death watch interval
    protected static final String DEATH_WATCH_INTERVAL = &quot;bookieDeathWatchInterval&quot;;
    // Ledger Cache Parameters
    protected static final String OPEN_FILE_LIMIT = &quot;openFileLimit&quot;;
    protected static final String PAGE_LIMIT = &quot;pageLimit&quot;;
    protected static final String PAGE_SIZE = &quot;pageSize&quot;;
    protected static final String FILEINFO_CACHE_INITIAL_CAPACITY = &quot;fileInfoCacheInitialCapacity&quot;;
    protected static final String FILEINFO_MAX_IDLE_TIME = &quot;fileInfoMaxIdleTime&quot;;
    protected static final String FILEINFO_FORMAT_VERSION_TO_WRITE = &quot;fileInfoFormatVersionToWrite&quot;;
    // Journal Parameters
    protected static final String MAX_JOURNAL_SIZE = &quot;journalMaxSizeMB&quot;;
    protected static final String MAX_BACKUP_JOURNALS = &quot;journalMaxBackups&quot;;
    protected static final String JOURNAL_SYNC_DATA = &quot;journalSyncData&quot;;
    protected static final String JOURNAL_WRITE_DATA = &quot;journalWriteData&quot;;
    protected static final String JOURNAL_ADAPTIVE_GROUP_WRITES = &quot;journalAdaptiveGroupWrites&quot;;
    protected static final String JOURNAL_MAX_GROUP_WAIT_MSEC = &quot;journalMaxGroupWaitMSec&quot;;
    protected static final String JOURNAL_BUFFERED_WRITES_THRESHOLD = &quot;journalBufferedWritesThreshold&quot;;
    protected static final String JOURNAL_BUFFERED_ENTRIES_THRESHOLD = &quot;journalBufferedEntriesThreshold&quot;;
    protected static final String JOURNAL_FLUSH_WHEN_QUEUE_EMPTY = &quot;journalFlushWhenQueueEmpty&quot;;
    protected static final String JOURNAL_REMOVE_FROM_PAGE_CACHE = &quot;journalRemoveFromPageCache&quot;;
    protected static final String JOURNAL_PRE_ALLOC_SIZE = &quot;journalPreAllocSizeMB&quot;;
    protected static final String JOURNAL_WRITE_BUFFER_SIZE = &quot;journalWriteBufferSizeKB&quot;;
    protected static final String JOURNAL_ALIGNMENT_SIZE = &quot;journalAlignmentSize&quot;;
    protected static final String NUM_JOURNAL_CALLBACK_THREADS = &quot;numJournalCallbackThreads&quot;;
    protected static final String JOURNAL_FORMAT_VERSION_TO_WRITE = &quot;journalFormatVersionToWrite&quot;;
    protected static final String JOURNAL_QUEUE_SIZE = &quot;journalQueueSize&quot;;
    protected static final String JOURNAL_MAX_MEMORY_SIZE_MB = &quot;journalMaxMemorySizeMb&quot;;
    protected static final String JOURNAL_PAGECACHE_FLUSH_INTERVAL_MSEC = &quot;journalPageCacheFlushIntervalMSec&quot;;
    protected static final String JOURNAL_CHANNEL_PROVIDER = &quot;journalChannelProvider&quot;;
    protected static final String JOURNAL_REUSE_FILES = &quot;journalReuseFiles&quot;;
    // backpressure control
    protected static final String MAX_ADDS_IN_PROGRESS_LIMIT = &quot;maxAddsInProgressLimit&quot;;
    protected static final String MAX_READS_IN_PROGRESS_LIMIT = &quot;maxReadsInProgressLimit&quot;;
    protected static final String CLOSE_CHANNEL_ON_RESPONSE_TIMEOUT = &quot;closeChannelOnResponseTimeout&quot;;
    protected static final String WAIT_TIMEOUT_ON_RESPONSE_BACKPRESSURE = &quot;waitTimeoutOnResponseBackpressureMs&quot;;

    // Bookie Parameters
    protected static final String BOOKIE_PORT = &quot;bookiePort&quot;;
    protected static final String LISTENING_INTERFACE = &quot;listeningInterface&quot;;
    protected static final String ALLOW_LOOPBACK = &quot;allowLoopback&quot;;
    protected static final String ADVERTISED_ADDRESS = &quot;advertisedAddress&quot;;
    protected static final String BOOKIE_ID = &quot;bookieId&quot;;
    protected static final String ALLOW_EPHEMERAL_PORTS = &quot;allowEphemeralPorts&quot;;

    protected static final String JOURNAL_DIR = &quot;journalDirectory&quot;;
    protected static final String JOURNAL_DIRS = &quot;journalDirectories&quot;;
    protected static final String LEDGER_DIRS = &quot;ledgerDirectories&quot;;
    protected static final String INDEX_DIRS = &quot;indexDirectories&quot;;
    protected static final String ALLOW_STORAGE_EXPANSION = &quot;allowStorageExpansion&quot;;
    // NIO and Netty Parameters
    protected static final String SERVER_TCP_NODELAY = &quot;serverTcpNoDelay&quot;;
    protected static final String SERVER_SOCK_KEEPALIVE = &quot;serverSockKeepalive&quot;;
    protected static final String SERVER_SOCK_LINGER = &quot;serverTcpLinger&quot;;
    protected static final String SERVER_WRITEBUFFER_LOW_WATER_MARK = &quot;serverWriteBufferLowWaterMark&quot;;
    protected static final String SERVER_WRITEBUFFER_HIGH_WATER_MARK = &quot;serverWriteBufferHighWaterMark&quot;;

    protected static final String SERVER_NUM_ACCEPTOR_THREADS = &quot;serverNumAcceptorThreads&quot;;
    protected static final String SERVER_NUM_IO_THREADS = &quot;serverNumIOThreads&quot;;

    // Zookeeper Parameters
    protected static final String ZK_RETRY_BACKOFF_START_MS = &quot;zkRetryBackoffStartMs&quot;;
    protected static final String ZK_RETRY_BACKOFF_MAX_MS = &quot;zkRetryBackoffMaxMs&quot;;
    protected static final String OPEN_LEDGER_REREPLICATION_GRACE_PERIOD = &quot;openLedgerRereplicationGracePeriod&quot;;
    protected static final String LOCK_RELEASE_OF_FAILED_LEDGER_GRACE_PERIOD = &quot;lockReleaseOfFailedLedgerGracePeriod&quot;;
    //ReadOnly mode support on all disk full
    protected static final String READ_ONLY_MODE_ENABLED = &quot;readOnlyModeEnabled&quot;;
    protected static final String READ_ONLY_MODE_ON_ANY_DISK_FULL_ENABLED = &quot;readOnlyModeOnAnyDiskFullEnabled&quot;;
    //Whether the bookie is force started in ReadOnly mode
    protected static final String FORCE_READ_ONLY_BOOKIE = &quot;forceReadOnlyBookie&quot;;
    //Whether to persist the bookie status
    protected static final String PERSIST_BOOKIE_STATUS_ENABLED = &quot;persistBookieStatusEnabled&quot;;
    //Disk utilization
    protected static final String DISK_USAGE_THRESHOLD = &quot;diskUsageThreshold&quot;;
    protected static final String DISK_USAGE_WARN_THRESHOLD = &quot;diskUsageWarnThreshold&quot;;
    protected static final String DISK_USAGE_LWM_THRESHOLD = &quot;diskUsageLwmThreshold&quot;;
    protected static final String DISK_CHECK_INTERVAL = &quot;diskCheckInterval&quot;;

    // Replication parameters
    protected static final String AUDITOR_PERIODIC_CHECK_INTERVAL = &quot;auditorPeriodicCheckInterval&quot;;
    protected static final String AUDITOR_PERIODIC_BOOKIE_CHECK_INTERVAL = &quot;auditorPeriodicBookieCheckInterval&quot;;
    protected static final String AUDITOR_PERIODIC_PLACEMENT_POLICY_CHECK_INTERVAL =
                                                                &quot;auditorPeriodicPlacementPolicyCheckInterval&quot;;
    protected static final String REPAIRED_PLACEMENT_POLICY_NOT_ADHERING_BOOKIE_ENABLED =
                                                                &quot;repairedPlacementPolicyNotAdheringBookieEnabled&quot;;
    protected static final String AUDITOR_LEDGER_VERIFICATION_PERCENTAGE = &quot;auditorLedgerVerificationPercentage&quot;;
    protected static final String AUTO_RECOVERY_DAEMON_ENABLED = &quot;autoRecoveryDaemonEnabled&quot;;
    protected static final String LOST_BOOKIE_RECOVERY_DELAY = &quot;lostBookieRecoveryDelay&quot;;
    protected static final String RW_REREPLICATE_BACKOFF_MS = &quot;rwRereplicateBackoffMs&quot;;
    protected static final String UNDERREPLICATED_LEDGER_RECOVERY_GRACE_PERIOD =
            &quot;underreplicatedLedgerRecoveryGracePeriod&quot;;
    protected static final String AUDITOR_REPLICAS_CHECK_INTERVAL = &quot;auditorReplicasCheckInterval&quot;;
    protected static final String AUDITOR_MAX_NUMBER_OF_CONCURRENT_OPEN_LEDGER_OPERATIONS =
        &quot;auditorMaxNumberOfConcurrentOpenLedgerOperations&quot;;
    protected static final String AUDITOR_ACQUIRE_CONCURRENT_OPEN_LEDGER_OPERATIONS_TIMEOUT_MSEC =
        &quot;auditorAcquireConcurrentOpenLedgerOperationsTimeOutMSec&quot;;
    protected static final String IN_FLIGHT_READ_ENTRY_NUM_IN_LEDGER_CHECKER = &quot;inFlightReadEntryNumInLedgerChecker&quot;;


    // Worker Thread parameters.
    protected static final String NUM_ADD_WORKER_THREADS = &quot;numAddWorkerThreads&quot;;
    protected static final String NUM_READ_WORKER_THREADS = &quot;numReadWorkerThreads&quot;;
    protected static final String MAX_PENDING_READ_REQUESTS_PER_THREAD = &quot;maxPendingReadRequestsPerThread&quot;;
    protected static final String MAX_PENDING_ADD_REQUESTS_PER_THREAD = &quot;maxPendingAddRequestsPerThread&quot;;
    protected static final String NUM_LONG_POLL_WORKER_THREADS = &quot;numLongPollWorkerThreads&quot;;
    protected static final String NUM_HIGH_PRIORITY_WORKER_THREADS = &quot;numHighPriorityWorkerThreads&quot;;
    protected static final String READ_WORKER_THREADS_THROTTLING_ENABLED = &quot;readWorkerThreadsThrottlingEnabled&quot;;

    // Long poll parameters
    protected static final String REQUEST_TIMER_TICK_DURATION_MILLISEC = &quot;requestTimerTickDurationMs&quot;;
    protected static final String REQUEST_TIMER_NO_OF_TICKS = &quot;requestTimerNumTicks&quot;;

    protected static final String READ_BUFFER_SIZE = &quot;readBufferSizeBytes&quot;;
    protected static final String WRITE_BUFFER_SIZE = &quot;writeBufferSizeBytes&quot;;
    // Whether the bookie should use its hostname or ipaddress for the
    // registration.
    protected static final String USE_HOST_NAME_AS_BOOKIE_ID = &quot;useHostNameAsBookieID&quot;;
    protected static final String USE_SHORT_HOST_NAME = &quot;useShortHostName&quot;;
    protected static final String ENABLE_LOCAL_TRANSPORT = &quot;enableLocalTransport&quot;;
    protected static final String DISABLE_SERVER_SOCKET_BIND = &quot;disableServerSocketBind&quot;;

    protected static final String SORTED_LEDGER_STORAGE_ENABLED = &quot;sortedLedgerStorageEnabled&quot;;
    protected static final String SKIP_LIST_SIZE_LIMIT = &quot;skipListSizeLimit&quot;;
    protected static final String SKIP_LIST_CHUNK_SIZE_ENTRY = &quot;skipListArenaChunkSize&quot;;
    protected static final String SKIP_LIST_MAX_ALLOC_ENTRY = &quot;skipListArenaMaxAllocSize&quot;;

    // Statistics Parameters
    protected static final String ENABLE_STATISTICS = &quot;enableStatistics&quot;;
    protected static final String STATS_PROVIDER_CLASS = &quot;statsProviderClass&quot;;


    // Rx adaptive ByteBuf allocator parameters
    protected static final String BYTEBUF_ALLOCATOR_SIZE_INITIAL = &quot;byteBufAllocatorSizeInitial&quot;;
    protected static final String BYTEBUF_ALLOCATOR_SIZE_MIN = &quot;byteBufAllocatorSizeMin&quot;;
    protected static final String BYTEBUF_ALLOCATOR_SIZE_MAX = &quot;byteBufAllocatorSizeMax&quot;;

    // Bookie auth provider factory class name
    protected static final String BOOKIE_AUTH_PROVIDER_FACTORY_CLASS = &quot;bookieAuthProviderFactoryClass&quot;;

    protected static final String MIN_USABLESIZE_FOR_INDEXFILE_CREATION = &quot;minUsableSizeForIndexFileCreation&quot;;
    protected static final String MIN_USABLESIZE_FOR_ENTRYLOG_CREATION = &quot;minUsableSizeForEntryLogCreation&quot;;
    protected static final String MIN_USABLESIZE_FOR_HIGH_PRIORITY_WRITES = &quot;minUsableSizeForHighPriorityWrites&quot;;

    protected static final String ALLOW_MULTIPLEDIRS_UNDER_SAME_DISKPARTITION =
        &quot;allowMultipleDirsUnderSameDiskPartition&quot;;

    // Http Server parameters
    protected static final String HTTP_SERVER_ENABLED = &quot;httpServerEnabled&quot;;
    protected static final String HTTP_SERVER_PORT = &quot;httpServerPort&quot;;
    protected static final String HTTP_SERVER_HOST = &quot;httpServerHost&quot;;
    protected static final String HTTP_SERVER_TLS_ENABLE = &quot;httpServerTlsEnable&quot;;
    protected static final String HTTP_SERVER_KEY_STORE_PATH = &quot;httpServerKeyStorePath&quot;;
    protected static final String HTTP_SERVER_KEY_STORE_PASSWORD = &quot;httpServerKeyStorePassword&quot;;
    protected static final String HTTP_SERVER_TRUST_STORE_PATH = &quot;httpServerTrustStorePath&quot;;
    protected static final String HTTP_SERVER_TRUST_STORE_PASSWORD = &quot;httpServerTrustStorePassword&quot;;

    // Lifecycle Components
    protected static final String EXTRA_SERVER_COMPONENTS = &quot;extraServerComponents&quot;;
    protected static final String IGNORE_EXTRA_SERVER_COMPONENTS_STARTUP_FAILURES =
        &quot;ignoreExtraServerComponentsStartupFailures&quot;;

    // Registration
    protected static final String REGISTRATION_MANAGER_CLASS = &quot;registrationManagerClass&quot;;

    // Stats
    protected static final String ENABLE_TASK_EXECUTION_STATS = &quot;enableTaskExecutionStats&quot;;

    /*
     * config specifying if the entrylog per ledger is enabled or not.
     */
    protected static final String ENTRY_LOG_PER_LEDGER_ENABLED = &quot;entryLogPerLedgerEnabled&quot;;
    // In the case of multipleentrylogs, multiple threads can be used to flush the memtable parallelly.
    protected static final String NUMBER_OF_MEMTABLE_FLUSH_THREADS = &quot;numOfMemtableFlushThreads&quot;;


    /*
     * config specifying if the entrylog per ledger is enabled, then the amount
     * of time EntryLogManagerForEntryLogPerLedger should wait for closing the
     * entrylog file after the last addEntry call for that ledger, if explicit
     * writeclose for that ledger is not received.
     */
    protected static final String ENTRYLOGMAP_ACCESS_EXPIRYTIME_INSECONDS = &quot;entrylogMapAccessExpiryTimeInSeconds&quot;;

    /*
     * in entryLogPerLedger feature, this specifies the maximum number of
     * entrylogs that can be active at a given point in time. If there are more
     * number of active entryLogs then the maximumNumberOfActiveEntryLogs then
     * the entrylog will be evicted from the cache.
     */
    protected static final String MAXIMUM_NUMBER_OF_ACTIVE_ENTRYLOGS = &quot;maximumNumberOfActiveEntryLogs&quot;;

    /*
     * in EntryLogManagerForEntryLogPerLedger, this config value specifies the
     * metrics cache size limits in multiples of entrylogMap cache size limits.
     */
    protected static final String ENTRY_LOG_PER_LEDGER_COUNTER_LIMITS_MULT_FACTOR =
            &quot;entryLogPerLedgerCounterLimitsMultFactor&quot;;

    // Perform local consistency check on bookie startup
    protected static final String LOCAL_CONSISTENCY_CHECK_ON_STARTUP = &quot;localConsistencyCheckOnStartup&quot;;

    // Certificate role based authorization
    protected static final String AUTHORIZED_ROLES = &quot;authorizedRoles&quot;;

    protected static final String DATA_INTEGRITY_CHECKING_ENABLED = &quot;dataIntegrityChecking&quot;;
    protected static final String DATA_INTEGRITY_COOKIE_STAMPING_ENABLED = &quot;dataIntegrityStampMissingCookies&quot;;

    // Used for default,command until or test case
    protected static final String DEFAULT_ROCKSDB_CONF = &quot;defaultRocksdbConf&quot;;

    // Used for ledgers db, doesn't need particular configuration
    protected static final String ENTRY_LOCATION_ROCKSDB_CONF = &quot;entryLocationRocksdbConf&quot;;

    // Used for location index, lots of writes and much bigger dataset
    protected static final String LEDGER_METADATA_ROCKSDB_CONF = &quot;ledgerMetadataRocksdbConf&quot;;

    /**
     * Construct a default configuration object.
     */
    public ServerConfiguration() {
<span class="nc" id="L345">        super();</span>
<span class="nc" id="L346">    }</span>

    /**
     * Construct a configuration based on other configuration.
     *
     * @param conf
     *          Other configuration
     */
    public ServerConfiguration(AbstractConfiguration conf) {
<span class="nc" id="L355">        super();</span>
<span class="nc" id="L356">        loadConf(conf);</span>
<span class="nc" id="L357">    }</span>

    /**
     * Get entry logger size limitation.
     *
     * @return entry logger size limitation
     */
    public long getEntryLogSizeLimit() {
<span class="nc" id="L365">        return ENTRY_LOG_SIZE_LIMIT_KEY.getLong(this);</span>
    }

    /**
     * Set entry logger size limitation.
     *
     * @param logSizeLimit
     *          new log size limitation
     */
    public ServerConfiguration setEntryLogSizeLimit(long logSizeLimit) {
<span class="nc" id="L375">        ENTRY_LOG_SIZE_LIMIT_KEY.set(this, logSizeLimit);</span>
<span class="nc" id="L376">        return this;</span>
    }

    /**
     * Is entry log file preallocation enabled.
     *
     * @return whether entry log file preallocation is enabled or not.
     */
    public boolean isEntryLogFilePreAllocationEnabled() {
<span class="nc" id="L385">        return this.getBoolean(ENTRY_LOG_FILE_PREALLOCATION_ENABLED, true);</span>
    }

    /**
     * Enable/disable entry log file preallocation.
     *
     * @param enabled
     *          enable/disable entry log file preallocation.
     * @return server configuration object.
     */
    public ServerConfiguration setEntryLogFilePreAllocationEnabled(boolean enabled) {
<span class="nc" id="L396">        this.setProperty(ENTRY_LOG_FILE_PREALLOCATION_ENABLED, enabled);</span>
<span class="nc" id="L397">        return this;</span>
    }

    /**
     * Get Garbage collection wait time. Default value is 10 minutes.
     * The guideline is not to set a too low value for this, if using zookeeper based
     * ledger manager. And it would be nice to align with the average lifecyle time of
     * ledgers in the system.
     *
     * @return gc wait time
     */
    public long getGcWaitTime() {
<span class="nc" id="L409">        return this.getLong(GC_WAIT_TIME, 600000);</span>
    }

    /**
     * Set garbage collection wait time.
     *
     * @param gcWaitTime
     *          gc wait time
     * @return server configuration
     */
    public ServerConfiguration setGcWaitTime(long gcWaitTime) {
<span class="nc" id="L420">        this.setProperty(GC_WAIT_TIME, Long.toString(gcWaitTime));</span>
<span class="nc" id="L421">        return this;</span>
    }

    /**
     * Get wait time in millis for garbage collection of overreplicated ledgers.
     *
     * @return gc wait time
     */
    public long getGcOverreplicatedLedgerWaitTimeMillis() {
<span class="nc" id="L430">        return this.getLong(GC_OVERREPLICATED_LEDGER_WAIT_TIME, TimeUnit.DAYS.toMillis(1));</span>
    }

    /**
     * Set wait time for garbage collection of overreplicated ledgers. Default: 1 day
     *
     * &lt;p&gt;A ledger can be overreplicated under the following circumstances:
     * 1. The ledger with few entries has bk1 and bk2 as its ensemble.
     * 2. bk1 crashes.
     * 3. bk3 replicates the ledger from bk2 and updates the ensemble to bk2 and bk3.
     * 4. bk1 comes back up.
     * 5. Now there are 3 copies of the ledger.
     *
     * @param gcWaitTime
     * @return server configuration
     */
    public ServerConfiguration setGcOverreplicatedLedgerWaitTime(long gcWaitTime, TimeUnit unit) {
<span class="nc" id="L447">        this.setProperty(GC_OVERREPLICATED_LEDGER_WAIT_TIME, Long.toString(unit.toMillis(gcWaitTime)));</span>
<span class="nc" id="L448">        return this;</span>
    }

    /**
     * Max number of concurrent requests in garbage collection of overreplicated ledgers.
     *
     * @return max number of concurrent requests
     */
    public int getGcOverreplicatedLedgerMaxConcurrentRequests() {
<span class="nc" id="L457">        return this.getInt(GC_OVERREPLICATED_LEDGER_MAX_CONCURRENT_REQUESTS, 1000);</span>
    }

    /**
     * Max number of concurrent requests in garbage collection of overreplicated ledgers. Default: 1000
     *
     * @param gcOverreplicatedLedgerMaxConcurrentRequests
     * @return server configuration
     */
    public ServerConfiguration setGcOverreplicatedLedgerMaxConcurrentRequests(
            int gcOverreplicatedLedgerMaxConcurrentRequests) {
<span class="nc" id="L468">        this.setProperty(GC_OVERREPLICATED_LEDGER_MAX_CONCURRENT_REQUESTS,</span>
<span class="nc" id="L469">                Integer.toString(gcOverreplicatedLedgerMaxConcurrentRequests));</span>
<span class="nc" id="L470">        return this;</span>
    }

    /**
     * Get whether to use transactional compaction and using a separate log for compaction or not.
     *
     * @return use transactional compaction
     */
    public boolean getUseTransactionalCompaction() {
<span class="nc" id="L479">        return this.getBoolean(USE_TRANSACTIONAL_COMPACTION, false);</span>
    }

    /**
     * Set whether to use transactional compaction and using a separate log for compaction or not.
     * @param useTransactionalCompaction
     * @return server configuration
     */
    public ServerConfiguration setUseTransactionalCompaction(boolean useTransactionalCompaction) {
<span class="nc" id="L488">        this.setProperty(USE_TRANSACTIONAL_COMPACTION, useTransactionalCompaction);</span>
<span class="nc" id="L489">        return this;</span>
    }

    /**
     * Get whether the bookie is configured to double check prior to gc.
     *
     * @return use transactional compaction
     */
    public boolean getVerifyMetadataOnGC() {
<span class="nc" id="L498">        return this.getBoolean(VERIFY_METADATA_ON_GC, false);</span>
    }

    /**
     * Set whether the bookie is configured to double check prior to gc.
     * @param verifyMetadataOnGC
     * @return server configuration
     */
    public ServerConfiguration setVerifyMetadataOnGc(boolean verifyMetadataOnGC) {
<span class="nc" id="L507">        this.setProperty(VERIFY_METADATA_ON_GC, verifyMetadataOnGC);</span>
<span class="nc" id="L508">        return this;</span>
    }

    /**
     * Get whether the bookie is configured to use persistent
     * entrylogMetadataMap.
     * @return use persistent entry-log metadata map
     */
    public boolean isGcEntryLogMetadataCacheEnabled() {
<span class="nc" id="L517">        return this.getBoolean(GC_ENTRYLOGMETADATA_CACHE_ENABLED, false);</span>
    }

    /**
     * Set whether the bookie is configured to use persistent
     * entrylogMetadataMap.
     * @param gcEntryLogMetadataCacheEnabled
     * @return server configuration
     */
    public ServerConfiguration setGcEntryLogMetadataCacheEnabled(
            boolean gcEntryLogMetadataCacheEnabled) {
<span class="nc" id="L528">        this.setProperty(GC_ENTRYLOGMETADATA_CACHE_ENABLED, gcEntryLogMetadataCacheEnabled);</span>
<span class="nc" id="L529">        return this;</span>
    }

    /**
     * Get directory to persist Entrylog metadata if
     * gcPersistentEntrylogMetadataMapEnabled is true.
     *
     * @return entrylog metadata-map persistent store dir path.(default: it
     *         creates a sub-directory under each ledger
     *         directory with name &quot;metadata-cache&quot;. If it set, it only works for one ledger directory
     *         configured for ledgerDirectories).
     */
    public String getGcEntryLogMetadataCachePath() {
<span class="nc" id="L542">        return getString(GC_ENTRYLOG_METADATA_CACHE_PATH, null);</span>
    }

    /**
     * Set directory to persist Entrylog metadata if gcPersistentEntrylogMetadataMapEnabled is true.
     * If it set, it only works for one ledger directory configured for ledgerDirectories. For multi ledgerDirectory
     * configured, keep the default value is the best practice.
     *
     * @param gcEntrylogMetadataCachePath
     * @return server configuration.
     */
    public ServerConfiguration setGcEntryLogMetadataCachePath(String gcEntrylogMetadataCachePath) {
<span class="nc" id="L554">        this.setProperty(GC_ENTRYLOG_METADATA_CACHE_PATH, gcEntrylogMetadataCachePath);</span>
<span class="nc" id="L555">        return this;</span>
    }

    public boolean isUseTargetEntryLogSizeForGc() {
<span class="nc" id="L559">        return getBoolean(USE_TARGET_ENTRYLOG_SIZE_FOR_GC, false);</span>
    }

    public ServerConfiguration setUseTargetEntryLogSizeForGc(boolean useTargetEntryLogSizeForGc) {
<span class="nc" id="L563">        this.setProperty(USE_TARGET_ENTRYLOG_SIZE_FOR_GC, useTargetEntryLogSizeForGc);</span>
<span class="nc" id="L564">        return this;</span>
    }

    /**
     * Get whether local scrub is enabled.
     *
     * @return Whether local scrub is enabled.
     */
    public boolean isLocalScrubEnabled() {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        return this.getLocalScrubPeriod() &gt; 0;</span>
    }

    /**
     * Get local scrub interval.
     *
     * @return Number of seconds between scrubs, {@literal &lt;=}0 for disabled.
     */
    public long getLocalScrubPeriod() {
<span class="nc" id="L582">        return this.getLong(LOCAL_SCRUB_PERIOD, 0);</span>
    }

    /**
     * Set local scrub period in seconds ({@literal &lt;=}0 for disabled). Scrub will be scheduled at delays
     * chosen from the interval (.5 * interval, 1.5 * interval)
     */
    public void setLocalScrubPeriod(long period) {
<span class="nc" id="L590">        this.setProperty(LOCAL_SCRUB_PERIOD, period);</span>
<span class="nc" id="L591">    }</span>

    /**
     * Get local scrub rate limit (entries/second).
     *
     * @return Max number of entries to scrub per second, 0 for disabled.
     */
    public double getLocalScrubRateLimit() {
<span class="nc" id="L599">        return this.getDouble(LOCAL_SCRUB_RATE_LIMIT, 60);</span>
    }

    /**
     * Get local scrub rate limit (entries/second).
     *
     * @param scrubRateLimit Max number of entries per second to scan.
     */
    public void setLocalScrubRateLimit(double scrubRateLimit) {
<span class="nc" id="L608">        this.setProperty(LOCAL_SCRUB_RATE_LIMIT, scrubRateLimit);</span>
<span class="nc" id="L609">    }</span>

    /**
     * Get flush interval. Default value is 10 second. It isn't useful to decrease
     * this value, since ledger storage only checkpoints when an entry logger file
     * is rolled.
     *
     * @return flush interval
     */
    public int getFlushInterval() {
<span class="nc" id="L619">        return this.getInt(FLUSH_INTERVAL, 10000);</span>
    }

    /**
     * Set flush interval.
     *
     * @param flushInterval
     *          Flush Interval
     * @return server configuration
     */
    public ServerConfiguration setFlushInterval(int flushInterval) {
<span class="nc" id="L630">        this.setProperty(FLUSH_INTERVAL, Integer.toString(flushInterval));</span>
<span class="nc" id="L631">        return this;</span>
    }

    /**
     * Set entry log flush interval in bytes.
     *
     * &lt;p&gt;Default is 0. 0 or less disables this feature and effectively flush
     * happens on log rotation.
     *
     * &lt;p&gt;Flushing in smaller chunks but more frequently reduces spikes in disk
     * I/O. Flushing too frequently may also affect performance negatively.
     *
     * @return Entry log flush interval in bytes
     */
    public long getFlushIntervalInBytes() {
<span class="nc" id="L646">        return this.getLong(FLUSH_ENTRYLOG_INTERVAL_BYTES, 0);</span>
    }

    /**
     * Set entry log flush interval in bytes.
     *
     * @param flushInterval in bytes
     * @return server configuration
     */
    public ServerConfiguration setFlushIntervalInBytes(long flushInterval) {
<span class="nc" id="L656">        this.setProperty(FLUSH_ENTRYLOG_INTERVAL_BYTES, Long.toString(flushInterval));</span>
<span class="nc" id="L657">        return this;</span>
    }


    /**
     * Get bookie death watch interval.
     *
     * @return watch interval
     */
    public int getDeathWatchInterval() {
<span class="nc" id="L667">        return this.getInt(DEATH_WATCH_INTERVAL, 1000);</span>
    }

    /**
     * Get open file limit. Default value is 20000.
     *
     * @return max number of files to open
     */
    public int getOpenFileLimit() {
<span class="nc" id="L676">        return this.getInt(OPEN_FILE_LIMIT, 20000);</span>
    }

    /**
     * Set limitation of number of open files.
     *
     * @param fileLimit
     *          Limitation of number of open files.
     * @return server configuration
     */
    public ServerConfiguration setOpenFileLimit(int fileLimit) {
<span class="nc" id="L687">        setProperty(OPEN_FILE_LIMIT, fileLimit);</span>
<span class="nc" id="L688">        return this;</span>
    }

    /**
     * Get limitation number of index pages in ledger cache.
     *
     * @return max number of index pages in ledger cache
     */
    public int getPageLimit() {
<span class="nc" id="L697">        return this.getInt(PAGE_LIMIT, -1);</span>
    }

    /**
     * Set limitation number of index pages in ledger cache.
     *
     * @param pageLimit
     *          Limitation of number of index pages in ledger cache.
     * @return server configuration
     */
    public ServerConfiguration setPageLimit(int pageLimit) {
<span class="nc" id="L708">        this.setProperty(PAGE_LIMIT, pageLimit);</span>
<span class="nc" id="L709">        return this;</span>
    }

    /**
     * Get page size.
     *
     * @return page size in ledger cache
     */
    public int getPageSize() {
<span class="nc" id="L718">        return this.getInt(PAGE_SIZE, 8192);</span>
    }

    /**
     * Set page size.
     *
     * @see #getPageSize()
     *
     * @param pageSize
     *          Page Size
     * @return Server Configuration
     */
    public ServerConfiguration setPageSize(int pageSize) {
<span class="nc" id="L731">        this.setProperty(PAGE_SIZE, pageSize);</span>
<span class="nc" id="L732">        return this;</span>
    }

    /**
     * Get the minimum total size for the internal file info cache tables.
     * Providing a large enough estimate at construction time avoids the need for
     * expensive resizing operations later, but setting this value unnecessarily high
     * wastes memory.
     *
     * @return minimum size of initial file info cache.
     */
    public int getFileInfoCacheInitialCapacity() {
<span class="nc" id="L744">        return getInt(FILEINFO_CACHE_INITIAL_CAPACITY, Math.max(getOpenFileLimit() / 4, 64));</span>
    }

    /**
     * Set the minimum total size for the internal file info cache tables for initialization.
     *
     * @param initialCapacity
     *          Initial capacity of file info cache table.
     * @return server configuration instance.
     */
    public ServerConfiguration setFileInfoCacheInitialCapacity(int initialCapacity) {
<span class="nc" id="L755">        setProperty(FILEINFO_CACHE_INITIAL_CAPACITY, initialCapacity);</span>
<span class="nc" id="L756">        return this;</span>
    }

    /**
     * Get the max idle time allowed for a open file info existed in file info cache.
     * If the file info is idle for a long time, exceed the given time period. The file
     * info will be evicted and closed. If the value is zero, the file info is evicted
     * only when opened files reached openFileLimit.
     *
     * @see #getOpenFileLimit
     * @return max idle time of a file info in the file info cache.
     */
    public long getFileInfoMaxIdleTime() {
<span class="nc" id="L769">        return this.getLong(FILEINFO_MAX_IDLE_TIME, 0L);</span>
    }

    /**
     * Set the max idle time allowed for a open file info existed in file info cache.
     *
     * @param idleTime
     *          Idle time, in seconds.
     * @see #getFileInfoMaxIdleTime
     * @return server configuration object.
     */
    public ServerConfiguration setFileInfoMaxIdleTime(long idleTime) {
<span class="nc" id="L781">        setProperty(FILEINFO_MAX_IDLE_TIME, idleTime);</span>
<span class="nc" id="L782">        return this;</span>
    }

    /**
     * Get fileinfo format version to write.
     *
     * @return fileinfo format version to write.
     */
    public int getFileInfoFormatVersionToWrite() {
<span class="nc" id="L791">        return this.getInt(FILEINFO_FORMAT_VERSION_TO_WRITE, 1);</span>
    }

    /**
     * Set fileinfo format version to write.
     *
     * @param version
     *            fileinfo format version to write.
     * @return server configuration.
     */
    public ServerConfiguration setFileInfoFormatVersionToWrite(int version) {
<span class="nc" id="L802">        this.setProperty(FILEINFO_FORMAT_VERSION_TO_WRITE, version);</span>
<span class="nc" id="L803">        return this;</span>
    }

    /**
     * Max journal file size.
     *
     * @return max journal file size
     */
    public long getMaxJournalSizeMB() {
<span class="nc" id="L812">        return this.getLong(MAX_JOURNAL_SIZE, 2 * 1024);</span>
    }

    /**
     * Set new max journal file size.
     *
     * @param maxJournalSize
     *          new max journal file size
     * @return server configuration
     */
    public ServerConfiguration setMaxJournalSizeMB(long maxJournalSize) {
<span class="nc" id="L823">        this.setProperty(MAX_JOURNAL_SIZE, Long.toString(maxJournalSize));</span>
<span class="nc" id="L824">        return this;</span>
    }

    /**
     * How much space should we pre-allocate at a time in the journal.
     *
     * @return journal pre-allocation size in MB
     */
    public int getJournalPreAllocSizeMB() {
<span class="nc" id="L833">        return this.getInt(JOURNAL_PRE_ALLOC_SIZE, 16);</span>
    }

    /**
     * Size of the write buffers used for the journal.
     *
     * @return journal write buffer size in KB
     */
    public int getJournalWriteBufferSizeKB() {
<span class="nc" id="L842">        return this.getInt(JOURNAL_WRITE_BUFFER_SIZE, 64);</span>
    }

    /**
     * Set the size of the write buffers used for the journal.
     *
     * @param bufferSizeKB the size of the write buffer used for the journal, in KB.
     * @return server configuration
     */
    public ServerConfiguration setJournalWriteBufferSizeKB(int bufferSizeKB) {
<span class="nc" id="L852">        setProperty(JOURNAL_WRITE_BUFFER_SIZE, bufferSizeKB);</span>
<span class="nc" id="L853">        return this;</span>
    }

    /**
     * Max number of older journal files kept.
     *
     * @return max number of older journal files to kept
     */
    public int getMaxBackupJournals() {
<span class="nc" id="L862">        return this.getInt(MAX_BACKUP_JOURNALS, 5);</span>
    }

    /**
     * Set max number of older journal files to kept.
     *
     * @param maxBackupJournals
     *          Max number of older journal files
     * @return server configuration
     */
    public ServerConfiguration setMaxBackupJournals(int maxBackupJournals) {
<span class="nc" id="L873">        this.setProperty(MAX_BACKUP_JOURNALS, Integer.toString(maxBackupJournals));</span>
<span class="nc" id="L874">        return this;</span>
    }

    /**
     * All the journal writes and commits should be aligned to given size. If not,
     * zeros will be padded to align to given size.
     *
     * @return journal alignment size
     */
    public int getJournalAlignmentSize() {
<span class="nc" id="L884">        return this.getInt(JOURNAL_ALIGNMENT_SIZE, 512);</span>
    }

    /**
     * Set journal alignment size.
     *
     * @param size
     *          journal alignment size.
     * @return server configuration.
     */
    public ServerConfiguration setJournalAlignmentSize(int size) {
<span class="nc" id="L895">        this.setProperty(JOURNAL_ALIGNMENT_SIZE, size);</span>
<span class="nc" id="L896">        return this;</span>
    }

    /**
     * Get journal format version to write.
     *
     * @return journal format version to write.
     */
    public int getJournalFormatVersionToWrite() {
<span class="nc" id="L905">        return this.getInt(JOURNAL_FORMAT_VERSION_TO_WRITE, 6);</span>
    }

    /**
     * Set journal format version to write.
     *
     * @param version
     *          journal format version to write.
     * @return server configuration.
     */
    public ServerConfiguration setJournalFormatVersionToWrite(int version) {
<span class="nc" id="L916">        this.setProperty(JOURNAL_FORMAT_VERSION_TO_WRITE, version);</span>
<span class="nc" id="L917">        return this;</span>
    }

    /**
     * Set the size of the journal queue.
     *
     * @param journalQueueSize
     *            the max size of journal queue
     * @return server configuration.
     */
    public ServerConfiguration setJournalQueueSize(int journalQueueSize) {
<span class="nc" id="L928">        this.setProperty(JOURNAL_QUEUE_SIZE, journalQueueSize);</span>
<span class="nc" id="L929">        return this;</span>
    }

    /**
     * Get size of journal queue.
     *
     * @return the max size of journal queue.
     */
    public int getJournalQueueSize() {
<span class="nc" id="L938">        return this.getInt(JOURNAL_QUEUE_SIZE, 10_000);</span>
    }

    /**
     * Set the max amount of memory that can be used by the journal.
     *
     * @param journalMaxMemorySizeMb
     *            the max amount of memory for the journal
     * @return server configuration.
     */
    public ServerConfiguration setJournalMaxMemorySizeMb(long journalMaxMemorySizeMb) {
<span class="nc" id="L949">        this.setProperty(JOURNAL_MAX_MEMORY_SIZE_MB, journalMaxMemorySizeMb);</span>
<span class="nc" id="L950">        return this;</span>
    }

    /**
     * Get the max amount of memory that can be used by the journal.
     *
     * @return the max amount of memory for the journal
     */
    public long getJournalMaxMemorySizeMb() {
        // Default is taking 5% of max direct memory (and convert to MB).
<span class="nc" id="L960">        long estimateMaxDirectMemory = io.netty.util.internal.PlatformDependent.estimateMaxDirectMemory();</span>
<span class="nc" id="L961">        long defaultValue = (long) (estimateMaxDirectMemory * 0.05 / 1024 / 1024);</span>
<span class="nc" id="L962">        return this.getLong(JOURNAL_MAX_MEMORY_SIZE_MB, defaultValue);</span>
    }

    /**
     * Set PageCache flush interval in second.
     *
     * @Param journalPageCacheFlushInterval
     *          journal pageCache flush interval when journalSyncData closed
     * @return server configuration.
     */
    public ServerConfiguration setJournalPageCacheFlushIntervalMSec(long journalPageCacheFlushIntervalMSec) {
<span class="nc" id="L973">        this.setProperty(JOURNAL_PAGECACHE_FLUSH_INTERVAL_MSEC, journalPageCacheFlushIntervalMSec);</span>
<span class="nc" id="L974">        return this;</span>
    }

    /**
     * Get journal pageCache flush interval.
     *
     * @return journal pageCache flush interval.
     */
    public long getJournalPageCacheFlushIntervalMSec() {
<span class="nc" id="L983">        return this.getLong(JOURNAL_PAGECACHE_FLUSH_INTERVAL_MSEC, 1000);</span>
    }

    /**
     * Set JournalChannelProvider classname.
     * @param journalChannelProvider
     *          The JournalChannelProvider classname. The class must implements {@link FileChannelProvider} and
     *          no args constructor is needed.
     * @return
     */
    public ServerConfiguration setJournalChannelProvider(String journalChannelProvider) {
<span class="nc" id="L994">        this.setProperty(JOURNAL_CHANNEL_PROVIDER, journalChannelProvider);</span>
<span class="nc" id="L995">        return this;</span>
    }

    /**
     *
     * @return
     */
    public String getJournalChannelProvider() {
<span class="nc" id="L1003">        return this.getString(JOURNAL_CHANNEL_PROVIDER, &quot;org.apache.bookkeeper.bookie.DefaultFileChannelProvider&quot;);</span>
    }

    /**
     * Get reuse journal files.
     * @return
     */
    public boolean getJournalReuseFiles() {
<span class="nc" id="L1011">        return this.getBoolean(JOURNAL_REUSE_FILES, false);</span>
    }

    /**
     * Set reuse journal files.
     * @param journalReuseFiles
     * @return
     */
    public ServerConfiguration setJournalReuseFiles(boolean journalReuseFiles) {
<span class="nc" id="L1020">        setProperty(JOURNAL_REUSE_FILES, journalReuseFiles);</span>
<span class="nc" id="L1021">        return this;</span>
    }

    /**
     * Get max number of adds in progress. 0 == unlimited.
     *
     * @return Max number of adds in progress.
     */
    public int getMaxAddsInProgressLimit() {
<span class="nc" id="L1030">        return this.getInt(MAX_ADDS_IN_PROGRESS_LIMIT, 0);</span>
    }

    /**
     * Set max number of adds in progress. 0 == unlimited.
     *
     * @param value
     *          max number of adds in progress.
     * @return server configuration.
     */
    public ServerConfiguration setMaxAddsInProgressLimit(int value) {
<span class="nc" id="L1041">        this.setProperty(MAX_ADDS_IN_PROGRESS_LIMIT, value);</span>
<span class="nc" id="L1042">        return this;</span>
    }

    /**
     * Get max number of reads in progress. 0 == unlimited.
     *
     * @return Max number of reads in progress.
     */
    public int getMaxReadsInProgressLimit() {
<span class="nc" id="L1051">        return this.getInt(MAX_READS_IN_PROGRESS_LIMIT, 0);</span>
    }

    /**
     * Set max number of reads in progress. 0 == unlimited.
     *
     * @param value
     *          max number of reads in progress.
     * @return server configuration.
     */
    public ServerConfiguration setMaxReadsInProgressLimit(int value) {
<span class="nc" id="L1062">        this.setProperty(MAX_READS_IN_PROGRESS_LIMIT, value);</span>
<span class="nc" id="L1063">        return this;</span>
    }

    /**
     * Configures action in case if server timed out sending response to the client.
     * true == close the channel and drop response
     * false == drop response
     * Requires waitTimeoutOnBackpressureMs &gt;= 0 otherwise ignored.
     *
     * @return value indicating if channel should be closed.
     */
    public boolean getCloseChannelOnResponseTimeout(){
<span class="nc" id="L1075">        return this.getBoolean(CLOSE_CHANNEL_ON_RESPONSE_TIMEOUT, false);</span>
    }

    /**
     * Configures action in case if server timed out sending response to the client.
     * true == close the channel and drop response
     * false == drop response
     * Requires waitTimeoutOnBackpressureMs &gt;= 0 otherwise ignored.
     *
     * @param value
     * @return server configuration.
     */
    public ServerConfiguration setCloseChannelOnResponseTimeout(boolean value) {
<span class="nc" id="L1088">        this.setProperty(CLOSE_CHANNEL_ON_RESPONSE_TIMEOUT, value);</span>
<span class="nc" id="L1089">        return this;</span>
    }

    /**
     * Timeout controlling wait on response send in case of unresponsive client
     * (i.e. client in long GC etc.)
     *
     * @return timeout value
     *        negative value disables the feature
     *        0 to allow request to fail immediately
     *        Default is -1 (disabled)
     */
    public long getWaitTimeoutOnResponseBackpressureMillis() {
<span class="nc" id="L1102">        return getLong(WAIT_TIMEOUT_ON_RESPONSE_BACKPRESSURE, -1);</span>
    }

    /**
     * Timeout controlling wait on response send in case of unresponsive client
     * (i.e. client in long GC etc.)
     *
     * @param value
     *        negative value disables the feature
     *        0 to allow request to fail immediately
     *        Default is -1 (disabled)
     * @return client configuration.
     */
    public ServerConfiguration setWaitTimeoutOnResponseBackpressureMillis(long value) {
<span class="nc" id="L1116">        setProperty(WAIT_TIMEOUT_ON_RESPONSE_BACKPRESSURE, value);</span>
<span class="nc" id="L1117">        return this;</span>
    }

    /**
     * Get bookie port that bookie server listen on.
     *
     * @return bookie port
     */
    public int getBookiePort() {
<span class="nc" id="L1126">        return this.getInt(BOOKIE_PORT, 3181);</span>
    }

    /**
     * Set new bookie port that bookie server listen on.
     *
     * @param port
     *          Port to listen on
     * @return server configuration
     */
    public ServerConfiguration setBookiePort(int port) {
<span class="nc" id="L1137">        this.setProperty(BOOKIE_PORT, Integer.toString(port));</span>
<span class="nc" id="L1138">        return this;</span>
    }

    /**
     * Get the network interface that the bookie should
     * listen for connections on. If this is null, then the bookie
     * will listen for connections on all interfaces.
     *
     * @return the network interface to listen on, e.g. eth0, or
     *         null if none is specified
     */
    public String getListeningInterface() {
<span class="nc" id="L1150">        return this.getString(LISTENING_INTERFACE);</span>
    }

    /**
     * Set the network interface that the bookie should listen on.
     * If not set, the bookie will listen on all interfaces.
     *
     * @param iface the interface to listen on
     */
    public ServerConfiguration setListeningInterface(String iface) {
<span class="nc" id="L1160">        this.setProperty(LISTENING_INTERFACE, iface);</span>
<span class="nc" id="L1161">        return this;</span>
    }

    /**
     * Is the bookie allowed to use a loopback interface as its primary
     * interface(i.e. the interface it uses to establish its identity)?
     *
     * &lt;p&gt;By default, loopback interfaces are not allowed as the primary
     * interface.
     *
     * &lt;p&gt;Using a loopback interface as the primary interface usually indicates
     * a configuration error. For example, its fairly common in some VPS setups
     * to not configure a hostname, or to have the hostname resolve to
     * 127.0.0.1. If this is the case, then all bookies in the cluster will
     * establish their identities as 127.0.0.1:3181, and only one will be able
     * to join the cluster. For VPSs configured like this, you should explicitly
     * set the listening interface.
     *
     * @see #setListeningInterface(String)
     * @return whether a loopback interface can be used as the primary interface
     */
    public boolean getAllowLoopback() {
<span class="nc" id="L1183">        return this.getBoolean(ALLOW_LOOPBACK, false);</span>
    }

    /**
     * Configure the bookie to allow loopback interfaces to be used
     * as the primary bookie interface.
     *
     * @see #getAllowLoopback
     * @param allow whether to allow loopback interfaces
     * @return server configuration
     */
    public ServerConfiguration setAllowLoopback(boolean allow) {
<span class="nc" id="L1195">        this.setProperty(ALLOW_LOOPBACK, allow);</span>
<span class="nc" id="L1196">        return this;</span>
    }

     /**
     * Get the configured BookieId for the bookie.
     *
     * &lt;p&gt;If present, this setting will take precedence over the
     * automatic BookieId generation, based on Network Addresses.
     *
     * @see #setBookieId(java.lang.String)
     * @see #getAdvertisedAddress()
     * @return the configure address to be advertised
     */
    public String getBookieId() {
<span class="nc" id="L1210">        return this.getString(BOOKIE_ID, null);</span>
    }

    /**
     * Configure the bookie to advertise a specific BookieId.
     *
     * &lt;p&gt;By default, a bookie will advertise a BookieId computed
     * from the primary network endpoint addresss.
     *
     * @see #getBookieId()
     * @see #setAdvertisedAddress(java.lang.String)
     * @param bookieId the bookie id
     *
     * @return server configuration
     */
    public ServerConfiguration setBookieId(String bookieId) {
<span class="nc" id="L1226">        BookieId.parse(bookieId);</span>
<span class="nc" id="L1227">        this.setProperty(BOOKIE_ID, bookieId);</span>
<span class="nc" id="L1228">        return this;</span>
    }

    /**
     * Get the configured advertised address for the bookie.
     *
     * &lt;p&gt;If present, this setting will take precedence over the
     * {@link #setListeningInterface(String)} and
     * {@link #setUseHostNameAsBookieID(boolean)}.
     *
     * @see #setAdvertisedAddress(String)
     * @return the configure address to be advertised
     */
    public String getAdvertisedAddress() {
<span class="nc" id="L1242">        return this.getString(ADVERTISED_ADDRESS, null);</span>
    }

    /**
     * Configure the bookie to advertise a specific address.
     *
     * &lt;p&gt;By default, a bookie will advertise either its own IP or hostname,
     * depending on the {@link #getUseHostNameAsBookieID()} setting.
     *
     * &lt;p&gt;When the advertised is set to a non-empty string, the bookie will
     * register and advertise using this address.
     *
     * &lt;p&gt;If present, this setting will take precedence over the
     * {@link #setListeningInterface(String)} and
     * {@link #setUseHostNameAsBookieID(boolean)}.
     *
     * @see #getAdvertisedAddress()
     * @param advertisedAddress
     *            whether to allow loopback interfaces
     * @return server configuration
     */
    public ServerConfiguration setAdvertisedAddress(String advertisedAddress) {
<span class="nc" id="L1264">        this.setProperty(ADVERTISED_ADDRESS, advertisedAddress);</span>
<span class="nc" id="L1265">        return this;</span>
    }

    /**
     * Is the bookie allowed to use an ephemeral port (port 0) as its server port.
     *
     * &lt;p&gt;By default, an ephemeral port is not allowed. Using an ephemeral port
     * as the service port usually indicates a configuration error. However, in unit
     * tests, using ephemeral port will address port conflicts problem and allow
     * running tests in parallel.
     *
     * @return whether is allowed to use an ephemeral port.
     */
    public boolean getAllowEphemeralPorts() {
<span class="nc" id="L1279">        return this.getBoolean(ALLOW_EPHEMERAL_PORTS, false);</span>
    }

    /**
     * Configure the bookie to allow using an ephemeral port.
     *
     * @param allow whether to allow using an ephemeral port.
     * @return server configuration
     */
    public ServerConfiguration setAllowEphemeralPorts(boolean allow) {
<span class="nc" id="L1289">        this.setProperty(ALLOW_EPHEMERAL_PORTS, allow);</span>
<span class="nc" id="L1290">        return this;</span>
    }

    /**
     * Return whether we should allow addition of ledger/index dirs to an existing bookie.
     *
     * @return true if the addition is allowed; false otherwise
     */
    public boolean getAllowStorageExpansion() {
<span class="nc" id="L1299">        return this.getBoolean(ALLOW_STORAGE_EXPANSION, false);</span>
    }

    /**
     * Change the setting of whether or not we should allow ledger/index
     * dirs to be added to the current set of dirs.
     *
     * @param val - true if new ledger/index dirs can be added; false otherwise.
     *
     * @return server configuration
     */
    public ServerConfiguration setAllowStorageExpansion(boolean val) {
<span class="nc" id="L1311">        this.setProperty(ALLOW_STORAGE_EXPANSION, val);</span>
<span class="nc" id="L1312">        return this;</span>
    }

    /**
     * Get dir names to store journal files.
     *
     * @return journal dir name
     */
    public String[] getJournalDirNames() {
<span class="nc" id="L1321">        String[] journalDirs = this.getStringArray(JOURNAL_DIRS);</span>
<span class="nc bnc" id="L1322" title="All 6 branches missed.">        if (journalDirs == null || journalDirs.length == 0</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                || (journalDirs.length == 1 &amp;&amp; StringUtils.isEmpty(journalDirs[0]))) {</span>
<span class="nc" id="L1324">            return new String[] { getJournalDirName() };</span>
        }
<span class="nc" id="L1326">        return journalDirs;</span>
    }

    /**
     * Get dir name to store journal files.
     *
     * @return journal dir name
     */
    @Deprecated
    public String getJournalDirName() {
<span class="nc" id="L1336">        return this.getString(JOURNAL_DIR, &quot;/tmp/bk-txn&quot;);</span>
    }

    /**
     * Get dir name to store journal files.
     *
     * @return journal dir name
     */
    public String getJournalDirNameWithoutDefault() {
<span class="nc" id="L1345">        return this.getString(JOURNAL_DIR);</span>
    }


    /**
     * Set dir name to store journal files.
     *
     * @param journalDir
     *          Dir to store journal files
     * @return server configuration
     */
    public ServerConfiguration setJournalDirName(String journalDir) {
<span class="nc" id="L1357">        this.setProperty(JOURNAL_DIRS, new String[] {journalDir});</span>
<span class="nc" id="L1358">        return this;</span>
    }

    /**
     * Set dir names to store journal files.
     *
     * @param journalDirs
     *          Dir to store journal files
     * @return server configuration
     */
    public ServerConfiguration setJournalDirsName(String[] journalDirs) {
<span class="nc" id="L1369">        this.setProperty(JOURNAL_DIRS, journalDirs);</span>
<span class="nc" id="L1370">        return this;</span>
    }

    /**
     * Get dirs to store journal files.
     *
     * @return journal dirs, if no journal dir provided return null
     */
    public File[] getJournalDirs() {
<span class="nc" id="L1379">        String[] journalDirNames = getJournalDirNames();</span>
<span class="nc" id="L1380">        File[] journalDirs = new File[journalDirNames.length];</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">        for (int i = 0; i &lt; journalDirNames.length; i++) {</span>
<span class="nc" id="L1382">            journalDirs[i] = new File(journalDirNames[i]);</span>
        }
<span class="nc" id="L1384">        return journalDirs;</span>
    }

    /**
     * Get dir names to store ledger data.
     *
     * @return ledger dir names, if not provided return null
     */
    public String[] getLedgerDirWithoutDefault() {
<span class="nc" id="L1393">        return this.getStringArray(LEDGER_DIRS);</span>
    }

    /**
     * Get dir names to store ledger data.
     *
     * @return ledger dir names, if not provided return null
     */
    public String[] getLedgerDirNames() {
<span class="nc" id="L1402">        String[] ledgerDirs = this.getStringArray(LEDGER_DIRS);</span>
<span class="nc bnc" id="L1403" title="All 4 branches missed.">        if ((null == ledgerDirs) || (0 == ledgerDirs.length)) {</span>
<span class="nc" id="L1404">            return new String[] { &quot;/tmp/bk-data&quot; };</span>
        }
<span class="nc" id="L1406">        return ledgerDirs;</span>
    }

    /**
     * Set dir names to store ledger data.
     *
     * @param ledgerDirs
     *          Dir names to store ledger data
     * @return server configuration
     */
    public ServerConfiguration setLedgerDirNames(String[] ledgerDirs) {
<span class="nc bnc" id="L1417" title="All 2 branches missed.">        if (null == ledgerDirs) {</span>
<span class="nc" id="L1418">            return this;</span>
        }
<span class="nc" id="L1420">        this.setProperty(LEDGER_DIRS, ledgerDirs);</span>
<span class="nc" id="L1421">        return this;</span>
    }

    /**
     * Get dirs that stores ledger data.
     *
     * @return ledger dirs
     */
    public File[] getLedgerDirs() {
<span class="nc" id="L1430">        String[] ledgerDirNames = getLedgerDirNames();</span>

<span class="nc" id="L1432">        File[] ledgerDirs = new File[ledgerDirNames.length];</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">        for (int i = 0; i &lt; ledgerDirNames.length; i++) {</span>
<span class="nc" id="L1434">            ledgerDirs[i] = new File(ledgerDirNames[i]);</span>
        }
<span class="nc" id="L1436">        return ledgerDirs;</span>
    }

    /**
     * Get dir name to store index files.
     *
     * @return ledger index dir name, if no index dirs provided return null
     */
    public String[] getIndexDirNames() {
<span class="nc bnc" id="L1445" title="All 2 branches missed.">        if (!this.containsKey(INDEX_DIRS)) {</span>
<span class="nc" id="L1446">            return null;</span>
        }
<span class="nc" id="L1448">        return this.getStringArray(INDEX_DIRS);</span>
    }

    /**
     * Set dir name to store index files.
     *
     * @param indexDirs
     *          Index dir names
     * @return server configuration.
     */
    public ServerConfiguration setIndexDirName(String[] indexDirs) {
<span class="nc" id="L1459">        this.setProperty(INDEX_DIRS, indexDirs);</span>
<span class="nc" id="L1460">        return this;</span>
    }

    /**
     * Get index dir to store ledger index files.
     *
     * @return index dirs, if no index dirs provided return null
     */
    public File[] getIndexDirs() {
<span class="nc" id="L1469">        String[] idxDirNames = getIndexDirNames();</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        if (null == idxDirNames) {</span>
<span class="nc" id="L1471">            return null;</span>
        }
<span class="nc" id="L1473">        File[] idxDirs = new File[idxDirNames.length];</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">        for (int i = 0; i &lt; idxDirNames.length; i++) {</span>
<span class="nc" id="L1475">            idxDirs[i] = new File(idxDirNames[i]);</span>
        }
<span class="nc" id="L1477">        return idxDirs;</span>
    }

    /**
     * Is tcp connection no delay.
     *
     * @return tcp socket nodelay setting
     */
    public boolean getServerTcpNoDelay() {
<span class="nc" id="L1486">        return getBoolean(SERVER_TCP_NODELAY, true);</span>
    }

    /**
     * Set socket nodelay setting.
     *
     * @param noDelay
     *          NoDelay setting
     * @return server configuration
     */
    public ServerConfiguration setServerTcpNoDelay(boolean noDelay) {
<span class="nc" id="L1497">        setProperty(SERVER_TCP_NODELAY, Boolean.toString(noDelay));</span>
<span class="nc" id="L1498">        return this;</span>
    }

    /**
     * Get the number of IO threads. This is the number of
     * threads used by Netty to handle TCP connections.
     *
     * @return the number of IO threads
     */
    public int getServerNumIOThreads() {
<span class="nc" id="L1508">        return getInt(SERVER_NUM_IO_THREADS, 2 * Runtime.getRuntime().availableProcessors());</span>
    }

    /**
     * Get the number of Acceptor threads.
     *
     * @return the number of Acceptor threads
     */
    public int getServerNumAcceptorThreads() {
<span class="nc" id="L1517">        return getInt(SERVER_NUM_ACCEPTOR_THREADS, 1);</span>
    }

    /**
     * Set the number of IO threads.
     *
     * &lt;p&gt;
     * This is the number of threads used by Netty to handle TCP connections.
     * &lt;/p&gt;
     *
     * @see #getServerNumIOThreads()
     * @param numThreads number of IO threads used for bookkeeper
     * @return client configuration
     */
    public ServerConfiguration setServerNumIOThreads(int numThreads) {
<span class="nc" id="L1532">        setProperty(SERVER_NUM_IO_THREADS, Integer.toString(numThreads));</span>
<span class="nc" id="L1533">        return this;</span>
    }

    /**
     * Timeout to drain the socket on close.
     *
     * @return socket linger setting
     */
    public int getServerSockLinger() {
<span class="nc" id="L1542">        return getInt(SERVER_SOCK_LINGER, 0);</span>
    }

    /**
     * Set socket linger timeout on close.
     *
     * &lt;p&gt;When enabled, a close or shutdown will not return until all queued messages for the socket have been
     * successfully sent or the linger timeout has been reached. Otherwise, the call returns immediately and the
     * closing is done in the background.
     *
     * @param linger
     *            NoDelay setting
     * @return server configuration
     */
    public ServerConfiguration setServerSockLinger(int linger) {
<span class="nc" id="L1557">        setProperty(SERVER_SOCK_LINGER, Integer.toString(linger));</span>
<span class="nc" id="L1558">        return this;</span>
    }

    /**
     * Get socket keepalive.
     *
     * @return socket keepalive setting
     */
    public boolean getServerSockKeepalive() {
<span class="nc" id="L1567">        return getBoolean(SERVER_SOCK_KEEPALIVE, true);</span>
    }

    /**
     * Set socket keepalive setting.
     *
     * &lt;p&gt;This setting is used to send keep-alive messages on connection-oriented sockets.
     *
     * @param keepalive
     *            KeepAlive setting
     * @return server configuration
     */
    public ServerConfiguration setServerSockKeepalive(boolean keepalive) {
<span class="nc" id="L1580">        setProperty(SERVER_SOCK_KEEPALIVE, Boolean.toString(keepalive));</span>
<span class="nc" id="L1581">        return this;</span>
    }

    /**
     * Get zookeeper client backoff retry start time in millis.
     *
     * @return zk backoff retry start time in millis.
     */
    public int getZkRetryBackoffStartMs() {
<span class="nc" id="L1590">        return getInt(ZK_RETRY_BACKOFF_START_MS, getZkTimeout());</span>
    }

    /**
     * Set zookeeper client backoff retry start time in millis.
     *
     * @param retryMs
     *          backoff retry start time in millis.
     * @return server configuration.
     */
    public ServerConfiguration setZkRetryBackoffStartMs(int retryMs) {
<span class="nc" id="L1601">        setProperty(ZK_RETRY_BACKOFF_START_MS, retryMs);</span>
<span class="nc" id="L1602">        return this;</span>
    }

    /**
     * Get zookeeper client backoff retry max time in millis.
     *
     * @return zk backoff retry max time in millis.
     */
    public int getZkRetryBackoffMaxMs() {
<span class="nc" id="L1611">        return getInt(ZK_RETRY_BACKOFF_MAX_MS, getZkTimeout());</span>
    }

    /**
     * Set zookeeper client backoff retry max time in millis.
     *
     * @param retryMs
     *          backoff retry max time in millis.
     * @return server configuration.
     */
    public ServerConfiguration setZkRetryBackoffMaxMs(int retryMs) {
<span class="nc" id="L1622">        setProperty(ZK_RETRY_BACKOFF_MAX_MS, retryMs);</span>
<span class="nc" id="L1623">        return this;</span>
    }

    /**
     * Is statistics enabled.
     *
     * @return is statistics enabled
     */
    public boolean isStatisticsEnabled() {
<span class="nc" id="L1632">        return getBoolean(ENABLE_STATISTICS, true);</span>
    }

    /**
     * Turn on/off statistics.
     *
     * @param enabled
     *          Whether statistics enabled or not.
     * @return server configuration
     */
    public ServerConfiguration setStatisticsEnabled(boolean enabled) {
<span class="nc" id="L1643">        setProperty(ENABLE_STATISTICS, Boolean.toString(enabled));</span>
<span class="nc" id="L1644">        return this;</span>
    }

    /**
     * Allow manually force compact the entry log or not.
     *
     * @param enable
     *          whether allow manually force compact the entry log or not.
     * @return service configuration.
     */
    public ServerConfiguration setForceAllowCompaction(boolean enable) {
<span class="nc" id="L1655">        setProperty(FORCE_ALLOW_COMPACTION, enable);</span>
<span class="nc" id="L1656">        return this;</span>
    }

    /**
     * The force compaction is allowed or not when disabling the entry log compaction.
     *
     * @return the force compaction is allowed or not when disabling the entry log compaction.
     */
    public boolean isForceAllowCompaction() {
<span class="nc" id="L1665">        return getBoolean(FORCE_ALLOW_COMPACTION, false);</span>
    }

    /**
     * Get threshold of minor compaction.
     *
     * &lt;p&gt;For those entry log files whose remaining size percentage reaches below
     * this threshold  will be compacted in a minor compaction.
     *
     * &lt;p&gt;If it is set to less than zero, the minor compaction is disabled.
     *
     * @return threshold of minor compaction
     */
    public double getMinorCompactionThreshold() {
<span class="nc" id="L1679">        return getDouble(MINOR_COMPACTION_THRESHOLD, 0.2d);</span>
    }

    /**
     * Set threshold of minor compaction.
     *
     * @see #getMinorCompactionThreshold()
     *
     * @param threshold
     *          Threshold for minor compaction
     * @return server configuration
     */
    public ServerConfiguration setMinorCompactionThreshold(double threshold) {
<span class="nc" id="L1692">        setProperty(MINOR_COMPACTION_THRESHOLD, threshold);</span>
<span class="nc" id="L1693">        return this;</span>
    }

    /**
     * Get threshold of major compaction.
     *
     * &lt;p&gt;For those entry log files whose remaining size percentage reaches below
     * this threshold  will be compacted in a major compaction.
     *
     * &lt;p&gt;If it is set to less than zero, the major compaction is disabled.
     *
     * @return threshold of major compaction
     */
    public double getMajorCompactionThreshold() {
<span class="nc" id="L1707">        return getDouble(MAJOR_COMPACTION_THRESHOLD, 0.8d);</span>
    }

    /**
     * Set threshold of major compaction.
     *
     * @see #getMajorCompactionThreshold()
     *
     * @param threshold
     *          Threshold of major compaction
     * @return server configuration
     */
    public ServerConfiguration setMajorCompactionThreshold(double threshold) {
<span class="nc" id="L1720">        setProperty(MAJOR_COMPACTION_THRESHOLD, threshold);</span>
<span class="nc" id="L1721">        return this;</span>
    }

    /**
     * Get the maximum milliseconds to run major compaction. If {@literal &lt;=}0 the
     * thread will run until all compaction is completed.
     *
     * @return limit
     *           The number of milliseconds to run compaction.
     */
    public long getMajorCompactionMaxTimeMillis() {
<span class="nc" id="L1732">        return getLong(MAJOR_COMPACTION_MAX_TIME_MILLIS, -1);</span>
    }

    /**
     * Set the maximum milliseconds to run major compaction. If {@literal &lt;=}0 the
     * thread will run until all compaction is completed.
     *
     * @see #getMajorCompactionMaxTimeMillis()
     *
     * @param majorCompactionMaxTimeMillis
     *           The number of milliseconds to run compaction.
     *
     * @return  server configuration
     */
    public ServerConfiguration setMajorCompactionMaxTimeMillis(long majorCompactionMaxTimeMillis) {
<span class="nc" id="L1747">        setProperty(MAJOR_COMPACTION_MAX_TIME_MILLIS, majorCompactionMaxTimeMillis);</span>
<span class="nc" id="L1748">        return this;</span>
    }

    /**
     * Get interval to run minor compaction, in seconds.
     *
     * &lt;p&gt;If it is set to less than zero, the minor compaction is disabled.
     *
     * @return threshold of minor compaction
     */
    public long getMinorCompactionInterval() {
<span class="nc" id="L1759">        return getLong(MINOR_COMPACTION_INTERVAL, 3600);</span>
    }

    /**
     * Set interval to run minor compaction.
     *
     * @see #getMinorCompactionInterval()
     *
     * @param interval
     *          Interval to run minor compaction
     * @return server configuration
     */
    public ServerConfiguration setMinorCompactionInterval(long interval) {
<span class="nc" id="L1772">        setProperty(MINOR_COMPACTION_INTERVAL, interval);</span>
<span class="nc" id="L1773">        return this;</span>
    }

    /**
     * Get interval to run major compaction, in seconds.
     *
     * &lt;p&gt;If it is set to less than zero, the major compaction is disabled.
     *
     * @return high water mark
     */
    public long getMajorCompactionInterval() {
<span class="nc" id="L1784">        return getLong(MAJOR_COMPACTION_INTERVAL, 86400);</span>
    }

    /**
     * Set interval to run major compaction.
     *
     * @see #getMajorCompactionInterval()
     *
     * @param interval
     *          Interval to run major compaction
     * @return server configuration
     */
    public ServerConfiguration setMajorCompactionInterval(long interval) {
<span class="nc" id="L1797">        setProperty(MAJOR_COMPACTION_INTERVAL, interval);</span>
<span class="nc" id="L1798">        return this;</span>
    }

    /**
     * Get the maximum milliseconds to run minor compaction. If {@literal &lt;=}0 the
     * thread will run until all compaction is completed.
     *
     * @return limit
     *           The number of milliseconds to run compaction.
     */
    public long getMinorCompactionMaxTimeMillis() {
<span class="nc" id="L1809">        return getLong(MINOR_COMPACTION_MAX_TIME_MILLIS, -1);</span>
    }

    /**
     * Set the maximum milliseconds to run minor compaction. If {@literal &lt;=}0 the
     * thread will run until all compaction is completed.
     *
     * @see #getMinorCompactionMaxTimeMillis()
     *
     * @param minorCompactionMaxTimeMillis
     *           The number of milliseconds to run compaction.
     *
     * @return  server configuration
     */
    public ServerConfiguration setMinorCompactionMaxTimeMillis(long minorCompactionMaxTimeMillis) {
<span class="nc" id="L1824">        setProperty(MINOR_COMPACTION_MAX_TIME_MILLIS, minorCompactionMaxTimeMillis);</span>
<span class="nc" id="L1825">        return this;</span>
    }

    /**
     * Get whether force compaction is allowed when disk full or almost full.
     *
     * &lt;p&gt;Force GC may get some space back, but may also fill up disk space more
     * quickly. This is because new log files are created before GC, while old
     * garbage log files deleted after GC.
     *
     * @return true  - do force GC when disk full,
     *         false - suspend GC when disk full.
     */
    public boolean getIsForceGCAllowWhenNoSpace() {
<span class="nc" id="L1839">        return getBoolean(IS_FORCE_GC_ALLOW_WHEN_NO_SPACE, false);</span>
    }

    /**
     * Set whether force GC is allowed when disk full or almost full.
     *
     * @param force true to allow force GC; false to suspend GC
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setIsForceGCAllowWhenNoSpace(boolean force) {
<span class="nc" id="L1850">        setProperty(IS_FORCE_GC_ALLOW_WHEN_NO_SPACE, force);</span>
<span class="nc" id="L1851">        return this;</span>
    }

    /**
     * Set the grace period which the rereplication worker will wait before
     * fencing and rereplicating a ledger fragment which is still being written
     * to, on bookie failure.
     *
     * &lt;p&gt;The grace period allows the writer to detect the bookie failure, and and
     * start writing to another ledger fragment. If the writer writes nothing
     * during the grace period, the rereplication worker assumes that it has
     * crashed and therefore fences the ledger, preventing any further writes to
     * that ledger.
     *
     * @see org.apache.bookkeeper.client.BookKeeper#openLedger
     *
     * @param waitTime time to wait before replicating ledger fragment
     */
    public void setOpenLedgerRereplicationGracePeriod(String waitTime) {
<span class="nc" id="L1870">        setProperty(OPEN_LEDGER_REREPLICATION_GRACE_PERIOD, waitTime);</span>
<span class="nc" id="L1871">    }</span>

    /**
     * Get the grace period which the rereplication worker to wait before
     * fencing and rereplicating a ledger fragment which is still being written
     * to, on bookie failure.
     *
     * @return long
     */
    public long getOpenLedgerRereplicationGracePeriod() {
<span class="nc" id="L1881">        return getLong(OPEN_LEDGER_REREPLICATION_GRACE_PERIOD, 30000);</span>
    }

    /**
     * Set the grace period, in milliseconds, which the replication worker has
     * to wait before releasing the lock after it failed to replicate a ledger.
     * For the first ReplicationWorker.NUM_OF_EXPONENTIAL_BACKOFF_RETRIALS
     * failures it will do exponential backoff then it will bound at
     * LOCK_RELEASE_OF_FAILED_LEDGER_GRACE_PERIOD.
     *
     * &lt;p&gt;On replication failure, instead of releasing the lock immediately
     * after failed attempt, it will hold under replicated ledger lock for the
     * grace period and then it will release the lock.
     *
     * @param waitTime
     */
    public void setLockReleaseOfFailedLedgerGracePeriod(String waitTime) {
<span class="nc" id="L1898">        setProperty(LOCK_RELEASE_OF_FAILED_LEDGER_GRACE_PERIOD, waitTime);</span>
<span class="nc" id="L1899">    }</span>

    /**
     * Get the grace period, in milliseconds, which the replication worker has
     * to wait before releasing the lock after it failed to replicate a ledger.
     * For the first ReplicationWorker.NUM_OF_EXPONENTIAL_BACKOFF_RETRIALS
     * failures it will do exponential backoff then it will bound at
     * LOCK_RELEASE_OF_FAILED_LEDGER_GRACE_PERIOD.
     *
     * @return
     */
    public long getLockReleaseOfFailedLedgerGracePeriod() {
<span class="nc" id="L1911">        return getLong(LOCK_RELEASE_OF_FAILED_LEDGER_GRACE_PERIOD, 300000);</span>
    }

    /**
     * Get the number of bytes we should use as capacity for
     * org.apache.bookkeeper.bookie.BufferedReadChannel.
     * Default is 512 bytes
     * @return read buffer size
     */
    public int getReadBufferBytes() {
<span class="nc" id="L1921">        return getInt(READ_BUFFER_SIZE, 512);</span>
    }

    /**
     * Set the number of bytes we should use as capacity for
     * org.apache.bookkeeper.bookie.BufferedReadChannel.
     *
     * @param readBufferSize
     *          Read Buffer Size
     * @return server configuration
     */
    public ServerConfiguration setReadBufferBytes(int readBufferSize) {
<span class="nc" id="L1933">        setProperty(READ_BUFFER_SIZE, readBufferSize);</span>
<span class="nc" id="L1934">        return this;</span>
    }

    /**
     * Set the number of threads that would handle write requests.
     *
     * @param numThreads
     *          number of threads to handle write requests.
     * @return server configuration
     */
    public ServerConfiguration setNumAddWorkerThreads(int numThreads) {
<span class="nc" id="L1945">        setProperty(NUM_ADD_WORKER_THREADS, numThreads);</span>
<span class="nc" id="L1946">        return this;</span>
    }

    /**
     * Get the number of threads that should handle write requests.
     *
     * @return the number of threads that handle write requests.
     */
    public int getNumAddWorkerThreads() {
<span class="nc" id="L1955">        return getInt(NUM_ADD_WORKER_THREADS, 1);</span>
    }

    /**
     * Set the number of threads that should handle long poll requests.
     *
     * @param numThreads
     *          number of threads to handle long poll requests.
     * @return server configuration
     */
    public ServerConfiguration setNumLongPollWorkerThreads(int numThreads) {
<span class="nc" id="L1966">        setProperty(NUM_LONG_POLL_WORKER_THREADS, numThreads);</span>
<span class="nc" id="L1967">        return this;</span>
    }

    /**
     * Get the number of threads that should handle long poll requests.
     *
     * &lt;p&gt;If the number of threads is zero or negative, bookie will fallback to
     * use read threads. If there is no read threads used, it will create a thread pool
     * with {@link Runtime#availableProcessors()} threads.
     *
     * @return the number of threads that should handle long poll requests, default value is 0.
     */
    public int getNumLongPollWorkerThreads() {
<span class="nc" id="L1980">        return getInt(NUM_LONG_POLL_WORKER_THREADS, 0);</span>
    }

    /**
     * Set the number of threads that should be used for high priority requests
     * (i.e. recovery reads and adds, and fencing)
     *
     * @param numThreads
     *          number of threads to handle high priority requests.
     * @return server configuration
     */
    public ServerConfiguration setNumHighPriorityWorkerThreads(int numThreads) {
<span class="nc" id="L1992">        setProperty(NUM_HIGH_PRIORITY_WORKER_THREADS, numThreads);</span>
<span class="nc" id="L1993">        return this;</span>
    }

    /**
     * Get the number of threads that should be used for high priority requests
     * (i.e. recovery reads and adds, and fencing)
     * @return
     */
    public int getNumHighPriorityWorkerThreads() {
<span class="nc" id="L2002">        return getInt(NUM_HIGH_PRIORITY_WORKER_THREADS, 8);</span>
    }

    /**
     * Use auto-throttling of the read-worker threads. This is done
     * to ensure the bookie is not using unlimited amount of memory
     * to respond to read-requests.
     *
     * @param throttle
     *          whether to throttle the read workers threads
     * @return server configuration
     */
    public ServerConfiguration setReadWorkerThreadsThrottlingEnabled(boolean throttle) {
<span class="nc" id="L2015">        setProperty(READ_WORKER_THREADS_THROTTLING_ENABLED, throttle);</span>
<span class="nc" id="L2016">        return this;</span>
    }

    /**
     * Get the auto-throttling status of the read-worker threads.
     * @return
     */
    public boolean isReadWorkerThreadsThrottlingEnabled() {
<span class="nc" id="L2024">        return getBoolean(READ_WORKER_THREADS_THROTTLING_ENABLED, true);</span>
    }



    /**
     * Set the number of threads that would handle read requests.
     *
     * @param numThreads
     *          Number of threads to handle read requests.
     * @return server configuration
     */
    public ServerConfiguration setNumReadWorkerThreads(int numThreads) {
<span class="nc" id="L2037">        setProperty(NUM_READ_WORKER_THREADS, numThreads);</span>
<span class="nc" id="L2038">        return this;</span>
    }

    /**
     * Get the number of threads that should handle read requests.
     */
    public int getNumReadWorkerThreads() {
<span class="nc" id="L2045">        return getInt(NUM_READ_WORKER_THREADS, 8);</span>
    }

    /**
     * Set the tick duration in milliseconds.
     *
     * @param tickDuration
     *          tick duration in milliseconds.
     * @return server configuration
     */
    public ServerConfiguration setRequestTimerTickDurationMs(int tickDuration) {
<span class="nc" id="L2056">        setProperty(REQUEST_TIMER_TICK_DURATION_MILLISEC, tickDuration);</span>
<span class="nc" id="L2057">        return this;</span>
    }

    /**
     * Set the max number of pending read requests for each read worker thread. After the quota is reached,
     * new requests will be failed immediately.
     *
     * @param maxPendingReadRequestsPerThread
     * @return server configuration
     */
    public ServerConfiguration setMaxPendingReadRequestPerThread(int maxPendingReadRequestsPerThread) {
<span class="nc" id="L2068">        setProperty(MAX_PENDING_READ_REQUESTS_PER_THREAD, maxPendingReadRequestsPerThread);</span>
<span class="nc" id="L2069">        return this;</span>
    }

    /**
     * If read workers threads are enabled, limit the number of pending requests, to avoid the executor queue to grow
     * indefinitely (default: 10000 entries).
     */
    public int getMaxPendingReadRequestPerThread() {
<span class="nc" id="L2077">        return getInt(MAX_PENDING_READ_REQUESTS_PER_THREAD, 10000);</span>
    }

    /**
     * Set the max number of pending add requests for each add worker thread. After the quota is reached, new requests
     * will be failed immediately.
     *
     * @param maxPendingAddRequestsPerThread
     * @return server configuration
     */
    public ServerConfiguration setMaxPendingAddRequestPerThread(int maxPendingAddRequestsPerThread) {
<span class="nc" id="L2088">        setProperty(MAX_PENDING_ADD_REQUESTS_PER_THREAD, maxPendingAddRequestsPerThread);</span>
<span class="nc" id="L2089">        return this;</span>
    }

    /**
     * If add workers threads are enabled, limit the number of pending requests, to avoid the executor queue to grow
     * indefinitely (default: 10000 entries).
     */
    public int getMaxPendingAddRequestPerThread() {
<span class="nc" id="L2097">        return getInt(MAX_PENDING_ADD_REQUESTS_PER_THREAD, 10000);</span>
    }



    /**
     * Get the tick duration in milliseconds.
     * @return
     */
    public int getRequestTimerTickDurationMs() {
<span class="nc" id="L2107">        return getInt(REQUEST_TIMER_TICK_DURATION_MILLISEC, 10);</span>
    }

    /**
     * Set the number of ticks per wheel for the request timer.
     *
     * @param tickCount
     *          number of ticks per wheel for the request timer.
     * @return server configuration
     */
    public ServerConfiguration setRequestTimerNumTicks(int tickCount) {
<span class="nc" id="L2118">        setProperty(REQUEST_TIMER_NO_OF_TICKS, tickCount);</span>
<span class="nc" id="L2119">        return this;</span>
    }

    /**
     * Get the number of ticks per wheel for the request timer.
     * @return
     */
    public int getRequestTimerNumTicks() {
<span class="nc" id="L2127">        return getInt(REQUEST_TIMER_NO_OF_TICKS, 1024);</span>
    }

    /**
     * Get the number of bytes used as capacity for the write buffer. Default is
     * 64KB.
     * NOTE: Make sure this value is greater than the maximum message size.
     * @return the size of the write buffer in bytes
     */
    public int getWriteBufferBytes() {
<span class="nc" id="L2137">        return getInt(WRITE_BUFFER_SIZE, 65536);</span>
    }

    /**
     * Set the number of bytes used as capacity for the write buffer.
     *
     * @param writeBufferBytes
     *          Write Buffer Bytes
     * @return server configuration
     */
    public ServerConfiguration setWriteBufferBytes(int writeBufferBytes) {
<span class="nc" id="L2148">        setProperty(WRITE_BUFFER_SIZE, writeBufferBytes);</span>
<span class="nc" id="L2149">        return this;</span>
    }

    /**
     * Set the number of threads that would handle journal callbacks.
     *
     * @param numThreads
     *          number of threads to handle journal callbacks.
     * @return server configuration
     */
    @Deprecated
    public ServerConfiguration setNumJournalCallbackThreads(int numThreads) {
<span class="nc" id="L2161">        setProperty(NUM_JOURNAL_CALLBACK_THREADS, numThreads);</span>
<span class="nc" id="L2162">        return this;</span>
    }

    /**
     * Get the number of threads that should handle journal callbacks.
     *
     * @return the number of threads that handle journal callbacks.
     */
    @Deprecated
    public int getNumJournalCallbackThreads() {
<span class="nc" id="L2172">        return getInt(NUM_JOURNAL_CALLBACK_THREADS, 1);</span>
    }

    /**
     * Set sorted-ledger storage enabled or not.
     *
     * @deprecated Use {@link #setLedgerStorageClass(String)} to configure the implementation class
     * @param enabled
     */
    public ServerConfiguration setSortedLedgerStorageEnabled(boolean enabled) {
<span class="nc" id="L2182">        this.setProperty(SORTED_LEDGER_STORAGE_ENABLED, enabled);</span>
<span class="nc" id="L2183">        return this;</span>
    }

    /**
     * Check if sorted-ledger storage enabled (default true).
     *
     * @return true if sorted ledger storage is enabled, false otherwise
     */
    public boolean getSortedLedgerStorageEnabled() {
<span class="nc" id="L2192">        return this.getBoolean(SORTED_LEDGER_STORAGE_ENABLED, true);</span>
    }

    /**
     * Get skip list data size limitation (default 64MB).
     * Max value is 1,073,741,823
     *
     * @return skip list data size limitation
     */
    public long getSkipListSizeLimit() {
<span class="nc" id="L2202">        return this.getLong(SKIP_LIST_SIZE_LIMIT, 64 * 1024 * 1024L);</span>
    }

    /**
     * Set skip list size limit.
     *
     * @param size skip list size limit.
     * @return server configuration object.
     */
    public ServerConfiguration setSkipListSizeLimit(int size) {
<span class="nc bnc" id="L2212" title="All 2 branches missed.">        if (size &gt; (Integer.MAX_VALUE - 1) / 2) {</span>
            // gives max of 2*1023MB for mem table (one being checkpointed and still writable).
<span class="nc" id="L2214">            throw new IllegalArgumentException(&quot;skiplist size over &quot; + ((Integer.MAX_VALUE - 1) / 2));</span>
        }
<span class="nc" id="L2216">        setProperty(SKIP_LIST_SIZE_LIMIT, size);</span>
<span class="nc" id="L2217">        return this;</span>
    }

    /**
     * Get the number of bytes we should use as chunk allocation for
     * org.apache.bookkeeper.bookie.SkipListArena.
     * Default is 4 MB
     * @return the number of bytes to use for each chunk in the skiplist arena
     */
    public int getSkipListArenaChunkSize() {
<span class="nc" id="L2227">        return getInt(SKIP_LIST_CHUNK_SIZE_ENTRY, 4096 * 1024);</span>
    }

    /**
     * Set the number of bytes we used as chunk allocation for
     * org.apache.bookkeeper.bookie.SkipListArena.
     *
     * @param size chunk size.
     * @return server configuration object.
     */
    public ServerConfiguration setSkipListArenaChunkSize(int size) {
<span class="nc" id="L2238">        setProperty(SKIP_LIST_CHUNK_SIZE_ENTRY, size);</span>
<span class="nc" id="L2239">        return this;</span>
    }

    /**
     * Get the max size we should allocate from the skiplist arena. Allocations
     * larger than this should be allocated directly by the VM to avoid fragmentation.
     *
     * @return max size allocatable from the skiplist arena (Default is 128 KB)
     */
    public int getSkipListArenaMaxAllocSize() {
<span class="nc" id="L2249">        return getInt(SKIP_LIST_MAX_ALLOC_ENTRY, 128 * 1024);</span>
    }

    /**
     * Set the max size we should allocate from the skiplist arena. Allocations
     * larger than this should be allocated directly by the VM to avoid fragmentation.
     *
     * @param size max alloc size.
     * @return server configuration object.
     */
    public ServerConfiguration setSkipListArenaMaxAllocSize(int size) {
<span class="nc" id="L2260">        setProperty(SKIP_LIST_MAX_ALLOC_ENTRY, size);</span>
<span class="nc" id="L2261">        return this;</span>
    }

    /**
     * Should the data be fsynced on journal before acknowledgment.
     *
     * &lt;p&gt;Default is true
     *
     * @return
     */
    public boolean getJournalSyncData() {
<span class="nc" id="L2272">        return getBoolean(JOURNAL_SYNC_DATA, true);</span>
    }

    /**
     * Should the data be written to journal before acknowledgment.
     *
     * &lt;p&gt;Default is true
     *
     * @return
     */
    public boolean getJournalWriteData() {
<span class="nc" id="L2283">        return getBoolean(JOURNAL_WRITE_DATA, true);</span>
    }

    /**
     * Should the data be written to journal before acknowledgment.
     *
     * &lt;p&gt;Default is true
     *
     * @return
     */
    public ServerConfiguration setJournalWriteData(boolean journalWriteData) {
<span class="nc" id="L2294">        setProperty(JOURNAL_WRITE_DATA, journalWriteData);</span>
<span class="nc" id="L2295">        return this;</span>
    }

    /**
     * Enable or disable journal syncs.
     *
     * &lt;p&gt;By default, data sync is enabled to guarantee durability of writes.
     *
     * &lt;p&gt;Beware: while disabling data sync in the Bookie journal might improve the bookie write performance, it will
     * also introduce the possibility of data loss. With no sync, the journal entries are written in the OS page cache
     * but not flushed to disk. In case of power failure, the affected bookie might lose the unflushed data. If the
     * ledger is replicated to multiple bookies, the chances of data loss are reduced though still present.
     *
     * @param syncData
     *            whether to sync data on disk before acknowledgement
     * @return server configuration object
     */
    public ServerConfiguration setJournalSyncData(boolean syncData) {
<span class="nc" id="L2313">        setProperty(JOURNAL_SYNC_DATA, syncData);</span>
<span class="nc" id="L2314">        return this;</span>
    }

    /**
     * Should we group journal force writes.
     *
     * @return group journal force writes
     */
    public boolean getJournalAdaptiveGroupWrites() {
<span class="nc" id="L2323">        return getBoolean(JOURNAL_ADAPTIVE_GROUP_WRITES, true);</span>
    }

    /**
     * Enable/disable group journal force writes.
     *
     * @param enabled flag to enable/disable group journal force writes
     */
    public ServerConfiguration setJournalAdaptiveGroupWrites(boolean enabled) {
<span class="nc" id="L2332">        setProperty(JOURNAL_ADAPTIVE_GROUP_WRITES, enabled);</span>
<span class="nc" id="L2333">        return this;</span>
    }

    /**
     * Maximum latency to impose on a journal write to achieve grouping. Default is 2ms.
     *
     * @return max wait for grouping
     */
    public long getJournalMaxGroupWaitMSec() {
<span class="nc" id="L2342">        return getLong(JOURNAL_MAX_GROUP_WAIT_MSEC, 2);</span>
    }

    /**
     * Sets the maximum latency to impose on a journal write to achieve grouping.
     *
     * @param journalMaxGroupWaitMSec
     *          maximum time to wait in milliseconds.
     * @return server configuration.
     */
    public ServerConfiguration setJournalMaxGroupWaitMSec(long journalMaxGroupWaitMSec) {
<span class="nc" id="L2353">        setProperty(JOURNAL_MAX_GROUP_WAIT_MSEC, journalMaxGroupWaitMSec);</span>
<span class="nc" id="L2354">        return this;</span>
    }

    /**
     * Maximum bytes to buffer to impose on a journal write to achieve grouping.
     *
     * @return max bytes to buffer
     */
    public long getJournalBufferedWritesThreshold() {
<span class="nc" id="L2363">        return getLong(JOURNAL_BUFFERED_WRITES_THRESHOLD, 512 * 1024);</span>
    }

    /**
     * Set maximum bytes to buffer to impose on a journal write to achieve grouping.
     *
     * @param maxBytes maximum bytes to buffer to impose on a journal write
     * @return max bytes to buffer
     */
    public ServerConfiguration setJournalBufferedWritesThreshold(long maxBytes) {
<span class="nc" id="L2373">        setProperty(JOURNAL_BUFFERED_WRITES_THRESHOLD, maxBytes);</span>
<span class="nc" id="L2374">        return this;</span>
    }

    /**
     * Maximum entries to buffer to impose on a journal write to achieve grouping.
     * Use {@link #getJournalBufferedWritesThreshold()} if this is set to zero or
     * less than zero.
     *
     * @return max entries to buffer.
     */
    public long getJournalBufferedEntriesThreshold() {
<span class="nc" id="L2385">        return getLong(JOURNAL_BUFFERED_ENTRIES_THRESHOLD, 0);</span>
    }

    /**
     * Set maximum entries to buffer to impose on a journal write to achieve grouping.
     * Use {@link #getJournalBufferedWritesThreshold()} set this to zero or less than
     * zero.
     *
     * @param maxEntries
     *          maximum entries to buffer.
     * @return server configuration.
     */
    public ServerConfiguration setJournalBufferedEntriesThreshold(int maxEntries) {
<span class="nc" id="L2398">        setProperty(JOURNAL_BUFFERED_ENTRIES_THRESHOLD, maxEntries);</span>
<span class="nc" id="L2399">        return this;</span>
    }

    /**
     * Set if we should flush the journal when queue is empty.
     */
    public ServerConfiguration setJournalFlushWhenQueueEmpty(boolean enabled) {
<span class="nc" id="L2406">        setProperty(JOURNAL_FLUSH_WHEN_QUEUE_EMPTY, enabled);</span>
<span class="nc" id="L2407">        return this;</span>
    }

    /**
     * Should we flush the journal when queue is empty.
     *
     * @return flush when queue is empty
     */
    public boolean getJournalFlushWhenQueueEmpty() {
<span class="nc" id="L2416">        return getBoolean(JOURNAL_FLUSH_WHEN_QUEUE_EMPTY, false);</span>
    }

    /**
     * Set whether the bookie is able to go into read-only mode.
     * If this is set to false, the bookie will shutdown on encountering
     * an error condition.
     *
     * @param enabled whether to enable read-only mode.
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setReadOnlyModeEnabled(boolean enabled) {
<span class="nc" id="L2429">        setProperty(READ_ONLY_MODE_ENABLED, enabled);</span>
<span class="nc" id="L2430">        return this;</span>
    }

    /**
     * Get whether read-only mode is enabled. The default is true.
     *
     * @return boolean
     */
    public boolean isReadOnlyModeEnabled() {
<span class="nc" id="L2439">        return getBoolean(READ_ONLY_MODE_ENABLED, true);</span>
    }

    /**
     * Set whether the bookie is able to go into read-only mode when any disk is full.
     * If this set to false, it will behave to READ_ONLY_MODE_ENABLED flag.
     *
     * @param enabled whether to enable read-only mode when any disk is full.
     * @return
     */
    public ServerConfiguration setReadOnlyModeOnAnyDiskFullEnabled(boolean enabled) {
<span class="nc" id="L2450">        setProperty(READ_ONLY_MODE_ON_ANY_DISK_FULL_ENABLED, enabled);</span>
<span class="nc" id="L2451">        return this;</span>
    }

    /**
     * Get whether read-only mode is enable when any disk is full. The default is false.
     *
     * @return boolean
     */
    public boolean isReadOnlyModeOnAnyDiskFullEnabled() {
<span class="nc" id="L2460">        return getBoolean(READ_ONLY_MODE_ON_ANY_DISK_FULL_ENABLED, false);</span>
    }

    /**
     * Set the warning threshold for disk usage.
     *
     * @param threshold warning threshold to force gc.
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setDiskUsageWarnThreshold(float threshold) {
<span class="nc" id="L2471">        setProperty(DISK_USAGE_WARN_THRESHOLD, threshold);</span>
<span class="nc" id="L2472">        return this;</span>
    }

    /**
     * Returns the warning threshold for disk usage. If disk usage
     * goes beyond this, a garbage collection cycle will be forced.
     * @return the percentage at which a disk usage warning will trigger
     */
    public float getDiskUsageWarnThreshold() {
<span class="nc" id="L2481">        return getFloat(DISK_USAGE_WARN_THRESHOLD, 0.90f);</span>
    }

    /**
     * Whether to persist the bookie status so that when bookie server restarts,
     * it will continue using the previous status.
     *
     * @param enabled
     *            - true if persist the bookie status. Otherwise false.
     * @return ServerConfiguration
     */
    public ServerConfiguration setPersistBookieStatusEnabled(boolean enabled) {
<span class="nc" id="L2493">        setProperty(PERSIST_BOOKIE_STATUS_ENABLED, enabled);</span>
<span class="nc" id="L2494">        return this;</span>
    }

    /**
     * Get whether to persist the bookie status so that when bookie server restarts,
     * it will continue using the previous status.
     *
     * @return true - if need to start a bookie in read only mode. Otherwise false.
     */
    public boolean isPersistBookieStatusEnabled() {
<span class="nc" id="L2504">        return getBoolean(PERSIST_BOOKIE_STATUS_ENABLED, false);</span>
    }

    /**
     * Set the Disk free space threshold as a fraction of the total
     * after which disk will be considered as full during disk check.
     *
     * @param threshold threshold to declare a disk full
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setDiskUsageThreshold(float threshold) {
<span class="nc" id="L2516">        setProperty(DISK_USAGE_THRESHOLD, threshold);</span>
<span class="nc" id="L2517">        return this;</span>
    }

    /**
     * Returns disk free space threshold. By default it is 0.95.
     *
     * @return the percentage at which a disk will be considered full
     */
    public float getDiskUsageThreshold() {
<span class="nc" id="L2526">        return getFloat(DISK_USAGE_THRESHOLD, 0.95f);</span>
    }

    /**
     * Set the disk free space low water mark threshold.
     * Disk is considered full when usage threshold is exceeded.
     * Disk returns back to non-full state when usage is below low water mark threshold.
     * This prevents it from going back and forth between these states frequently
     * when concurrent writes and compaction are happening. This also prevent bookie from
     * switching frequently between read-only and read-writes states in the same cases.
     *
     * @param threshold threshold to declare a disk full
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setDiskLowWaterMarkUsageThreshold(float threshold) {
<span class="nc" id="L2542">        setProperty(DISK_USAGE_LWM_THRESHOLD, threshold);</span>
<span class="nc" id="L2543">        return this;</span>
    }

    /**
     * Returns disk free space low water mark threshold. By default it is the
     * same as usage threshold (for backwards-compatibility).
     *
     * @return the percentage below which a disk will NOT be considered full
     */
    public float getDiskLowWaterMarkUsageThreshold() {
<span class="nc" id="L2553">        return getFloat(DISK_USAGE_LWM_THRESHOLD, getDiskUsageThreshold());</span>
    }

    /**
     * Set the disk checker interval to monitor ledger disk space.
     *
     * @param interval interval between disk checks for space.
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setDiskCheckInterval(int interval) {
<span class="nc" id="L2564">        setProperty(DISK_CHECK_INTERVAL, interval);</span>
<span class="nc" id="L2565">        return this;</span>
    }

    /**
     * Get the disk checker interval.
     *
     * @return int
     */
    public int getDiskCheckInterval() {
<span class="nc" id="L2574">        return getInt(DISK_CHECK_INTERVAL, 10 * 1000);</span>
    }

    /**
     * Set the regularity at which the auditor will run a check
     * of all ledgers. This should not be run very often, and at most,
     * once a day. Setting this to 0 will completely disable the periodic
     * check.
     *
     * @param interval The interval in seconds. e.g. 86400 = 1 day, 604800 = 1 week
     */
    public void setAuditorPeriodicCheckInterval(long interval) {
<span class="nc" id="L2586">        setProperty(AUDITOR_PERIODIC_CHECK_INTERVAL, interval);</span>
<span class="nc" id="L2587">    }</span>

    /**
     * Get the regularity at which the auditor checks all ledgers.
     * @return The interval in seconds. Default is 604800 (1 week).
     */
    public long getAuditorPeriodicCheckInterval() {
<span class="nc" id="L2594">        return getLong(AUDITOR_PERIODIC_CHECK_INTERVAL, 604800);</span>
    }

    /**
     * Set the interval between auditor bookie checks.
     * The auditor bookie check, checks ledger metadata to see which bookies
     * contain entries for each ledger. If a bookie which should contain entries
     * is unavailable, then the ledger containing that entry is marked for recovery.
     * Setting this to 0 disabled the periodic check. Bookie checks will still
     * run when a bookie fails.
     *
     * @param interval The period in seconds.
     */
    public void setAuditorPeriodicBookieCheckInterval(long interval) {
<span class="nc" id="L2608">        setProperty(AUDITOR_PERIODIC_BOOKIE_CHECK_INTERVAL, interval);</span>
<span class="nc" id="L2609">    }</span>

    /**
     * Get the interval between auditor bookie check runs.
     * @see #setAuditorPeriodicBookieCheckInterval(long)
     * @return the interval between bookie check runs, in seconds. Default is 86400 (= 1 day)
     */
    public long getAuditorPeriodicBookieCheckInterval() {
<span class="nc" id="L2617">        return getLong(AUDITOR_PERIODIC_BOOKIE_CHECK_INTERVAL, 86400);</span>
    }

    /**
     * Sets the regularity/interval at which the auditor will run a placement
     * policy check of all ledgers, which are closed. This should not be run
     * very often, and should be run at most once a day. Setting this to 0 will
     * completely disable the periodic metadata check.
     *
     * @param interval
     *            The interval in seconds. e.g. 86400 = 1 day, 604800 = 1 week
     */
    public void setAuditorPeriodicPlacementPolicyCheckInterval(long interval) {
<span class="nc" id="L2630">        setProperty(AUDITOR_PERIODIC_PLACEMENT_POLICY_CHECK_INTERVAL, interval);</span>
<span class="nc" id="L2631">    }</span>

    /**
     * Get the regularity at which the auditor does placement policy check of
     * all ledgers, which are closed.
     *
     * @return The interval in seconds. By default, it is disabled.
     */
    public long getAuditorPeriodicPlacementPolicyCheckInterval() {
<span class="nc" id="L2640">        return getLong(AUDITOR_PERIODIC_PLACEMENT_POLICY_CHECK_INTERVAL, 0);</span>
    }

    public void setRepairedPlacementPolicyNotAdheringBookieEnable(boolean enabled) {
<span class="nc" id="L2644">        setProperty(REPAIRED_PLACEMENT_POLICY_NOT_ADHERING_BOOKIE_ENABLED, enabled);</span>
<span class="nc" id="L2645">    }</span>

    /**
     * Now the feature only support RackawareEnsemblePlacementPolicy.
     *
     * In Auditor, it combines with {@link #getAuditorPeriodicPlacementPolicyCheckInterval}, to control is marked
     * ledger id to under replication managed when found a ledger ensemble not adhere to placement policy.
     * In ReplicationWorker, to control is to repair the ledger which the ensemble does not adhere to the placement
     * policy. By default, it is disabled.
     *
     * If you want to enable this feature, there maybe lots of ledger will be mark underreplicated.
     * The replicationWorker will replicate lots of ledger, it will increase read request and write request in bookie
     * server. You should set a suitable rereplicationEntryBatchSize to avoid bookie server pressure.
     *
     */
    public boolean isRepairedPlacementPolicyNotAdheringBookieEnable() {
<span class="nc" id="L2661">        return getBoolean(REPAIRED_PLACEMENT_POLICY_NOT_ADHERING_BOOKIE_ENABLED, false);</span>
    }

    /**
     * Sets the grace period (in seconds) for underreplicated ledgers recovery.
     * If ledger is marked underreplicated for more than this period then it
     * will be reported by placementPolicyCheck in Auditor. Setting this to 0
     * will disable this check.
     *
     * @param gracePeriod
     *            The interval in seconds. e.g. 3600 = 1 hour
     */
    public void setUnderreplicatedLedgerRecoveryGracePeriod(long gracePeriod) {
<span class="nc" id="L2674">        setProperty(UNDERREPLICATED_LEDGER_RECOVERY_GRACE_PERIOD, gracePeriod);</span>
<span class="nc" id="L2675">    }</span>

    /**
     * Gets the grace period (in seconds) for underreplicated ledgers recovery.
     * If ledger is marked underreplicated for more than this period then it
     * will be reported by placementPolicyCheck in Auditor. Setting this to 0
     * will disable this check.
     *
     * @return The interval in seconds. By default it is disabled.
     */
    public long getUnderreplicatedLedgerRecoveryGracePeriod() {
<span class="nc" id="L2686">        return getLong(UNDERREPLICATED_LEDGER_RECOVERY_GRACE_PERIOD, 0);</span>
    }

    /**
     * Sets the interval at which the auditor will run a replicas check of all
     * ledgers. This should not be run very often since it validates
     * availability of replicas of all ledgers by querying bookies. Setting this
     * to 0 will disable the periodic replicas check.
     *
     * @param interval
     *            The interval in seconds. e.g. 86400 = 1 day, 604800 = 1 week
     */
    public void setAuditorPeriodicReplicasCheckInterval(long interval) {
<span class="nc" id="L2699">        setProperty(AUDITOR_REPLICAS_CHECK_INTERVAL, interval);</span>
<span class="nc" id="L2700">    }</span>

    /**
     * Get the interval at which the auditor does replicas check of all ledgers.
     *
     * @return The interval in seconds. By default it is disabled.
     */
    public long getAuditorPeriodicReplicasCheckInterval() {
<span class="nc" id="L2708">        return getLong(AUDITOR_REPLICAS_CHECK_INTERVAL, 0);</span>
    }

    /**
     * Get the semaphore limit value of getting ledger from zookeeper in auto recovery.
     *
     * @return The semaphore value. By default it is 500.
     */
    public int getAuditorMaxNumberOfConcurrentOpenLedgerOperations() {
<span class="nc" id="L2717">        return getInt(AUDITOR_MAX_NUMBER_OF_CONCURRENT_OPEN_LEDGER_OPERATIONS, 500);</span>
    }

    /**
     * Set the semaphore limit value for getting ledger from zookeeper in auto recovery.
     * @param semaphore
     */
    public void setAuditorMaxNumberOfConcurrentOpenLedgerOperations(int semaphore) {
<span class="nc" id="L2725">        setProperty(AUDITOR_MAX_NUMBER_OF_CONCURRENT_OPEN_LEDGER_OPERATIONS, semaphore);</span>
<span class="nc" id="L2726">    }</span>

    /**
     * Get the acquire concurrent open ledger operations timeout.
     *
     * @return The timeout values. By default it is 120000ms
     */
    public int getAuditorAcquireConcurrentOpenLedgerOperationsTimeoutMSec() {
<span class="nc" id="L2734">        return getInt(AUDITOR_ACQUIRE_CONCURRENT_OPEN_LEDGER_OPERATIONS_TIMEOUT_MSEC, 120000);</span>
    }

    /**
     * Set the acquire concurrent open ledger operations timeout.
     * @param timeoutMs
     */
    public void setAuditorAcquireConcurrentOpenLedgerOperationsTimeoutMSec(int timeoutMs) {
<span class="nc" id="L2742">        setProperty(AUDITOR_ACQUIRE_CONCURRENT_OPEN_LEDGER_OPERATIONS_TIMEOUT_MSEC, timeoutMs);</span>
<span class="nc" id="L2743">    }</span>


    /**
     * Set what percentage of a ledger (fragment)'s entries will be verified.
     * 0 - only the first and last entry of each ledger fragment would be verified
     * 100 - the entire ledger fragment would be verified
     * anything else - randomly picked entries from over the fragment would be verifiec
     * @param auditorLedgerVerificationPercentage The verification proportion as a percentage
     * @return ServerConfiguration
     */
    public ServerConfiguration setAuditorLedgerVerificationPercentage(long auditorLedgerVerificationPercentage) {
<span class="nc" id="L2755">        setProperty(AUDITOR_LEDGER_VERIFICATION_PERCENTAGE, auditorLedgerVerificationPercentage);</span>
<span class="nc" id="L2756">        return this;</span>
    }

    /**
     * Get what percentage of a ledger (fragment)'s entries will be verified.
     * @see #setAuditorLedgerVerificationPercentage(long)
     * @return percentage of a ledger (fragment)'s entries will be verified. Default is 0.
     */
    public long getAuditorLedgerVerificationPercentage() {
<span class="nc" id="L2765">        return getLong(AUDITOR_LEDGER_VERIFICATION_PERCENTAGE, 0);</span>
    }

    /**
     * Sets that whether the auto-recovery service can start along with Bookie
     * server itself or not.
     *
     * @param enabled
     *            - true if need to start auto-recovery service. Otherwise
     *            false.
     * @return ServerConfiguration
     */
    public ServerConfiguration setAutoRecoveryDaemonEnabled(boolean enabled) {
<span class="nc" id="L2778">        setProperty(AUTO_RECOVERY_DAEMON_ENABLED, enabled);</span>
<span class="nc" id="L2779">        return this;</span>
    }

    /**
     * Get whether the Bookie itself can start auto-recovery service also or not.
     *
     * @return true - if Bookie should start auto-recovery service along with
     *         it. false otherwise.
     */
    public boolean isAutoRecoveryDaemonEnabled() {
<span class="nc" id="L2789">        return getBoolean(AUTO_RECOVERY_DAEMON_ENABLED, false);</span>
    }

    /**
     * Get how long to delay the recovery of ledgers of a lost bookie.
     *
     * @return delay interval in seconds
     */
    public int getLostBookieRecoveryDelay() {
<span class="nc" id="L2798">        return getInt(LOST_BOOKIE_RECOVERY_DELAY, 0);</span>
    }

    /**
     * Set the delay interval for starting recovery of a lost bookie.
     */
    public void setLostBookieRecoveryDelay(int interval) {
<span class="nc" id="L2805">        setProperty(LOST_BOOKIE_RECOVERY_DELAY, interval);</span>
<span class="nc" id="L2806">    }</span>

    /**
     * Get how long to backoff when encountering exception on rereplicating a ledger.
     *
     * @return backoff time in milliseconds
     */
    public int getRwRereplicateBackoffMs() {
<span class="nc" id="L2814">        return getInt(RW_REREPLICATE_BACKOFF_MS, 5000);</span>
    }

    /**
     * Set how long to backoff when encountering exception on rereplicating a ledger.
     *
     * @param backoffMs backoff time in milliseconds
     */
    public void setRwRereplicateBackoffMs(int backoffMs) {
<span class="nc" id="L2823">        setProperty(RW_REREPLICATE_BACKOFF_MS, backoffMs);</span>
<span class="nc" id="L2824">    }</span>

    /**
     * Sets that whether force start a bookie in readonly mode.
     *
     * @param enabled
     *            - true if need to start a bookie in read only mode. Otherwise
     *            false.
     * @return ServerConfiguration
     */
    public ServerConfiguration setForceReadOnlyBookie(boolean enabled) {
<span class="nc" id="L2835">        setProperty(FORCE_READ_ONLY_BOOKIE, enabled);</span>
<span class="nc" id="L2836">        return this;</span>
    }

    /**
     * Get whether the Bookie is force started in read only mode or not.
     *
     * @return true - if need to start a bookie in read only mode. Otherwise
     *         false.
     */
    public boolean isForceReadOnlyBookie() {
<span class="nc" id="L2846">        return getBoolean(FORCE_READ_ONLY_BOOKIE, false);</span>
    }

    /**
     * Get whether use bytes to throttle garbage collector compaction or not.
     *
     * @return true  - use Bytes,
     *         false - use Entries.
     */
    public boolean getIsThrottleByBytes() {
<span class="nc" id="L2856">        return getBoolean(IS_THROTTLE_BY_BYTES, false);</span>
    }

    /**
     * Set whether use bytes to throttle garbage collector compaction or not.
     *
     * @param byBytes true to use by bytes; false to use by entries
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setIsThrottleByBytes(boolean byBytes) {
<span class="nc" id="L2867">        setProperty(IS_THROTTLE_BY_BYTES, byBytes);</span>
<span class="nc" id="L2868">        return this;</span>
    }

    /**
     * Get the maximum number of entries which can be compacted without flushing.
     * Default is 100,000.
     *
     * @return the maximum number of unflushed entries
     */
    public int getCompactionMaxOutstandingRequests() {
<span class="nc" id="L2878">        return getInt(COMPACTION_MAX_OUTSTANDING_REQUESTS, 100000);</span>
    }

    /**
     * Set the maximum number of entries which can be compacted without flushing.
     *
     * &lt;p&gt;When compacting, the entries are written to the entrylog and the new offsets
     * are cached in memory. Once the entrylog is flushed the index is updated with
     * the new offsets. This parameter controls the number of entries added to the
     * entrylog before a flush is forced. A higher value for this parameter means
     * more memory will be used for offsets. Each offset consists of 3 longs.
     *
     * &lt;p&gt;This parameter should _not_ be modified unless you know what you're doing.
     * The default is 100,000.
     *
     * @param maxOutstandingRequests number of entries to compact before flushing
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setCompactionMaxOutstandingRequests(int maxOutstandingRequests) {
<span class="nc" id="L2898">        setProperty(COMPACTION_MAX_OUTSTANDING_REQUESTS, maxOutstandingRequests);</span>
<span class="nc" id="L2899">        return this;</span>
    }

    /**
     * Get the rate of compaction adds. Default is 1,000.
     *
     * @return rate of compaction (adds per second)
     * @deprecated  replaced by {@link #getCompactionRateByEntries()}
     */
    @Deprecated
    public int getCompactionRate() {
<span class="nc" id="L2910">        return getInt(COMPACTION_RATE, 1000);</span>
    }

    /**
     * Set the rate of compaction adds.
     *
     * @param rate rate of compaction adds (adds entries per second)
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setCompactionRate(int rate) {
<span class="nc" id="L2921">        setProperty(COMPACTION_RATE, rate);</span>
<span class="nc" id="L2922">        return this;</span>
    }

    /**
     * Get the rate of compaction adds. Default is 1,000.
     *
     * @return rate of compaction (adds entries per second)
     */
    public int getCompactionRateByEntries() {
<span class="nc" id="L2931">        return getInt(COMPACTION_RATE_BY_ENTRIES, getCompactionRate());</span>
    }

    /**
     * Set the rate of compaction adds.
     *
     * @param rate rate of compaction adds (adds entries per second)
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setCompactionRateByEntries(int rate) {
<span class="nc" id="L2942">        setProperty(COMPACTION_RATE_BY_ENTRIES, rate);</span>
<span class="nc" id="L2943">        return this;</span>
    }

    /**
     * Get the rate of compaction adds. Default is 1,000,000.
     *
     * @return rate of compaction (adds bytes per second)
     */
    public int getCompactionRateByBytes() {
<span class="nc" id="L2952">        return getInt(COMPACTION_RATE_BY_BYTES, 1000000);</span>
    }

    /**
     * Set the rate of compaction adds.
     *
     * @param rate rate of compaction adds (adds bytes per second)
     *
     * @return ServerConfiguration
     */
    public ServerConfiguration setCompactionRateByBytes(int rate) {
<span class="nc" id="L2963">        setProperty(COMPACTION_RATE_BY_BYTES, rate);</span>
<span class="nc" id="L2964">        return this;</span>
    }

    /**
     * Should we remove pages from page cache after force write.
     *
     * @return remove pages from cache
     */
    @Beta
    public boolean getJournalRemovePagesFromCache() {
<span class="nc" id="L2974">        return getBoolean(JOURNAL_REMOVE_FROM_PAGE_CACHE, true);</span>
    }

    /**
     * Sets that whether should we remove pages from page cache after force write.
     *
     * @param enabled
     *            - true if we need to remove pages from page cache. otherwise, false
     * @return ServerConfiguration
     */
    public ServerConfiguration setJournalRemovePagesFromCache(boolean enabled) {
<span class="nc" id="L2985">        setProperty(JOURNAL_REMOVE_FROM_PAGE_CACHE, enabled);</span>
<span class="nc" id="L2986">        return this;</span>
    }

    /*
     * Get the {@link LedgerStorage} implementation class name.
     *
     * @return the class name
     */
    public String getLedgerStorageClass() {
<span class="nc" id="L2995">        String ledgerStorageClass = LEDGER_STORAGE_CLASS_KEY.getString(this);</span>
<span class="nc bnc" id="L2996" title="All 2 branches missed.">        if (ledgerStorageClass.equals(SortedLedgerStorage.class.getName())</span>
<span class="nc bnc" id="L2997" title="All 2 branches missed.">                &amp;&amp; !getSortedLedgerStorageEnabled()) {</span>
            // This is to retain compatibility with BK-4.3 configuration
            // In BK-4.3, the ledger storage is configured through the &quot;sortedLedgerStorageEnabled&quot; flag :
            // sortedLedgerStorageEnabled == true (default) ---&gt; use SortedLedgerStorage
            // sortedLedgerStorageEnabled == false ---&gt; use InterleavedLedgerStorage
            //
            // Since BK-4.4, one can specify the implementation class, but if it was using InterleavedLedgerStorage it
            // should continue to use that with the same configuration
<span class="nc" id="L3005">            ledgerStorageClass = InterleavedLedgerStorage.class.getName();</span>
        }

<span class="nc" id="L3008">        return ledgerStorageClass;</span>
    }

    /**
     * Set the {@link LedgerStorage} implementation class name.
     *
     * @param ledgerStorageClass the class name
     * @return ServerConfiguration
     */
    public ServerConfiguration setLedgerStorageClass(String ledgerStorageClass) {
<span class="nc" id="L3018">        LEDGER_STORAGE_CLASS_KEY.set(this, ledgerStorageClass);</span>
<span class="nc" id="L3019">        return this;</span>
    }

    /**
     * Get whether bookie is using hostname for registration and in ledger
     * metadata. Defaults to false.
     *
     * @return true, then bookie will be registered with its hostname and
     *         hostname will be used in ledger metadata. Otherwise bookie will
     *         use its ipaddress
     */
    public boolean getUseHostNameAsBookieID() {
<span class="nc" id="L3031">        return getBoolean(USE_HOST_NAME_AS_BOOKIE_ID, false);</span>
    }

    /**
     * Configure the bookie to use its hostname to register with the
     * co-ordination service(eg: zookeeper) and in ledger metadata.
     *
     * @see #getUseHostNameAsBookieID
     * @param useHostName
     *            whether to use hostname for registration and in ledgermetadata
     * @return server configuration
     */
    public ServerConfiguration setUseHostNameAsBookieID(boolean useHostName) {
<span class="nc" id="L3044">        setProperty(USE_HOST_NAME_AS_BOOKIE_ID, useHostName);</span>
<span class="nc" id="L3045">        return this;</span>
    }

    /**
     * If bookie is using hostname for registration and in ledger metadata then
     * whether to use short hostname or FQDN hostname. Defaults to false.
     *
     * @return true, then bookie will be registered with its short hostname and
     *         short hostname will be used in ledger metadata. Otherwise bookie
     *         will use its FQDN hostname
     */
    public boolean getUseShortHostName() {
<span class="nc" id="L3057">        return getBoolean(USE_SHORT_HOST_NAME, false);</span>
    }

    /**
     * Configure the bookie to use its short hostname or FQDN hostname to
     * register with the co-ordination service(eg: zookeeper) and in ledger
     * metadata.
     *
     * @see #getUseShortHostName
     * @param useShortHostName
     *            whether to use short hostname for registration and in
     *            ledgermetadata
     * @return server configuration
     */
    public ServerConfiguration setUseShortHostName(boolean useShortHostName) {
<span class="nc" id="L3072">        setProperty(USE_SHORT_HOST_NAME, useShortHostName);</span>
<span class="nc" id="L3073">        return this;</span>
    }

    /**
     * Get whether to listen for local JVM clients. Defaults to false.
     *
     * @return true, then bookie will be listen for local JVM clients
     */
    public boolean isEnableLocalTransport() {
<span class="nc" id="L3082">        return getBoolean(ENABLE_LOCAL_TRANSPORT, false);</span>
    }

    /**
     * Configure the bookie to listen for BookKeeper clients executed on the local JVM.
     *
     * @see #isEnableLocalTransport
     * @param enableLocalTransport
     *            whether to use listen for local JVM clients
     * @return server configuration
     */
    public ServerConfiguration setEnableLocalTransport(boolean enableLocalTransport) {
<span class="nc" id="L3094">        setProperty(ENABLE_LOCAL_TRANSPORT, enableLocalTransport);</span>
<span class="nc" id="L3095">        return this;</span>
    }

    /**
     * Get whether to disable bind of server-side sockets. Defaults to false.
     *
     * @return true, then bookie will not listen for network connections
     */
    public boolean isDisableServerSocketBind() {
<span class="nc" id="L3104">        return getBoolean(DISABLE_SERVER_SOCKET_BIND, false);</span>
    }

    /**
     * Configure the bookie to disable bind on network interfaces,
     * this bookie will be available only to BookKeeper clients executed on the local JVM.
     *
     * @see #isDisableServerSocketBind
     * @param disableServerSocketBind
     *            whether to disable binding on network interfaces
     * @return server configuration
     */
    public ServerConfiguration setDisableServerSocketBind(boolean disableServerSocketBind) {
<span class="nc" id="L3117">        setProperty(DISABLE_SERVER_SOCKET_BIND, disableServerSocketBind);</span>
<span class="nc" id="L3118">        return this;</span>
    }

    /**
     * Get the stats provider used by bookie.
     *
     * @return stats provider class
     * @throws ConfigurationException
     */
    public Class&lt;? extends StatsProvider&gt; getStatsProviderClass()
        throws ConfigurationException {
<span class="nc" id="L3129">        return ReflectionUtils.getClass(this, STATS_PROVIDER_CLASS,</span>
                                        NullStatsProvider.class, StatsProvider.class,
                                        DEFAULT_LOADER);
    }

    /**
     * Set the stats provider used by bookie.
     *
     * @param providerClass
     *          stats provider class
     * @return server configuration
     */
    public ServerConfiguration setStatsProviderClass(Class&lt;? extends StatsProvider&gt; providerClass) {
<span class="nc" id="L3142">        setProperty(STATS_PROVIDER_CLASS, providerClass.getName());</span>
<span class="nc" id="L3143">        return this;</span>
    }

    /**
     * Validate the configuration.
     * @throws ConfigurationException
     */
    public void validate() throws ConfigurationException {
        // generate config def
<span class="nc" id="L3152">        ConfigDef configDef = ConfigDef.of(ServerConfiguration.class);</span>
        try {
<span class="nc" id="L3154">            configDef.validate(this);</span>
<span class="nc" id="L3155">        } catch (ConfigException e) {</span>
<span class="nc" id="L3156">            throw new ConfigurationException(e.getMessage(), e.getCause());</span>
<span class="nc" id="L3157">        }</span>

<span class="nc bnc" id="L3159" title="All 2 branches missed.">        if (getSkipListArenaChunkSize() &lt; getSkipListArenaMaxAllocSize()) {</span>
<span class="nc" id="L3160">            throw new ConfigurationException(&quot;Arena max allocation size should be smaller than the chunk size.&quot;);</span>
        }
<span class="nc bnc" id="L3162" title="All 4 branches missed.">        if (getJournalAlignmentSize() &lt; 512 || getJournalAlignmentSize() % 512 != 0) {</span>
<span class="nc" id="L3163">            throw new ConfigurationException(&quot;Invalid journal alignment size : &quot; + getJournalAlignmentSize());</span>
        }
<span class="nc bnc" id="L3165" title="All 2 branches missed.">        if (getJournalAlignmentSize() &gt; getJournalPreAllocSizeMB() * 1024 * 1024) {</span>
<span class="nc" id="L3166">            throw new ConfigurationException(&quot;Invalid preallocation size : &quot; + getJournalPreAllocSizeMB() + &quot; MB&quot;);</span>
        }
<span class="nc bnc" id="L3168" title="All 4 branches missed.">        if (0 == getBookiePort() &amp;&amp; !getAllowEphemeralPorts()) {</span>
<span class="nc" id="L3169">            throw new ConfigurationException(&quot;Invalid port specified, using ephemeral ports accidentally?&quot;);</span>
        }
<span class="nc bnc" id="L3171" title="All 4 branches missed.">        if (isEntryLogPerLedgerEnabled() &amp;&amp; getUseTransactionalCompaction()) {</span>
<span class="nc" id="L3172">            throw new ConfigurationException(</span>
                    &quot;When entryLogPerLedger is enabled , it is unnecessary to use transactional compaction&quot;);
        }
<span class="nc bnc" id="L3175" title="All 6 branches missed.">        if ((getJournalFormatVersionToWrite() &gt;= 6) ^ (getFileInfoFormatVersionToWrite() &gt;= 1)) {</span>
<span class="nc" id="L3176">            throw new ConfigurationException(&quot;For persisiting explicitLac, journalFormatVersionToWrite should be &gt;= 6&quot;</span>
                    + &quot;and FileInfoFormatVersionToWrite should be &gt;= 1&quot;);
        }
<span class="nc bnc" id="L3179" title="All 4 branches missed.">        if (getMinorCompactionInterval() &gt; 0 &amp;&amp; getMinorCompactionInterval() * SECOND &lt; getGcWaitTime()) {</span>
<span class="nc" id="L3180">            throw new ConfigurationException(&quot;minorCompactionInterval should be &gt;= gcWaitTime.&quot;);</span>
        }
<span class="nc bnc" id="L3182" title="All 4 branches missed.">        if (getMajorCompactionInterval() &gt; 0 &amp;&amp; getMajorCompactionInterval() * SECOND &lt; getGcWaitTime()) {</span>
<span class="nc" id="L3183">            throw new ConfigurationException(&quot;majorCompactionInterval should be &gt;= gcWaitTime.&quot;);</span>
        }
<span class="nc" id="L3185">    }</span>

    /**
     * Get Recv ByteBuf allocator initial buf size.
     *
     * @return initial byteBuf size
     */
    public int getRecvByteBufAllocatorSizeInitial() {
<span class="nc" id="L3193">        return getInt(BYTEBUF_ALLOCATOR_SIZE_INITIAL, 64 * 1024);</span>
    }

    /**
     * Set Recv ByteBuf allocator initial buf size.
     *
     * @param size
     *            buffer size
     */
    public void setRecvByteBufAllocatorSizeInitial(int size) {
<span class="nc" id="L3203">        setProperty(BYTEBUF_ALLOCATOR_SIZE_INITIAL, size);</span>
<span class="nc" id="L3204">    }</span>

    /**
     * Get Recv ByteBuf allocator min buf size.
     *
     * @return min byteBuf size
     */
    public int getRecvByteBufAllocatorSizeMin() {
<span class="nc" id="L3212">        return getInt(BYTEBUF_ALLOCATOR_SIZE_MIN, 64 * 1024);</span>
    }

    /**
     * Set Recv ByteBuf allocator min buf size.
     *
     * @param size
     *            buffer size
     */
    public void setRecvByteBufAllocatorSizeMin(int size) {
<span class="nc" id="L3222">        setProperty(BYTEBUF_ALLOCATOR_SIZE_MIN, size);</span>
<span class="nc" id="L3223">    }</span>

    /**
     * Get Recv ByteBuf allocator max buf size.
     *
     * @return max byteBuf size
     */
    public int getRecvByteBufAllocatorSizeMax() {
<span class="nc" id="L3231">        return getInt(BYTEBUF_ALLOCATOR_SIZE_MAX, 1 * 1024 * 1024);</span>
    }

    /**
     * Set Recv ByteBuf allocator max buf size.
     *
     * @param size
     *            buffer size
     */
    public void setRecvByteBufAllocatorSizeMax(int size) {
<span class="nc" id="L3241">        setProperty(BYTEBUF_ALLOCATOR_SIZE_MAX, size);</span>
<span class="nc" id="L3242">    }</span>

    /**
     * Set the bookie authentication provider factory class name.
     * If this is not set, no authentication will be used.
     *
     * @param factoryClass
     *          the bookie authentication provider factory class name
     */
    public void setBookieAuthProviderFactoryClass(String factoryClass) {
<span class="nc" id="L3252">        setProperty(BOOKIE_AUTH_PROVIDER_FACTORY_CLASS, factoryClass);</span>
<span class="nc" id="L3253">    }</span>

    /**
     * Get the bookie authentication provider factory class name.
     * If this returns null, no authentication will take place.
     *
     * @return the bookie authentication provider factory class name or null.
     */
    public String getBookieAuthProviderFactoryClass() {
<span class="nc" id="L3262">        return getString(BOOKIE_AUTH_PROVIDER_FACTORY_CLASS, null);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ServerConfiguration setNettyMaxFrameSizeBytes(int maxSize) {
<span class="nc" id="L3270">        super.setNettyMaxFrameSizeBytes(maxSize);</span>
<span class="nc" id="L3271">        return this;</span>
    }

    /**
     * Get the truststore type for client. Default is JKS.
     *
     * @return
     */
    public String getTLSTrustStoreType() {
<span class="nc" id="L3280">        return getString(TLS_TRUSTSTORE_TYPE, &quot;JKS&quot;);</span>
    }

    /**
     * Set the keystore type for client.
     *
     * @return
     */
    public ServerConfiguration setTLSKeyStoreType(String arg) {
<span class="nc" id="L3289">        setProperty(TLS_KEYSTORE_TYPE, arg);</span>
<span class="nc" id="L3290">        return this;</span>
    }

    /**
     * Get the keystore path for the client.
     *
     * @return
     */
    public String getTLSKeyStore() {
<span class="nc" id="L3299">        return getString(TLS_KEYSTORE, null);</span>
    }

    /**
     * Set the keystore path for the client.
     *
     * @return
     */
    public ServerConfiguration setTLSKeyStore(String arg) {
<span class="nc" id="L3308">        setProperty(TLS_KEYSTORE, arg);</span>
<span class="nc" id="L3309">        return this;</span>
    }

    /**
     * Get the path to file containing keystore password if the client keystore is password protected. Default is null.
     *
     * @return
     */
    public String getTLSKeyStorePasswordPath() {
<span class="nc" id="L3318">        return getString(TLS_KEYSTORE_PASSWORD_PATH, null);</span>
    }

    /**
     * Set the path to file containing keystore password, if the client keystore is password protected.
     *
     * @return
     */
    public ServerConfiguration setTLSKeyStorePasswordPath(String arg) {
<span class="nc" id="L3327">        setProperty(TLS_KEYSTORE_PASSWORD_PATH, arg);</span>
<span class="nc" id="L3328">        return this;</span>
    }

    /**
     * Get the keystore type for client. Default is JKS.
     *
     * @return
     */
    public String getTLSKeyStoreType() {
<span class="nc" id="L3337">        return getString(TLS_KEYSTORE_TYPE, &quot;JKS&quot;);</span>
    }

    /**
     * Set the truststore type for client.
     *
     * @return
     */
    public ServerConfiguration setTLSTrustStoreType(String arg) {
<span class="nc" id="L3346">        setProperty(TLS_TRUSTSTORE_TYPE, arg);</span>
<span class="nc" id="L3347">        return this;</span>
    }

    /**
     * Get the truststore path for the client.
     *
     * @return
     */
    public String getTLSTrustStore() {
<span class="nc" id="L3356">        return getString(TLS_TRUSTSTORE, null);</span>
    }

    /**
     * Set the truststore path for the client.
     *
     * @return
     */
    public ServerConfiguration setTLSTrustStore(String arg) {
<span class="nc" id="L3365">        setProperty(TLS_TRUSTSTORE, arg);</span>
<span class="nc" id="L3366">        return this;</span>
    }

    /**
     * Get the path to file containing truststore password if the client truststore is password protected. Default is
     * null.
     *
     * @return
     */
    public String getTLSTrustStorePasswordPath() {
<span class="nc" id="L3376">        return getString(TLS_TRUSTSTORE_PASSWORD_PATH, null);</span>
    }

    /**
     * Set the path to file containing truststore password, if the client truststore is password protected.
     *
     * @return
     */
    public ServerConfiguration setTLSTrustStorePasswordPath(String arg) {
<span class="nc" id="L3385">        setProperty(TLS_TRUSTSTORE_PASSWORD_PATH, arg);</span>
<span class="nc" id="L3386">        return this;</span>
    }

    /**
     * Get the path to file containing TLS Certificate.
     *
     * @return
     */
    public String getTLSCertificatePath() {
<span class="nc" id="L3395">        return getString(TLS_CERTIFICATE_PATH, null);</span>
    }

    /**
     * Set the path to file containing TLS Certificate.
     *
     * @return
     */
    public ServerConfiguration setTLSCertificatePath(String arg) {
<span class="nc" id="L3404">        setProperty(TLS_CERTIFICATE_PATH, arg);</span>
<span class="nc" id="L3405">        return this;</span>
    }


    /**
     * Whether to enable recording task execution stats.
     *
     * @return flag to enable/disable recording task execution stats.
     */
    public boolean getEnableTaskExecutionStats() {
<span class="nc" id="L3415">        return getBoolean(ENABLE_TASK_EXECUTION_STATS, false);</span>
    }

    /**
     * Enable/Disable recording task execution stats.
     *
     * @param enabled
     *          flag to enable/disable recording task execution stats.
     * @return client configuration.
     */
    public ServerConfiguration setEnableTaskExecutionStats(boolean enabled) {
<span class="nc" id="L3426">        setProperty(ENABLE_TASK_EXECUTION_STATS, enabled);</span>
<span class="nc" id="L3427">        return this;</span>
    }

    /**
     * Gets the minimum safe Usable size to be available in index directory for Bookie to create Index File while
     * replaying journal at the time of Bookie Start in Readonly Mode (in bytes).
     *
     * @return minimum safe usable size to be available in index directory for bookie to create index files.
     * @see #setMinUsableSizeForIndexFileCreation(long)
     */
    public long getMinUsableSizeForIndexFileCreation() {
<span class="nc" id="L3438">        return this.getLong(MIN_USABLESIZE_FOR_INDEXFILE_CREATION, 100 * 1024 * 1024L);</span>
    }

    /**
     * Sets the minimum safe Usable size to be available in index directory for Bookie to create Index File while
     * replaying journal at the time of Bookie Start in Readonly Mode (in bytes).
     *
     * &lt;p&gt;This parameter allows creating index files when there are enough disk spaces, even when the bookie
     * is running at readonly mode because of the disk usage is exceeding {@link #getDiskUsageThreshold()}. Because
     * compaction, journal replays can still write index files to disks when a bookie is readonly.
     *
     * @param minUsableSizeForIndexFileCreation min usable size for index file creation
     * @return server configuration
     */
    public ServerConfiguration setMinUsableSizeForIndexFileCreation(long minUsableSizeForIndexFileCreation) {
<span class="nc" id="L3453">        this.setProperty(MIN_USABLESIZE_FOR_INDEXFILE_CREATION, minUsableSizeForIndexFileCreation);</span>
<span class="nc" id="L3454">        return this;</span>
    }

    /**
     * Gets the minimum safe usable size to be available in ledger directory for Bookie to create entry log files.
     *
     * @return minimum safe usable size to be available in ledger directory for entry log file creation.
     * @see #setMinUsableSizeForEntryLogCreation(long)
     */
    public long getMinUsableSizeForEntryLogCreation() {
<span class="nc" id="L3464">        return this.getLong(MIN_USABLESIZE_FOR_ENTRYLOG_CREATION, (long) 1.2 * getEntryLogSizeLimit());</span>
    }

    /**
     * Sets the minimum safe usable size to be available in ledger directory for Bookie to create entry log files.
     *
     * &lt;p&gt;This parameter allows creating entry log files when there are enough disk spaces, even when the bookie
     * is running at readonly mode because of the disk usage is exceeding {@link #getDiskUsageThreshold()}. Because
     * compaction, journal replays can still write data to disks when a bookie is readonly.
     *
     * @param minUsableSizeForEntryLogCreation minimum safe usable size to be available in ledger directory
     * @return server configuration
     */
    public ServerConfiguration setMinUsableSizeForEntryLogCreation(long minUsableSizeForEntryLogCreation) {
<span class="nc" id="L3478">        this.setProperty(MIN_USABLESIZE_FOR_ENTRYLOG_CREATION, minUsableSizeForEntryLogCreation);</span>
<span class="nc" id="L3479">        return this;</span>
    }

    /**
     * Gets the minimum safe usable size to be available in ledger directory for Bookie to accept high priority writes.
     *
     * &lt;p&gt;If not set, it is the value of {@link #getMinUsableSizeForEntryLogCreation()}.
     *
     * @return the minimum safe usable size per ledger directory for bookie to accept high priority writes.
     */
    public long getMinUsableSizeForHighPriorityWrites() {
<span class="nc" id="L3490">        return this.getLong(MIN_USABLESIZE_FOR_HIGH_PRIORITY_WRITES, getMinUsableSizeForEntryLogCreation());</span>
    }

    /**
     * Sets the minimum safe usable size to be available in ledger directory for Bookie to accept high priority writes.
     *
     * @param minUsableSizeForHighPriorityWrites minimum safe usable size per ledger directory for Bookie to accept
     *                                           high priority writes
     * @return server configuration.
     */
    public ServerConfiguration setMinUsableSizeForHighPriorityWrites(long minUsableSizeForHighPriorityWrites) {
<span class="nc" id="L3501">        this.setProperty(MIN_USABLESIZE_FOR_HIGH_PRIORITY_WRITES, minUsableSizeForHighPriorityWrites);</span>
<span class="nc" id="L3502">        return this;</span>
    }

    /**
     * returns whether it is allowed to have multiple ledger/index/journal
     * Directories in the same filesystem diskpartition.
     *
     * @return
     */
    public boolean isAllowMultipleDirsUnderSameDiskPartition() {
<span class="nc" id="L3512">        return this.getBoolean(ALLOW_MULTIPLEDIRS_UNDER_SAME_DISKPARTITION, true);</span>
    }

    /**
     * Configure the Bookie to allow/disallow multiple ledger/index/journal
     * directories in the same filesystem diskpartition.
     *
     * @param allow
     *
     * @return server configuration object.
     */
    public ServerConfiguration setAllowMultipleDirsUnderSameDiskPartition(boolean allow) {
<span class="nc" id="L3524">        this.setProperty(ALLOW_MULTIPLEDIRS_UNDER_SAME_DISKPARTITION, allow);</span>
<span class="nc" id="L3525">        return this;</span>
    }

    /**
     * Get whether to start the http server or not.
     *
     * @return true - if http server should start
     */
    public boolean isHttpServerEnabled() {
<span class="nc" id="L3534">        return getBoolean(HTTP_SERVER_ENABLED, false);</span>
    }

    /**
     * Set whether to start the http server or not.
     *
     * @param enabled
     *            - true if we should start http server
     * @return ServerConfiguration
     */
    public ServerConfiguration setHttpServerEnabled(boolean enabled) {
<span class="nc" id="L3545">        setProperty(HTTP_SERVER_ENABLED, enabled);</span>
<span class="nc" id="L3546">        return this;</span>
    }

    /**
     * Get the http server port.
     *
     * @return http server port
     */
    public int getHttpServerPort() {
<span class="nc" id="L3555">        return getInt(HTTP_SERVER_PORT, 8080);</span>
    }

    /**
     * Set Http server port listening on.
     *
     * @param port
     *          Port to listen on
     * @return server configuration
     */
    public ServerConfiguration setHttpServerPort(int port) {
<span class="nc" id="L3566">        setProperty(HTTP_SERVER_PORT, port);</span>
<span class="nc" id="L3567">        return this;</span>
    }

    /**
     * Get the http server host.
     *
     * @return http server host
     */
    public String getHttpServerHost() {
<span class="nc" id="L3576">        return getString(HTTP_SERVER_HOST, &quot;0.0.0.0&quot;);</span>
    }

    /**
     * Set Http server host listening on.
     *
     * @param host
     *          host to listen on
     * @return server configuration
     */
    public ServerConfiguration setHttpServerHost(String host) {
<span class="nc" id="L3587">        setProperty(HTTP_SERVER_HOST, host);</span>
<span class="nc" id="L3588">        return this;</span>
    }

    /**
     * Get if Http Server Tls enable.
     * @return
     */
    public boolean isHttpServerTlsEnable() {
<span class="nc" id="L3596">        return getBoolean(HTTP_SERVER_TLS_ENABLE, false);</span>
    }

    /**
     * Set if Http Server Tls enable.
     * @param tlsEnable
     * @return server configuration
     */
    public ServerConfiguration setHttpServerTlsEnable(boolean tlsEnable) {
<span class="nc" id="L3605">        setProperty(HTTP_SERVER_TLS_ENABLE, tlsEnable);</span>
<span class="nc" id="L3606">        return this;</span>
    }

    /**
     * Get the http server keystore path.
     *
     * @return http server keystore path
     */
    public String getHttpServerKeystorePath() {
<span class="nc" id="L3615">        return getString(HTTP_SERVER_KEY_STORE_PATH);</span>
    }

    /**
     * Set Http server keystore path.
     *
     * @param keystorePath
     *          http server keystore path
     * @return server configuration
     */
    public ServerConfiguration setHttpServerKeystorePath(String keystorePath) {
<span class="nc" id="L3626">        setProperty(HTTP_SERVER_KEY_STORE_PATH, keystorePath);</span>
<span class="nc" id="L3627">        return this;</span>
    }

    /**
     * Get the http server keyStore password.
     *
     * @return http server keyStore password
     */
    public String getHttpServerKeystorePassword() {
<span class="nc" id="L3636">        return getString(HTTP_SERVER_KEY_STORE_PASSWORD);</span>
    }

    /**
     * Set Http server keyStore password.
     *
     * @param keyStorePassword
     *          http server keyStore password
     * @return server configuration
     */
    public ServerConfiguration setHttpServerKeyStorePassword(String keyStorePassword) {
<span class="nc" id="L3647">        setProperty(HTTP_SERVER_KEY_STORE_PASSWORD, keyStorePassword);</span>
<span class="nc" id="L3648">        return this;</span>
    }

    /**
     * Get the http server trustStore path.
     *
     * @return http server trustStore path
     */
    public String getHttpServerTrustStorePath() {
<span class="nc" id="L3657">        return getString(HTTP_SERVER_TRUST_STORE_PATH);</span>
    }

    /**
     * Set Http server trustStore path.
     *
     * @param trustStorePath
     *          http server trustStore path
     * @return server configuration
     */
    public ServerConfiguration setHttpServerTrustStorePath(String trustStorePath) {
<span class="nc" id="L3668">        setProperty(HTTP_SERVER_TRUST_STORE_PATH, trustStorePath);</span>
<span class="nc" id="L3669">        return this;</span>
    }

    /**
     * Get the http server trustStore password.
     *
     * @return http server trustStore password
     */
    public String getHttpServerTrustStorePassword() {
<span class="nc" id="L3678">        return getString(HTTP_SERVER_KEY_STORE_PASSWORD);</span>
    }

    /**
     * Set Http server trustStore password.
     *
     * @param trustStorePassword
     *          http server trustStore password
     * @return server configuration
     */
    public ServerConfiguration setHttpServerTrustStorePasswordPassword(String trustStorePassword) {
<span class="nc" id="L3689">        setProperty(HTTP_SERVER_TRUST_STORE_PASSWORD, trustStorePassword);</span>
<span class="nc" id="L3690">        return this;</span>
    }

    /**
     * Get the extra list of server lifecycle components to enable on a bookie server.
     *
     * @return the extra list of server lifecycle components to enable on a bookie server.
     */
    public String[] getExtraServerComponents() {
<span class="nc" id="L3699">        String extraServerComponentsStr = getString(EXTRA_SERVER_COMPONENTS);</span>
<span class="nc bnc" id="L3700" title="All 2 branches missed.">        if (Strings.isNullOrEmpty(extraServerComponentsStr)) {</span>
<span class="nc" id="L3701">            return null;</span>
        }
<span class="nc" id="L3703">        return this.getStringArray(EXTRA_SERVER_COMPONENTS);</span>
    }

    /**
     * Set the extra list of server lifecycle components to enable on a bookie server.
     *
     * @param componentClasses
     *          the list of server lifecycle components to enable on a bookie server.
     * @return server configuration.
     */
    public ServerConfiguration setExtraServerComponents(String[] componentClasses) {
<span class="nc" id="L3714">        this.setProperty(EXTRA_SERVER_COMPONENTS, componentClasses);</span>
<span class="nc" id="L3715">        return this;</span>
    }

    /**
     * Return the flag whether to ignore startup failures on loading server components specified at
     * {@link #getExtraServerComponents()}.
     *
     * @return the flag whether to ignore startup failures on loading server components specified at
     * {@link #getExtraServerComponents()}. The default value is &lt;tt&gt;false&lt;/tt&gt;.
     */
    public boolean getIgnoreExtraServerComponentsStartupFailures() {
<span class="nc" id="L3726">        return getBoolean(IGNORE_EXTRA_SERVER_COMPONENTS_STARTUP_FAILURES, false);</span>
    }

    /**
     * Set the flag whether to ignore startup failures on loading server components specified at
     * {@link #getExtraServerComponents()}.
     *
     * @param enabled flag to enable/disable ignoring startup failures on loading server components.
     * @return server configuration.
     */
    public ServerConfiguration setIgnoreExtraServerComponentsStartupFailures(boolean enabled) {
<span class="nc" id="L3737">        setProperty(IGNORE_EXTRA_SERVER_COMPONENTS_STARTUP_FAILURES, enabled);</span>
<span class="nc" id="L3738">        return this;</span>
    }

    /**
     * Get server netty channel write buffer low water mark.
     *
     * @return netty channel write buffer low water mark.
     */
    public int getServerWriteBufferLowWaterMark() {
<span class="nc" id="L3747">        return getInt(SERVER_WRITEBUFFER_LOW_WATER_MARK, 384 * 1024);</span>
    }

    /**
     * Set server netty channel write buffer low water mark.
     *
     * @param waterMark
     *          netty channel write buffer low water mark.
     * @return client configuration.
     */
    public ServerConfiguration setServerWriteBufferLowWaterMark(int waterMark) {
<span class="nc" id="L3758">        setProperty(SERVER_WRITEBUFFER_LOW_WATER_MARK, waterMark);</span>
<span class="nc" id="L3759">        return this;</span>
    }

    /**
     * Get server netty channel write buffer high water mark.
     *
     * @return netty channel write buffer high water mark.
     */
    public int getServerWriteBufferHighWaterMark() {
<span class="nc" id="L3768">        return getInt(SERVER_WRITEBUFFER_HIGH_WATER_MARK, 512 * 1024);</span>
    }

    /**
     * Set server netty channel write buffer high water mark.
     *
     * @param waterMark
     *          netty channel write buffer high water mark.
     * @return client configuration.
     */
    public ServerConfiguration setServerWriteBufferHighWaterMark(int waterMark) {
<span class="nc" id="L3779">        setProperty(SERVER_WRITEBUFFER_HIGH_WATER_MARK, waterMark);</span>
<span class="nc" id="L3780">        return this;</span>
    }
    /**
     * Set registration manager class.
     *
     * @param regManagerClass
     *            ManagerClass
     * @deprecated since 4.7.0, in favor of using {@link #setMetadataServiceUri(String)}
     */
    @Deprecated
    public void setRegistrationManagerClass(
            Class&lt;? extends RegistrationManager&gt; regManagerClass) {
<span class="nc" id="L3792">        setProperty(REGISTRATION_MANAGER_CLASS, regManagerClass);</span>
<span class="nc" id="L3793">    }</span>

    /**
     * Get Registration Manager Class.
     *
     * @return registration manager class.
     * @deprecated since 4.7.0, in favor of using {@link #getMetadataServiceUri()}
     */
    @Deprecated
    public Class&lt;? extends RegistrationManager&gt; getRegistrationManagerClass()
            throws ConfigurationException {
<span class="nc" id="L3804">        return ReflectionUtils.getClass(this, REGISTRATION_MANAGER_CLASS,</span>
                ZKRegistrationManager.class, RegistrationManager.class,
                DEFAULT_LOADER);
    }

    @Override
    protected ServerConfiguration getThis() {
<span class="nc" id="L3811">        return this;</span>
    }

    /*
     * specifies if entryLog per ledger is enabled. If it is enabled, then there
     * would be a active entrylog for each ledger
     */
    public boolean isEntryLogPerLedgerEnabled() {
<span class="nc" id="L3819">        return this.getBoolean(ENTRY_LOG_PER_LEDGER_ENABLED, false);</span>
    }

    /*
     * enables/disables entrylog per ledger feature.
     *
     */
    public ServerConfiguration setEntryLogPerLedgerEnabled(boolean entryLogPerLedgerEnabled) {
<span class="nc" id="L3827">        this.setProperty(ENTRY_LOG_PER_LEDGER_ENABLED, Boolean.toString(entryLogPerLedgerEnabled));</span>
<span class="nc" id="L3828">        return this;</span>
    }

    /*
     * In the case of multipleentrylogs, multiple threads can be used to flush the memtable.
     *
     * Gets the number of threads used to flush entrymemtable
     */
    public int getNumOfMemtableFlushThreads() {
<span class="nc" id="L3837">        return this.getInt(NUMBER_OF_MEMTABLE_FLUSH_THREADS, 8);</span>
    }

    /*
     * Sets the number of threads used to flush entrymemtable, in the case of multiple entrylogs
     *
     */
    public ServerConfiguration setNumOfMemtableFlushThreads(int numOfMemtableFlushThreads) {
<span class="nc" id="L3845">        this.setProperty(NUMBER_OF_MEMTABLE_FLUSH_THREADS, Integer.toString(numOfMemtableFlushThreads));</span>
<span class="nc" id="L3846">        return this;</span>
    }

    /*
     * in entryLogPerLedger feature, this specifies the time, once this duration
     * has elapsed after the entry's last access, that entry should be
     * automatically removed from the cache
     */
    public int getEntrylogMapAccessExpiryTimeInSeconds() {
<span class="nc" id="L3855">        return this.getInt(ENTRYLOGMAP_ACCESS_EXPIRYTIME_INSECONDS, 5 * 60);</span>
    }

    /*
     * sets the time duration for entrylogMapAccessExpiryTimeInSeconds, which will be used for cache eviction
     * policy, in entrylogperledger feature.
     */
    public ServerConfiguration setEntrylogMapAccessExpiryTimeInSeconds(int entrylogMapAccessExpiryTimeInSeconds) {
<span class="nc" id="L3863">        this.setProperty(ENTRYLOGMAP_ACCESS_EXPIRYTIME_INSECONDS,</span>
<span class="nc" id="L3864">                Integer.toString(entrylogMapAccessExpiryTimeInSeconds));</span>
<span class="nc" id="L3865">        return this;</span>
    }

    /*
     * get the maximum number of entrylogs that can be active at a given point
     * in time.
     */
    public int getMaximumNumberOfActiveEntryLogs() {
<span class="nc" id="L3873">        return this.getInt(MAXIMUM_NUMBER_OF_ACTIVE_ENTRYLOGS, 500);</span>
    }

    /*
     * sets the maximum number of entrylogs that can be active at a given point
     * in time.
     */
    public ServerConfiguration setMaximumNumberOfActiveEntryLogs(int maximumNumberOfActiveEntryLogs) {
<span class="nc" id="L3881">        this.setProperty(MAXIMUM_NUMBER_OF_ACTIVE_ENTRYLOGS,</span>
<span class="nc" id="L3882">                Integer.toString(maximumNumberOfActiveEntryLogs));</span>
<span class="nc" id="L3883">        return this;</span>
    }

    /*
     * in EntryLogManagerForEntryLogPerLedger, this config value specifies the
     * metrics cache size limits in multiples of entrylogMap cache size limits.
     */
    public int getEntryLogPerLedgerCounterLimitsMultFactor() {
<span class="nc" id="L3891">        return this.getInt(ENTRY_LOG_PER_LEDGER_COUNTER_LIMITS_MULT_FACTOR, 10);</span>
    }

    /*
     * in EntryLogManagerForEntryLogPerLedger, this config value specifies the
     * metrics cache size limits in multiples of entrylogMap cache size limits.
     */
    public ServerConfiguration setEntryLogPerLedgerCounterLimitsMultFactor(
            int entryLogPerLedgerCounterLimitsMultFactor) {
<span class="nc" id="L3900">        this.setProperty(ENTRY_LOG_PER_LEDGER_COUNTER_LIMITS_MULT_FACTOR,</span>
<span class="nc" id="L3901">                Integer.toString(entryLogPerLedgerCounterLimitsMultFactor));</span>
<span class="nc" id="L3902">        return this;</span>
    }

    /**
     * True if a local consistency check should be performed on startup.
     */
    public boolean isLocalConsistencyCheckOnStartup() {
<span class="nc" id="L3909">        return this.getBoolean(LOCAL_CONSISTENCY_CHECK_ON_STARTUP, false);</span>
    }

    /**
     * Get the authorized roles.
     *
     * @return String array of configured auth roles.
     */
    public String[] getAuthorizedRoles() {
<span class="nc" id="L3918">        return getStringArray(AUTHORIZED_ROLES);</span>
    }

    /**
     * Set authorized roles.
     *
     * @return Configuration Object with roles set
     */
    public ServerConfiguration setAuthorizedRoles(String roles) {
<span class="nc" id="L3927">        this.setProperty(AUTHORIZED_ROLES, roles);</span>
<span class="nc" id="L3928">        return this;</span>
    }

    /**
     * Get in flight read entry number when ledger checker.
     * Default value is -1 which it is unlimited  when ledger checker.
     *
     * @return read entry number of in flight.
     */
    public int getInFlightReadEntryNumInLedgerChecker(){
<span class="nc" id="L3938">        return getInt(IN_FLIGHT_READ_ENTRY_NUM_IN_LEDGER_CHECKER, -1);</span>
    }

    /**
     * Enabled data integrity checker.
     * The data integrity checker checks that the bookie has all the entries which
     * ledger metadata asserts it has.
     * The checker runs on startup (periodic will be added later).
     * The changes how cookies are handled. If a directory is found to be missing a cookie,
     * the check runs. The check is divided into two parts, preboot and full.
     * The preboot check ensures that it is safe to boot the bookie; the bookie will not
     * vote in any operation that contradicts a previous vote.
     * The full check ensures that any ledger that claims to have entries on the bookie,
     * truly does have data on the bookie. Any missing entries are copies from available
     * replicas.
     */
    public ServerConfiguration setDataIntegrityCheckingEnabled(boolean enabled) {
<span class="nc" id="L3955">        this.setProperty(DATA_INTEGRITY_CHECKING_ENABLED,</span>
<span class="nc" id="L3956">                         Boolean.toString(enabled));</span>
<span class="nc" id="L3957">        return this;</span>
    }

    /**
     * @see #setDataIntegrityCheckingEnabled
     */
    public boolean isDataIntegrityCheckingEnabled() {
<span class="nc" id="L3964">        return this.getBoolean(DATA_INTEGRITY_CHECKING_ENABLED, false);</span>
    }

    /**
     * When this config is set to true and the data integrity checker is also enabled then
     * any missing cookie files in the ledger directories do not prevent the bookie from
     * booting. Missing cookie files usually indicate an empty disk has been mounted, which
     * might be after a disk failure (all data lost) or a provisioning error (wrong disk mounted).
     * If there are missing cookie files then:
     * - a new cookie is stamped (written to each ledger directory and to the co-ordination service, eg: zookeeper).
     * - the data integrity checker will attempt to repair any lost data by sourcing the lost entries from other bookies
     * If any cookies do not match the master cookie, then cookie validation still fails as normal.
     */
    public ServerConfiguration setDataIntegrityStampMissingCookiesEnabled(boolean enabled) {
<span class="nc" id="L3978">        this.setProperty(DATA_INTEGRITY_COOKIE_STAMPING_ENABLED,</span>
<span class="nc" id="L3979">                Boolean.toString(enabled));</span>
<span class="nc" id="L3980">        return this;</span>
    }

    /**
     * @see #setDataIntegrityStampMissingCookiesEnabled
     */
    public boolean isDataIntegrityStampMissingCookiesEnabled() {
<span class="nc" id="L3987">        return this.getBoolean(DATA_INTEGRITY_COOKIE_STAMPING_ENABLED, false);</span>
    }

    /**
     * Get default rocksdb conf.
     *
     * @return String configured default rocksdb conf.
     */
    public String getDefaultRocksDBConf() {
<span class="nc" id="L3996">        String defaultPath = &quot;conf/default_rocksdb.conf&quot;;</span>
<span class="nc" id="L3997">        URL defURL = getClass().getClassLoader().getResource(defaultPath);</span>
<span class="nc bnc" id="L3998" title="All 2 branches missed.">        if (defURL != null) {</span>
<span class="nc" id="L3999">            defaultPath = defURL.getPath();</span>
        }
<span class="nc" id="L4001">        return getString(DEFAULT_ROCKSDB_CONF, defaultPath);</span>
    }

    /**
     * Set default rocksdb conf.
     *
     * @return Configuration Object with default rocksdb conf
     */
    public ServerConfiguration setDefaultRocksDBConf(String defaultRocksdbConf) {
<span class="nc" id="L4010">        this.setProperty(DEFAULT_ROCKSDB_CONF, defaultRocksdbConf);</span>
<span class="nc" id="L4011">        return this;</span>
    }

    /**
     * Get entry Location rocksdb conf.
     *
     * @return String configured entry Location rocksdb conf.
     */
    public String getEntryLocationRocksdbConf() {
<span class="nc" id="L4020">        String defaultPath = &quot;conf/entry_location_rocksdb.conf&quot;;</span>
<span class="nc" id="L4021">        URL defURL = getClass().getClassLoader().getResource(defaultPath);</span>
<span class="nc bnc" id="L4022" title="All 2 branches missed.">        if (defURL != null) {</span>
<span class="nc" id="L4023">            defaultPath = defURL.getPath();</span>
        }
<span class="nc" id="L4025">        return getString(ENTRY_LOCATION_ROCKSDB_CONF, defaultPath);</span>
    }

    /**
     * Set entry Location rocksdb conf.
     *
     * @return Configuration Object with entry Location rocksdb conf
     */
    public ServerConfiguration setEntryLocationRocksdbConf(String entryLocationRocksdbConf) {
<span class="nc" id="L4034">        this.setProperty(ENTRY_LOCATION_ROCKSDB_CONF, entryLocationRocksdbConf);</span>
<span class="nc" id="L4035">        return this;</span>
    }

    /**
     * Get ledger metadata rocksdb conf.
     *
     * @return String configured ledger metadata rocksdb conf.
     */
    public String getLedgerMetadataRocksdbConf() {
<span class="nc" id="L4044">        String defaultPath = &quot;conf/ledger_metadata_rocksdb.conf&quot;;</span>
<span class="nc" id="L4045">        URL defURL = getClass().getClassLoader().getResource(defaultPath);</span>
<span class="nc bnc" id="L4046" title="All 2 branches missed.">        if (defURL != null) {</span>
<span class="nc" id="L4047">            defaultPath = defURL.getPath();</span>
        }
<span class="nc" id="L4049">        return getString(LEDGER_METADATA_ROCKSDB_CONF, defaultPath);</span>
    }

    /**
     * Set ledger metadata rocksdb conf.
     *
     * @return Configuration Object with ledger metadata rocksdb conf
     */
    public ServerConfiguration setLedgerMetadataRocksdbConf(String ledgerMetadataRocksdbConf) {
<span class="nc" id="L4058">        this.setProperty(LEDGER_METADATA_ROCKSDB_CONF, ledgerMetadataRocksdbConf);</span>
<span class="nc" id="L4059">        return this;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>