<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Auditor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.replication</a> &gt; <span class="el_source">Auditor.java</span></div><h1>Auditor.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.replication;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.SettableFuture;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;
import org.apache.bookkeeper.client.BKException;
import org.apache.bookkeeper.client.BookKeeper;
import org.apache.bookkeeper.client.BookKeeperAdmin;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.meta.LedgerManager;
import org.apache.bookkeeper.meta.LedgerManagerFactory;
import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;
import org.apache.bookkeeper.meta.UnderreplicatedLedger;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;
import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;
import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.commons.collections4.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Auditor is a single entity in the entire Bookie cluster and will be watching
 * all the bookies under 'ledgerrootpath/available' zkpath. When any of the
 * bookie failed or disconnected from zk, he will start initiating the
 * re-replication activities by keeping all the corresponding ledgers of the
 * failed bookie as underreplicated znode in zk.
 *
 * &lt;p&gt;TODO: eliminate the direct usage of zookeeper here {@link https://github.com/apache/bookkeeper/issues/1332}
 */
public class Auditor implements AutoCloseable {
<span class="nc" id="L71">    private static final Logger LOG = LoggerFactory.getLogger(Auditor.class);</span>
    private final ServerConfiguration conf;
    private final BookKeeper bkc;
    private final boolean ownBkc;
    private final BookKeeperAdmin admin;
    private final boolean ownAdmin;
    private BookieLedgerIndexer bookieLedgerIndexer;
    private LedgerManager ledgerManager;
    private LedgerUnderreplicationManager ledgerUnderreplicationManager;
    private final ScheduledExecutorService executor;
<span class="nc" id="L81">    private List&lt;String&gt; knownBookies = new ArrayList&lt;String&gt;();</span>
    private final String bookieIdentifier;
    protected volatile Future&lt;?&gt; auditTask;
<span class="nc" id="L84">    private final Set&lt;String&gt; bookiesToBeAudited = Sets.newHashSet();</span>
    private volatile int lostBookieRecoveryDelayBeforeChange;
    protected AuditorBookieCheckTask auditorBookieCheckTask;
    protected AuditorTask auditorCheckAllLedgersTask;
    protected AuditorTask auditorPlacementPolicyCheckTask;
    protected AuditorTask auditorReplicasCheckTask;
<span class="nc" id="L90">    private final List&lt;AuditorTask&gt; allAuditorTasks = Lists.newArrayList();</span>

    private final AuditorStats auditorStats;

    static BookKeeper createBookKeeperClient(ServerConfiguration conf) throws InterruptedException, IOException {
<span class="nc" id="L95">        return createBookKeeperClient(conf, NullStatsLogger.INSTANCE);</span>
    }

    static BookKeeper createBookKeeperClient(ServerConfiguration conf, StatsLogger statsLogger)
            throws InterruptedException, IOException {
<span class="nc" id="L100">        ClientConfiguration clientConfiguration = new ClientConfiguration(conf);</span>
<span class="nc" id="L101">        clientConfiguration.setClientRole(ClientConfiguration.CLIENT_ROLE_SYSTEM);</span>
        try {
<span class="nc" id="L103">            return BookKeeper.forConfig(clientConfiguration).statsLogger(statsLogger).build();</span>
<span class="nc" id="L104">        } catch (BKException e) {</span>
<span class="nc" id="L105">            throw new IOException(&quot;Failed to create bookkeeper client&quot;, e);</span>
        }
    }

    static BookKeeper createBookKeeperClientThrowUnavailableException(ServerConfiguration conf)
            throws UnavailableException {
        try {
<span class="nc" id="L112">            return createBookKeeperClient(conf);</span>
<span class="nc" id="L113">        } catch (InterruptedException e) {</span>
<span class="nc" id="L114">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L115">            throw new UnavailableException(&quot;Failed to create bookkeeper client&quot;, e);</span>
<span class="nc" id="L116">        } catch (IOException e) {</span>
<span class="nc" id="L117">            throw new UnavailableException(&quot;Failed to create bookkeeper client&quot;, e);</span>
        }
    }

    public Auditor(final String bookieIdentifier,
                   ServerConfiguration conf,
                   StatsLogger statsLogger)
            throws UnavailableException {
<span class="nc" id="L125">        this(</span>
                bookieIdentifier,
                conf,
<span class="nc" id="L128">                createBookKeeperClientThrowUnavailableException(conf),</span>
                true,
                statsLogger);
<span class="nc" id="L131">    }</span>

    public Auditor(final String bookieIdentifier,
                   ServerConfiguration conf,
                   BookKeeper bkc,
                   boolean ownBkc,
                   StatsLogger statsLogger)
            throws UnavailableException {
<span class="nc" id="L139">        this(bookieIdentifier,</span>
                conf,
                bkc,
                ownBkc,
                new BookKeeperAdmin(bkc, statsLogger, new ClientConfiguration(conf)),
                true,
                statsLogger);
<span class="nc" id="L146">    }</span>

    public Auditor(final String bookieIdentifier,
                   ServerConfiguration conf,
                   BookKeeper bkc,
                   boolean ownBkc,
                   BookKeeperAdmin admin,
                   boolean ownAdmin,
                   StatsLogger statsLogger)
<span class="nc" id="L155">            throws UnavailableException {</span>
<span class="nc" id="L156">        this.conf = conf;</span>
<span class="nc" id="L157">        this.bookieIdentifier = bookieIdentifier;</span>
<span class="nc" id="L158">        this.auditorStats = new AuditorStats(statsLogger);</span>

<span class="nc" id="L160">        this.bkc = bkc;</span>
<span class="nc" id="L161">        this.ownBkc = ownBkc;</span>
<span class="nc" id="L162">        this.admin = admin;</span>
<span class="nc" id="L163">        this.ownAdmin = ownAdmin;</span>
<span class="nc" id="L164">        initialize(conf, bkc);</span>

<span class="nc" id="L166">        AuditorTask.ShutdownTaskHandler shutdownTaskHandler = this::submitShutdownTask;</span>
<span class="nc" id="L167">        BiConsumer&lt;Void, Throwable&gt; submitBookieCheckTask = (ignore, throwable) -&gt; this.submitBookieCheckTask();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        BiConsumer&lt;AtomicBoolean, Throwable&gt; hasAuditCheckTask = (flag, throwable) -&gt; flag.set(auditTask != null);</span>
<span class="nc" id="L169">        this.auditorBookieCheckTask = new AuditorBookieCheckTask(</span>
                conf, auditorStats, admin, ledgerManager,
                ledgerUnderreplicationManager, shutdownTaskHandler,
                bookieLedgerIndexer, hasAuditCheckTask, submitBookieCheckTask);
<span class="nc" id="L173">        allAuditorTasks.add(auditorBookieCheckTask);</span>
<span class="nc" id="L174">        this.auditorCheckAllLedgersTask = new AuditorCheckAllLedgersTask(</span>
                conf, auditorStats, admin, ledgerManager,
                ledgerUnderreplicationManager, shutdownTaskHandler, hasAuditCheckTask);
<span class="nc" id="L177">        allAuditorTasks.add(auditorCheckAllLedgersTask);</span>
<span class="nc" id="L178">        this.auditorPlacementPolicyCheckTask = new AuditorPlacementPolicyCheckTask(</span>
                conf, auditorStats, admin, ledgerManager,
                ledgerUnderreplicationManager, shutdownTaskHandler, hasAuditCheckTask);
<span class="nc" id="L181">        allAuditorTasks.add(auditorPlacementPolicyCheckTask);</span>
<span class="nc" id="L182">        this.auditorReplicasCheckTask = new AuditorReplicasCheckTask(</span>
                conf, auditorStats, admin, ledgerManager,
                ledgerUnderreplicationManager, shutdownTaskHandler, hasAuditCheckTask);
<span class="nc" id="L185">        allAuditorTasks.add(auditorReplicasCheckTask);</span>

<span class="nc" id="L187">        executor = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</span>
            @Override
            public Thread newThread(Runnable r) {
<span class="nc" id="L190">                Thread t = new Thread(r, &quot;AuditorBookie-&quot; + bookieIdentifier);</span>
<span class="nc" id="L191">                t.setDaemon(true);</span>
<span class="nc" id="L192">                return t;</span>
            }
        });
<span class="nc" id="L195">    }</span>

    private void initialize(ServerConfiguration conf, BookKeeper bkc)
            throws UnavailableException {
        try {
<span class="nc" id="L200">            LedgerManagerFactory ledgerManagerFactory = bkc.getLedgerManagerFactory();</span>
<span class="nc" id="L201">            ledgerManager = ledgerManagerFactory.newLedgerManager();</span>
<span class="nc" id="L202">            this.bookieLedgerIndexer = new BookieLedgerIndexer(ledgerManager);</span>

<span class="nc" id="L204">            this.ledgerUnderreplicationManager = ledgerManagerFactory</span>
<span class="nc" id="L205">                    .newLedgerUnderreplicationManager();</span>
<span class="nc" id="L206">            LOG.info(&quot;AuthProvider used by the Auditor is {}&quot;,</span>
<span class="nc" id="L207">                    admin.getConf().getClientAuthProviderFactoryClass());</span>
<span class="nc" id="L208">            if (this.ledgerUnderreplicationManager</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                    .initializeLostBookieRecoveryDelay(conf.getLostBookieRecoveryDelay())) {</span>
<span class="nc" id="L210">                LOG.info(&quot;Initializing lostBookieRecoveryDelay zNode to the conf value: {}&quot;,</span>
<span class="nc" id="L211">                        conf.getLostBookieRecoveryDelay());</span>
            } else {
<span class="nc" id="L213">                LOG.info(&quot;Valid lostBookieRecoveryDelay zNode is available, so not creating &quot;</span>
                        + &quot;lostBookieRecoveryDelay zNode as part of Auditor initialization &quot;);
            }
<span class="nc" id="L216">            lostBookieRecoveryDelayBeforeChange = this.ledgerUnderreplicationManager.getLostBookieRecoveryDelay();</span>
<span class="nc" id="L217">        } catch (CompatibilityException ce) {</span>
<span class="nc" id="L218">            throw new UnavailableException(</span>
                    &quot;CompatibilityException while initializing Auditor&quot;, ce);
<span class="nc" id="L220">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L221">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L222">            throw new UnavailableException(</span>
                    &quot;Interrupted while initializing Auditor&quot;, ie);
<span class="nc" id="L224">        }</span>
<span class="nc" id="L225">    }</span>

    private void submitShutdownTask() {
<span class="nc" id="L228">        synchronized (this) {</span>
<span class="nc" id="L229">            LOG.info(&quot;Executing submitShutdownTask&quot;);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (executor.isShutdown()) {</span>
<span class="nc" id="L231">                LOG.info(&quot;executor is already shutdown&quot;);</span>
<span class="nc" id="L232">                return;</span>
            }
<span class="nc" id="L234">            executor.submit(() -&gt; {</span>
<span class="nc" id="L235">                synchronized (Auditor.this) {</span>
<span class="nc" id="L236">                    LOG.info(&quot;Shutting down Auditor's Executor&quot;);</span>
<span class="nc" id="L237">                    executor.shutdown();</span>
<span class="nc" id="L238">                }</span>
<span class="nc" id="L239">            });</span>
<span class="nc" id="L240">        }</span>
<span class="nc" id="L241">    }</span>

    @VisibleForTesting
    synchronized Future&lt;?&gt; submitAuditTask() {
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (executor.isShutdown()) {</span>
<span class="nc" id="L246">            SettableFuture&lt;Void&gt; f = SettableFuture.&lt;Void&gt;create();</span>
<span class="nc" id="L247">            f.setException(new BKAuditException(&quot;Auditor shutting down&quot;));</span>
<span class="nc" id="L248">            return f;</span>
        }
<span class="nc" id="L250">        return executor.submit(() -&gt; {</span>
            try {
<span class="nc" id="L252">                waitIfLedgerReplicationDisabled();</span>
<span class="nc" id="L253">                int lostBookieRecoveryDelay = Auditor.this.ledgerUnderreplicationManager</span>
<span class="nc" id="L254">                        .getLostBookieRecoveryDelay();</span>
<span class="nc" id="L255">                List&lt;String&gt; availableBookies = getAvailableBookies();</span>

                // casting to String, as knownBookies and availableBookies
                // contains only String values
                // find new bookies(if any) and update the known bookie list
<span class="nc" id="L260">                Collection&lt;String&gt; newBookies = CollectionUtils.subtract(</span>
                        availableBookies, knownBookies);
<span class="nc" id="L262">                knownBookies.addAll(newBookies);</span>
<span class="nc bnc" id="L263" title="All 4 branches missed.">                if (!bookiesToBeAudited.isEmpty() &amp;&amp; knownBookies.containsAll(bookiesToBeAudited)) {</span>
                    // the bookie, which went down earlier and had an audit scheduled for,
                    // has come up. So let us stop tracking it and cancel the audit. Since
                    // we allow delaying of audit when there is only one failed bookie,
                    // bookiesToBeAudited should just have 1 element and hence containsAll
                    // check should be ok
<span class="nc bnc" id="L269" title="All 4 branches missed.">                    if (auditTask != null &amp;&amp; auditTask.cancel(false)) {</span>
<span class="nc" id="L270">                        auditTask = null;</span>
<span class="nc" id="L271">                        auditorStats.getNumDelayedBookieAuditsCancelled().inc();</span>
                    }
<span class="nc" id="L273">                    bookiesToBeAudited.clear();</span>
                }

                // find lost bookies(if any)
<span class="nc" id="L277">                bookiesToBeAudited.addAll(CollectionUtils.subtract(knownBookies, availableBookies));</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                if (bookiesToBeAudited.size() == 0) {</span>
<span class="nc" id="L279">                    return;</span>
                }

<span class="nc" id="L282">                knownBookies.removeAll(bookiesToBeAudited);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if (lostBookieRecoveryDelay == 0) {</span>
<span class="nc" id="L284">                    auditorBookieCheckTask.startAudit(false);</span>
<span class="nc" id="L285">                    bookiesToBeAudited.clear();</span>
<span class="nc" id="L286">                    return;</span>
                }
<span class="nc bnc" id="L288" title="All 2 branches missed.">                if (bookiesToBeAudited.size() &gt; 1) {</span>
                    // if more than one bookie is down, start the audit immediately;
<span class="nc" id="L290">                    LOG.info(&quot;Multiple bookie failure; not delaying bookie audit. &quot;</span>
                                    + &quot;Bookies lost now: {}; All lost bookies: {}&quot;,
<span class="nc" id="L292">                            CollectionUtils.subtract(knownBookies, availableBookies),</span>
                            bookiesToBeAudited);
<span class="nc bnc" id="L294" title="All 4 branches missed.">                    if (auditTask != null &amp;&amp; auditTask.cancel(false)) {</span>
<span class="nc" id="L295">                        auditTask = null;</span>
<span class="nc" id="L296">                        auditorStats.getNumDelayedBookieAuditsCancelled().inc();</span>
                    }
<span class="nc" id="L298">                    auditorBookieCheckTask.startAudit(false);</span>
<span class="nc" id="L299">                    bookiesToBeAudited.clear();</span>
<span class="nc" id="L300">                    return;</span>
                }
<span class="nc bnc" id="L302" title="All 2 branches missed.">                if (auditTask == null) {</span>
                    // if there is no scheduled audit, schedule one
<span class="nc" id="L304">                    auditTask = executor.schedule(() -&gt; {</span>
<span class="nc" id="L305">                        auditorBookieCheckTask.startAudit(false);</span>
<span class="nc" id="L306">                        auditTask = null;</span>
<span class="nc" id="L307">                        bookiesToBeAudited.clear();</span>
<span class="nc" id="L308">                    }, lostBookieRecoveryDelay, TimeUnit.SECONDS);</span>
<span class="nc" id="L309">                    auditorStats.getNumBookieAuditsDelayed().inc();</span>
<span class="nc" id="L310">                    LOG.info(&quot;Delaying bookie audit by {} secs for {}&quot;, lostBookieRecoveryDelay,</span>
                            bookiesToBeAudited);
                }
<span class="nc" id="L313">            } catch (BKException bke) {</span>
<span class="nc" id="L314">                LOG.error(&quot;Exception getting bookie list&quot;, bke);</span>
<span class="nc" id="L315">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L316">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L317">                LOG.error(&quot;Interrupted while watching available bookies &quot;, ie);</span>
<span class="nc" id="L318">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L319">                LOG.error(&quot;Exception while watching available bookies&quot;, ue);</span>
<span class="nc" id="L320">            }</span>
<span class="nc" id="L321">        });</span>
    }

    synchronized Future&lt;?&gt; submitLostBookieRecoveryDelayChangedEvent() {
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (executor.isShutdown()) {</span>
<span class="nc" id="L326">            SettableFuture&lt;Void&gt; f = SettableFuture.&lt;Void&gt;create();</span>
<span class="nc" id="L327">            f.setException(new BKAuditException(&quot;Auditor shutting down&quot;));</span>
<span class="nc" id="L328">            return f;</span>
        }
<span class="nc" id="L330">        return executor.submit(() -&gt; {</span>
<span class="nc" id="L331">            int lostBookieRecoveryDelay = -1;</span>
            try {
<span class="nc" id="L333">                waitIfLedgerReplicationDisabled();</span>
<span class="nc" id="L334">                lostBookieRecoveryDelay = Auditor.this.ledgerUnderreplicationManager</span>
<span class="nc" id="L335">                        .getLostBookieRecoveryDelay();</span>
                // if there is pending auditTask, cancel the task. So that it can be rescheduled
                // after new lostBookieRecoveryDelay period
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if (auditTask != null) {</span>
<span class="nc" id="L339">                    LOG.info(&quot;lostBookieRecoveryDelay period has been changed so canceling the pending AuditTask&quot;);</span>
<span class="nc" id="L340">                    auditTask.cancel(false);</span>
<span class="nc" id="L341">                    auditorStats.getNumDelayedBookieAuditsCancelled().inc();</span>
                }

                // if lostBookieRecoveryDelay is set to its previous value then consider it as
                // signal to trigger the Audit immediately.
<span class="nc bnc" id="L346" title="All 4 branches missed.">                if ((lostBookieRecoveryDelay == 0)</span>
                        || (lostBookieRecoveryDelay == lostBookieRecoveryDelayBeforeChange)) {
<span class="nc" id="L348">                    LOG.info(</span>
                            &quot;lostBookieRecoveryDelay has been set to 0 or reset to its previous value, &quot;
                                    + &quot;so starting AuditTask. Current lostBookieRecoveryDelay: {}, &quot;
                                    + &quot;previous lostBookieRecoveryDelay: {}&quot;,
<span class="nc" id="L352">                            lostBookieRecoveryDelay, lostBookieRecoveryDelayBeforeChange);</span>
<span class="nc" id="L353">                    auditorBookieCheckTask.startAudit(false);</span>
<span class="nc" id="L354">                    auditTask = null;</span>
<span class="nc" id="L355">                    bookiesToBeAudited.clear();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                } else if (auditTask != null) {</span>
<span class="nc" id="L357">                    LOG.info(&quot;lostBookieRecoveryDelay has been set to {}, so rescheduling AuditTask accordingly&quot;,</span>
<span class="nc" id="L358">                            lostBookieRecoveryDelay);</span>
<span class="nc" id="L359">                    auditTask = executor.schedule(() -&gt; {</span>
<span class="nc" id="L360">                        auditorBookieCheckTask.startAudit(false);</span>
<span class="nc" id="L361">                        auditTask = null;</span>
<span class="nc" id="L362">                        bookiesToBeAudited.clear();</span>
<span class="nc" id="L363">                    }, lostBookieRecoveryDelay, TimeUnit.SECONDS);</span>
<span class="nc" id="L364">                    auditorStats.getNumBookieAuditsDelayed().inc();</span>
                }
<span class="nc" id="L366">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L367">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L368">                LOG.error(&quot;Interrupted while for LedgersReplication to be enabled &quot;, ie);</span>
<span class="nc" id="L369">            } catch (ReplicationException.NonRecoverableReplicationException nre) {</span>
<span class="nc" id="L370">                LOG.error(&quot;Non Recoverable Exception while reading from ZK&quot;, nre);</span>
<span class="nc" id="L371">                submitShutdownTask();</span>
<span class="nc" id="L372">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L373">                LOG.error(&quot;Exception while reading from ZK&quot;, ue);</span>
            } finally {
<span class="nc bnc" id="L375" title="All 2 branches missed.">                if (lostBookieRecoveryDelay != -1) {</span>
<span class="nc" id="L376">                    lostBookieRecoveryDelayBeforeChange = lostBookieRecoveryDelay;</span>
                }
            }
<span class="nc" id="L379">        });</span>
    }

    public void start() {
<span class="nc" id="L383">        LOG.info(&quot;I'm starting as Auditor Bookie. ID: {}&quot;, bookieIdentifier);</span>
        // on startup watching available bookie and based on the
        // available bookies determining the bookie failures.
<span class="nc" id="L386">        synchronized (this) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (executor.isShutdown()) {</span>
<span class="nc" id="L388">                return;</span>
            }

            try {
<span class="nc" id="L392">                watchBookieChanges();</span>
<span class="nc" id="L393">                knownBookies = getAvailableBookies();</span>
<span class="nc" id="L394">            } catch (BKException bke) {</span>
<span class="nc" id="L395">                LOG.error(&quot;Couldn't get bookie list, so exiting&quot;, bke);</span>
<span class="nc" id="L396">                submitShutdownTask();</span>
<span class="nc" id="L397">            }</span>

            try {
<span class="nc" id="L400">                this.ledgerUnderreplicationManager</span>
<span class="nc" id="L401">                        .notifyLostBookieRecoveryDelayChanged(new LostBookieRecoveryDelayChangedCb());</span>
<span class="nc" id="L402">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L403">                LOG.error(&quot;Exception while registering for LostBookieRecoveryDelay change notification, so exiting&quot;,</span>
                        ue);
<span class="nc" id="L405">                submitShutdownTask();</span>
<span class="nc" id="L406">            }</span>

            try {
<span class="nc" id="L409">                this.ledgerUnderreplicationManager.notifyUnderReplicationLedgerChanged(</span>
                        new UnderReplicatedLedgersChangedCb());
<span class="nc" id="L411">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L412">                LOG.error(&quot;Exception while registering for under-replicated ledgers change notification, so exiting&quot;,</span>
                        ue);
<span class="nc" id="L414">                submitShutdownTask();</span>
<span class="nc" id="L415">            }</span>

<span class="nc" id="L417">            scheduleBookieCheckTask();</span>
<span class="nc" id="L418">            scheduleCheckAllLedgersTask();</span>
<span class="nc" id="L419">            schedulePlacementPolicyCheckTask();</span>
<span class="nc" id="L420">            scheduleReplicasCheckTask();</span>
<span class="nc" id="L421">        }</span>
<span class="nc" id="L422">    }</span>

    protected void submitBookieCheckTask() {
<span class="nc" id="L425">        executor.submit(auditorBookieCheckTask);</span>
<span class="nc" id="L426">    }</span>

    private void scheduleBookieCheckTask() {
<span class="nc" id="L429">        long bookieCheckInterval = conf.getAuditorPeriodicBookieCheckInterval();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (bookieCheckInterval == 0) {</span>
<span class="nc" id="L431">            LOG.info(&quot;Auditor periodic bookie checking disabled, running once check now anyhow&quot;);</span>
<span class="nc" id="L432">            submitBookieCheckTask();</span>
        } else {
<span class="nc" id="L434">            LOG.info(&quot;Auditor periodic bookie checking enabled&quot; + &quot; 'auditorPeriodicBookieCheckInterval' {} seconds&quot;,</span>
<span class="nc" id="L435">                    bookieCheckInterval);</span>
<span class="nc" id="L436">            executor.scheduleAtFixedRate(auditorBookieCheckTask, 0, bookieCheckInterval, TimeUnit.SECONDS);</span>
        }
<span class="nc" id="L438">    }</span>

    private void scheduleCheckAllLedgersTask() {
<span class="nc" id="L441">        long interval = conf.getAuditorPeriodicCheckInterval();</span>

<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (interval &gt; 0) {</span>
<span class="nc" id="L444">            LOG.info(&quot;Auditor periodic ledger checking enabled&quot; + &quot; 'auditorPeriodicCheckInterval' {} seconds&quot;,</span>
<span class="nc" id="L445">                    interval);</span>

            long checkAllLedgersLastExecutedCTime;
            long durationSinceLastExecutionInSecs;
            long initialDelay;
            try {
<span class="nc" id="L451">                checkAllLedgersLastExecutedCTime = ledgerUnderreplicationManager.getCheckAllLedgersCTime();</span>
<span class="nc" id="L452">            } catch (ReplicationException.NonRecoverableReplicationException nre) {</span>
<span class="nc" id="L453">                LOG.error(&quot;Non Recoverable Exception while reading from ZK&quot;, nre);</span>
<span class="nc" id="L454">                submitShutdownTask();</span>
<span class="nc" id="L455">                return;</span>
<span class="nc" id="L456">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L457">                LOG.error(&quot;Got UnavailableException while trying to get checkAllLedgersCTime&quot;, ue);</span>
<span class="nc" id="L458">                checkAllLedgersLastExecutedCTime = -1;</span>
<span class="nc" id="L459">            }</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            if (checkAllLedgersLastExecutedCTime == -1) {</span>
<span class="nc" id="L461">                durationSinceLastExecutionInSecs = -1;</span>
<span class="nc" id="L462">                initialDelay = 0;</span>
            } else {
<span class="nc" id="L464">                durationSinceLastExecutionInSecs = (System.currentTimeMillis() - checkAllLedgersLastExecutedCTime)</span>
                        / 1000;
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (durationSinceLastExecutionInSecs &lt; 0) {</span>
                    // this can happen if there is no strict time ordering
<span class="nc" id="L468">                    durationSinceLastExecutionInSecs = 0;</span>
                }
<span class="nc bnc" id="L470" title="All 2 branches missed.">                initialDelay = durationSinceLastExecutionInSecs &gt; interval ? 0</span>
<span class="nc" id="L471">                        : (interval - durationSinceLastExecutionInSecs);</span>
            }
<span class="nc" id="L473">            LOG.info(</span>
                    &quot;checkAllLedgers scheduling info.  checkAllLedgersLastExecutedCTime: {} &quot;
                            + &quot;durationSinceLastExecutionInSecs: {} initialDelay: {} interval: {}&quot;,
<span class="nc" id="L476">                    checkAllLedgersLastExecutedCTime, durationSinceLastExecutionInSecs, initialDelay, interval);</span>

<span class="nc" id="L478">            executor.scheduleAtFixedRate(auditorCheckAllLedgersTask, initialDelay, interval, TimeUnit.SECONDS);</span>
<span class="nc" id="L479">        } else {</span>
<span class="nc" id="L480">            LOG.info(&quot;Periodic checking disabled&quot;);</span>
        }
<span class="nc" id="L482">    }</span>

    private void schedulePlacementPolicyCheckTask() {
<span class="nc" id="L485">        long interval = conf.getAuditorPeriodicPlacementPolicyCheckInterval();</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (interval &gt; 0) {</span>
<span class="nc" id="L488">            LOG.info(&quot;Auditor periodic placement policy check enabled&quot;</span>
<span class="nc" id="L489">                    + &quot; 'auditorPeriodicPlacementPolicyCheckInterval' {} seconds&quot;, interval);</span>

            long placementPolicyCheckLastExecutedCTime;
            long durationSinceLastExecutionInSecs;
            long initialDelay;
            try {
<span class="nc" id="L495">                placementPolicyCheckLastExecutedCTime = ledgerUnderreplicationManager.getPlacementPolicyCheckCTime();</span>
<span class="nc" id="L496">            } catch (ReplicationException.NonRecoverableReplicationException nre) {</span>
<span class="nc" id="L497">                LOG.error(&quot;Non Recoverable Exception while reading from ZK&quot;, nre);</span>
<span class="nc" id="L498">                submitShutdownTask();</span>
<span class="nc" id="L499">                return;</span>
<span class="nc" id="L500">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L501">                LOG.error(&quot;Got UnavailableException while trying to get placementPolicyCheckCTime&quot;, ue);</span>
<span class="nc" id="L502">                placementPolicyCheckLastExecutedCTime = -1;</span>
<span class="nc" id="L503">            }</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (placementPolicyCheckLastExecutedCTime == -1) {</span>
<span class="nc" id="L505">                durationSinceLastExecutionInSecs = -1;</span>
<span class="nc" id="L506">                initialDelay = 0;</span>
            } else {
<span class="nc" id="L508">                durationSinceLastExecutionInSecs = (System.currentTimeMillis() - placementPolicyCheckLastExecutedCTime)</span>
                        / 1000;
<span class="nc bnc" id="L510" title="All 2 branches missed.">                if (durationSinceLastExecutionInSecs &lt; 0) {</span>
                    // this can happen if there is no strict time ordering
<span class="nc" id="L512">                    durationSinceLastExecutionInSecs = 0;</span>
                }
<span class="nc bnc" id="L514" title="All 2 branches missed.">                initialDelay = durationSinceLastExecutionInSecs &gt; interval ? 0</span>
<span class="nc" id="L515">                        : (interval - durationSinceLastExecutionInSecs);</span>
            }
<span class="nc" id="L517">            LOG.info(</span>
                    &quot;placementPolicyCheck scheduling info.  placementPolicyCheckLastExecutedCTime: {} &quot;
                            + &quot;durationSinceLastExecutionInSecs: {} initialDelay: {} interval: {}&quot;,
<span class="nc" id="L520">                    placementPolicyCheckLastExecutedCTime, durationSinceLastExecutionInSecs, initialDelay, interval);</span>

<span class="nc" id="L522">            executor.scheduleAtFixedRate(auditorPlacementPolicyCheckTask, initialDelay, interval, TimeUnit.SECONDS);</span>
<span class="nc" id="L523">        } else {</span>
<span class="nc" id="L524">            LOG.info(&quot;Periodic placementPolicy check disabled&quot;);</span>
        }
<span class="nc" id="L526">    }</span>

    private void scheduleReplicasCheckTask() {
<span class="nc" id="L529">        long interval = conf.getAuditorPeriodicReplicasCheckInterval();</span>

<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (interval &lt;= 0) {</span>
<span class="nc" id="L532">            LOG.info(&quot;Periodic replicas check disabled&quot;);</span>
<span class="nc" id="L533">            return;</span>
        }

<span class="nc" id="L536">        LOG.info(&quot;Auditor periodic replicas check enabled&quot; + &quot; 'auditorReplicasCheckInterval' {} seconds&quot;, interval);</span>
        long replicasCheckLastExecutedCTime;
        long durationSinceLastExecutionInSecs;
        long initialDelay;
        try {
<span class="nc" id="L541">            replicasCheckLastExecutedCTime = ledgerUnderreplicationManager.getReplicasCheckCTime();</span>
<span class="nc" id="L542">        } catch (ReplicationException.NonRecoverableReplicationException nre) {</span>
<span class="nc" id="L543">            LOG.error(&quot;Non Recoverable Exception while reading from ZK&quot;, nre);</span>
<span class="nc" id="L544">            submitShutdownTask();</span>
<span class="nc" id="L545">            return;</span>
<span class="nc" id="L546">        } catch (UnavailableException ue) {</span>
<span class="nc" id="L547">            LOG.error(&quot;Got UnavailableException while trying to get replicasCheckCTime&quot;, ue);</span>
<span class="nc" id="L548">            replicasCheckLastExecutedCTime = -1;</span>
<span class="nc" id="L549">        }</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (replicasCheckLastExecutedCTime == -1) {</span>
<span class="nc" id="L551">            durationSinceLastExecutionInSecs = -1;</span>
<span class="nc" id="L552">            initialDelay = 0;</span>
        } else {
<span class="nc" id="L554">            durationSinceLastExecutionInSecs = (System.currentTimeMillis() - replicasCheckLastExecutedCTime) / 1000;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (durationSinceLastExecutionInSecs &lt; 0) {</span>
                // this can happen if there is no strict time ordering
<span class="nc" id="L557">                durationSinceLastExecutionInSecs = 0;</span>
            }
<span class="nc bnc" id="L559" title="All 2 branches missed.">            initialDelay = durationSinceLastExecutionInSecs &gt; interval ? 0</span>
<span class="nc" id="L560">                    : (interval - durationSinceLastExecutionInSecs);</span>
        }
<span class="nc" id="L562">        LOG.info(</span>
                &quot;replicasCheck scheduling info. replicasCheckLastExecutedCTime: {} &quot;
                        + &quot;durationSinceLastExecutionInSecs: {} initialDelay: {} interval: {}&quot;,
<span class="nc" id="L565">                replicasCheckLastExecutedCTime, durationSinceLastExecutionInSecs, initialDelay, interval);</span>

<span class="nc" id="L567">        executor.scheduleAtFixedRate(auditorReplicasCheckTask, initialDelay, interval, TimeUnit.SECONDS);</span>
<span class="nc" id="L568">    }</span>

<span class="nc" id="L570">    private class UnderReplicatedLedgersChangedCb implements GenericCallback&lt;Void&gt; {</span>
        @Override
        public void operationComplete(int rc, Void result) {
<span class="nc" id="L573">            Iterator&lt;UnderreplicatedLedger&gt; underreplicatedLedgersInfo = ledgerUnderreplicationManager</span>
<span class="nc" id="L574">                    .listLedgersToRereplicate(null);</span>
<span class="nc" id="L575">            auditorStats.getUnderReplicatedLedgersGuageValue().set(Iterators.size(underreplicatedLedgersInfo));</span>
<span class="nc" id="L576">            auditorStats.getNumReplicatedLedgers().inc();</span>
<span class="nc" id="L577">        }</span>
    }

<span class="nc" id="L580">    private class LostBookieRecoveryDelayChangedCb implements GenericCallback&lt;Void&gt; {</span>
        @Override
        public void operationComplete(int rc, Void result) {
            try {
<span class="nc" id="L584">                Auditor.this.ledgerUnderreplicationManager</span>
<span class="nc" id="L585">                        .notifyLostBookieRecoveryDelayChanged(LostBookieRecoveryDelayChangedCb.this);</span>
<span class="nc" id="L586">            } catch (ReplicationException.NonRecoverableReplicationException nre) {</span>
<span class="nc" id="L587">                LOG.error(&quot;Non Recoverable Exception while reading from ZK&quot;, nre);</span>
<span class="nc" id="L588">                submitShutdownTask();</span>
<span class="nc" id="L589">            } catch (UnavailableException ae) {</span>
<span class="nc" id="L590">                LOG.error(&quot;Exception while registering for a LostBookieRecoveryDelay notification&quot;, ae);</span>
<span class="nc" id="L591">            }</span>
<span class="nc" id="L592">            Auditor.this.submitLostBookieRecoveryDelayChangedEvent();</span>
<span class="nc" id="L593">        }</span>
    }

    private void waitIfLedgerReplicationDisabled() throws UnavailableException,
            InterruptedException {
<span class="nc" id="L598">        ReplicationEnableCb cb = new ReplicationEnableCb();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {</span>
<span class="nc" id="L600">            LOG.info(&quot;LedgerReplication is disabled externally through Zookeeper, &quot;</span>
                    + &quot;since DISABLE_NODE ZNode is created, so waiting untill it is enabled&quot;);
<span class="nc" id="L602">            ledgerUnderreplicationManager.notifyLedgerReplicationEnabled(cb);</span>
<span class="nc" id="L603">            cb.await();</span>
        }
<span class="nc" id="L605">    }</span>

    protected List&lt;String&gt; getAvailableBookies() throws BKException {
        // Get the available bookies
<span class="nc" id="L609">        Collection&lt;BookieId&gt; availableBkAddresses = admin.getAvailableBookies();</span>
<span class="nc" id="L610">        Collection&lt;BookieId&gt; readOnlyBkAddresses = admin.getReadOnlyBookies();</span>
<span class="nc" id="L611">        availableBkAddresses.addAll(readOnlyBkAddresses);</span>

<span class="nc" id="L613">        List&lt;String&gt; availableBookies = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        for (BookieId addr : availableBkAddresses) {</span>
<span class="nc" id="L615">            availableBookies.add(addr.toString());</span>
<span class="nc" id="L616">        }</span>
<span class="nc" id="L617">        return availableBookies;</span>
    }

    private void watchBookieChanges() throws BKException {
<span class="nc" id="L621">        admin.watchWritableBookiesChanged(bookies -&gt; submitAuditTask());</span>
<span class="nc" id="L622">        admin.watchReadOnlyBookiesChanged(bookies -&gt; submitAuditTask());</span>
<span class="nc" id="L623">    }</span>

    /**
     * Shutdown the auditor.
     */
    public void shutdown() {
<span class="nc" id="L629">        LOG.info(&quot;Shutting down auditor&quot;);</span>
<span class="nc" id="L630">        executor.shutdown();</span>
        try {
<span class="nc bnc" id="L632" title="All 2 branches missed.">            while (!executor.awaitTermination(30, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L633">                LOG.warn(&quot;Executor not shutting down, interrupting&quot;);</span>
<span class="nc" id="L634">                executor.shutdownNow();</span>
            }

            // shutdown all auditorTasks to clean some resource
<span class="nc" id="L638">            allAuditorTasks.forEach(AuditorTask::shutdown);</span>
<span class="nc" id="L639">            allAuditorTasks.clear();</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (ownAdmin) {</span>
<span class="nc" id="L642">                admin.close();</span>
            }
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (ownBkc) {</span>
<span class="nc" id="L645">                bkc.close();</span>
            }
<span class="nc" id="L647">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L648">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L649">            LOG.warn(&quot;Interrupted while shutting down auditor bookie&quot;, ie);</span>
<span class="nc" id="L650">        } catch (BKException bke) {</span>
<span class="nc" id="L651">            LOG.warn(&quot;Exception while shutting down auditor bookie&quot;, bke);</span>
<span class="nc" id="L652">        }</span>
<span class="nc" id="L653">    }</span>

    @Override
    public void close() {
<span class="nc" id="L657">        shutdown();</span>
<span class="nc" id="L658">    }</span>

    /**
     * Return true if auditor is running otherwise return false.
     *
     * @return auditor status
     */
    public boolean isRunning() {
<span class="nc bnc" id="L666" title="All 2 branches missed.">        return !executor.isShutdown();</span>
    }

    int getLostBookieRecoveryDelayBeforeChange() {
<span class="nc" id="L670">        return lostBookieRecoveryDelayBeforeChange;</span>
    }

    Future&lt;?&gt; getAuditTask() {
<span class="nc" id="L674">        return auditTask;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>