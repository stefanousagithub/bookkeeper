<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RackawareEnsemblePlacementPolicyImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">RackawareEnsemblePlacementPolicyImpl.java</span></div><h1>RackawareEnsemblePlacementPolicyImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_JOINED;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_LEFT;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT;
import static org.apache.bookkeeper.client.BookKeeperClientStats.CLIENT_SCOPE;
import static org.apache.bookkeeper.client.BookKeeperClientStats.NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK;
import static org.apache.bookkeeper.client.BookKeeperClientStats.READ_REQUESTS_REORDERED;
import static org.apache.bookkeeper.client.RegionAwareEnsemblePlacementPolicy.UNKNOWN_REGION;

import com.beust.jcommander.internal.Lists;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import io.netty.util.HashedWheelTimer;
import java.io.IOException;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;
import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;
import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.conf.Configurable;
import org.apache.bookkeeper.feature.FeatureProvider;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.net.BookieNode;
import org.apache.bookkeeper.net.DNSToSwitchMapping;
import org.apache.bookkeeper.net.NetworkTopology;
import org.apache.bookkeeper.net.NetworkTopologyImpl;
import org.apache.bookkeeper.net.Node;
import org.apache.bookkeeper.net.NodeBase;
import org.apache.bookkeeper.net.ScriptBasedMapping;
import org.apache.bookkeeper.net.StabilizeNetworkTopology;
import org.apache.bookkeeper.proto.BookieAddressResolver;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Simple rackware ensemble placement policy.
 *
 * &lt;p&gt;Make most of the class and methods as protected, so it could be extended to implement other algorithms.
 */
@StatsDoc(
    name = CLIENT_SCOPE,
    help = &quot;BookKeeper client stats&quot;
)
public class RackawareEnsemblePlacementPolicyImpl extends TopologyAwareEnsemblePlacementPolicy {

<span class="nc" id="L87">    static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicyImpl.class);</span>
    int maxWeightMultiple;

    protected int minNumRacksPerWriteQuorum;
    protected boolean enforceMinNumRacksPerWriteQuorum;
    protected boolean ignoreLocalNodeInPlacementPolicy;

    public static final String REPP_RANDOM_READ_REORDERING = &quot;ensembleRandomReadReordering&quot;;

    static final int RACKNAME_DISTANCE_FROM_LEAVES = 1;

    // masks for reordering
    static final int LOCAL_MASK       = 0x01 &lt;&lt; 24;
    static final int LOCAL_FAIL_MASK  = 0x02 &lt;&lt; 24;
    static final int REMOTE_MASK      = 0x04 &lt;&lt; 24;
    static final int REMOTE_FAIL_MASK = 0x08 &lt;&lt; 24;
    static final int READ_ONLY_MASK   = 0x10 &lt;&lt; 24;
    static final int SLOW_MASK        = 0x20 &lt;&lt; 24;
    static final int UNAVAIL_MASK     = 0x40 &lt;&lt; 24;
    static final int MASK_BITS        = 0xFFF &lt;&lt; 20;

    protected HashedWheelTimer timer;
    // Use a loading cache so slow bookies are expired. Use entryId as values.
    protected Cache&lt;BookieId, Long&gt; slowBookies;
    protected BookieNode localNode;
<span class="nc" id="L112">    protected boolean reorderReadsRandom = false;</span>
<span class="nc" id="L113">    protected boolean enforceDurability = false;</span>
<span class="nc" id="L114">    protected int stabilizePeriodSeconds = 0;</span>
<span class="nc" id="L115">    protected int reorderThresholdPendingRequests = 0;</span>
    // looks like these only assigned in the same thread as constructor, immediately after constructor;
    // no need to make volatile
<span class="nc" id="L118">    protected StatsLogger statsLogger = null;</span>

<span class="nc" id="L120">    @StatsDoc(</span>
            name = READ_REQUESTS_REORDERED,
            help = &quot;The distribution of number of bookies reordered on each read request&quot;
    )
    protected OpStatsLogger readReorderedCounter = null;
<span class="nc" id="L125">    @StatsDoc(</span>
            name = FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT,
            help = &quot;Counter for number of times DNSResolverDecorator failed to resolve Network Location&quot;
    )
    protected Counter failedToResolveNetworkLocationCounter = null;
    @StatsDoc(
            name = NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK,
            help = &quot;Gauge for the number of writable Bookies in default rack&quot;
    )
    protected Gauge&lt;Integer&gt; numWritableBookiesInDefaultRack;

<span class="nc" id="L136">    private String defaultRack = NetworkTopology.DEFAULT_RACK;</span>

    RackawareEnsemblePlacementPolicyImpl() {
<span class="nc" id="L139">        this(false);</span>
<span class="nc" id="L140">    }</span>

<span class="nc" id="L142">    RackawareEnsemblePlacementPolicyImpl(boolean enforceDurability) {</span>
<span class="nc" id="L143">        this.enforceDurability = enforceDurability;</span>
<span class="nc" id="L144">        topology = new NetworkTopologyImpl();</span>
<span class="nc" id="L145">    }</span>

    /**
     * Initialize the policy.
     *
     * @param dnsResolver the object used to resolve addresses to their network address
     * @return initialized ensemble placement policy
     */
    protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dnsResolver,
                                                              HashedWheelTimer timer,
                                                              boolean reorderReadsRandom,
                                                              int stabilizePeriodSeconds,
                                                              int reorderThresholdPendingRequests,
                                                              boolean isWeighted,
                                                              int maxWeightMultiple,
                                                              int minNumRacksPerWriteQuorum,
                                                              boolean enforceMinNumRacksPerWriteQuorum,
                                                              boolean ignoreLocalNodeInPlacementPolicy,
                                                              StatsLogger statsLogger,
                                                              BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L165">        checkNotNull(statsLogger, &quot;statsLogger should not be null, use NullStatsLogger instead.&quot;);</span>
<span class="nc" id="L166">        this.statsLogger = statsLogger;</span>
<span class="nc" id="L167">        this.bookieAddressResolver = bookieAddressResolver;</span>
<span class="nc" id="L168">        this.bookiesJoinedCounter = statsLogger.getOpStatsLogger(BOOKIES_JOINED);</span>
<span class="nc" id="L169">        this.bookiesLeftCounter = statsLogger.getOpStatsLogger(BOOKIES_LEFT);</span>
<span class="nc" id="L170">        this.readReorderedCounter = statsLogger.getOpStatsLogger(READ_REQUESTS_REORDERED);</span>
<span class="nc" id="L171">        this.failedToResolveNetworkLocationCounter = statsLogger.getCounter(FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT);</span>
<span class="nc" id="L172">        this.numWritableBookiesInDefaultRack = new Gauge&lt;Integer&gt;() {</span>
            @Override
            public Integer getDefaultValue() {
<span class="nc" id="L175">                return 0;</span>
            }

            @Override
            public Integer getSample() {
<span class="nc" id="L180">                rwLock.readLock().lock();</span>
                try {
<span class="nc" id="L182">                    return topology.countNumOfAvailableNodes(getDefaultRack(), Collections.emptySet());</span>
                } finally {
<span class="nc" id="L184">                    rwLock.readLock().unlock();</span>
                }
            }
        };
<span class="nc" id="L188">        this.statsLogger.registerGauge(NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK, numWritableBookiesInDefaultRack);</span>
<span class="nc" id="L189">        this.reorderReadsRandom = reorderReadsRandom;</span>
<span class="nc" id="L190">        this.stabilizePeriodSeconds = stabilizePeriodSeconds;</span>
<span class="nc" id="L191">        this.reorderThresholdPendingRequests = reorderThresholdPendingRequests;</span>
<span class="nc" id="L192">        this.dnsResolver = new DNSResolverDecorator(dnsResolver, () -&gt; this.getDefaultRack(),</span>
                failedToResolveNetworkLocationCounter);
<span class="nc" id="L194">        this.timer = timer;</span>
<span class="nc" id="L195">        this.minNumRacksPerWriteQuorum = minNumRacksPerWriteQuorum;</span>
<span class="nc" id="L196">        this.enforceMinNumRacksPerWriteQuorum = enforceMinNumRacksPerWriteQuorum;</span>
<span class="nc" id="L197">        this.ignoreLocalNodeInPlacementPolicy = ignoreLocalNodeInPlacementPolicy;</span>

        // create the network topology
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (stabilizePeriodSeconds &gt; 0) {</span>
<span class="nc" id="L201">            this.topology = new StabilizeNetworkTopology(timer, stabilizePeriodSeconds);</span>
        } else {
<span class="nc" id="L203">            this.topology = new NetworkTopologyImpl();</span>
        }

<span class="nc" id="L206">        BookieNode bn = null;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (!ignoreLocalNodeInPlacementPolicy) {</span>
            try {
<span class="nc" id="L209">                bn = createDummyLocalBookieNode(InetAddress.getLocalHost().getHostAddress());</span>
<span class="nc" id="L210">            } catch (IOException e) {</span>
<span class="nc" id="L211">                LOG.error(&quot;Failed to get local host address : &quot;, e);</span>
<span class="nc" id="L212">            }</span>
        } else {
<span class="nc" id="L214">            LOG.info(&quot;Ignoring LocalNode in Placementpolicy&quot;);</span>
        }
<span class="nc" id="L216">        localNode = bn;</span>
<span class="nc" id="L217">        LOG.info(&quot;Initialize rackaware ensemble placement policy @ {} @ {} : {}.&quot;,</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                localNode, null == localNode ? &quot;Unknown&quot; : localNode.getNetworkLocation(),</span>
<span class="nc" id="L219">                dnsResolver.getClass().getName());</span>

<span class="nc" id="L221">        this.isWeighted = isWeighted;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (this.isWeighted) {</span>
<span class="nc" id="L223">            this.maxWeightMultiple = maxWeightMultiple;</span>
<span class="nc" id="L224">            this.weightedSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
<span class="nc" id="L225">            LOG.info(&quot;Weight based placement with max multiple of &quot; + this.maxWeightMultiple);</span>
        } else {
<span class="nc" id="L227">            LOG.info(&quot;Not weighted&quot;);</span>
        }
<span class="nc" id="L229">        return this;</span>
    }

    /*
     * sets default rack for the policy.
     * i.e. region-aware policy may want to have /region/rack while regular
     * rack-aware policy needs /rack only since we cannot mix both styles
     */
    public RackawareEnsemblePlacementPolicyImpl withDefaultRack(String rack) {
<span class="nc" id="L238">        checkNotNull(rack, &quot;Default rack cannot be null&quot;);</span>

<span class="nc" id="L240">        this.defaultRack = rack;</span>
<span class="nc" id="L241">        return this;</span>
    }

    public String getDefaultRack() {
<span class="nc" id="L245">        return defaultRack;</span>
    }

    @Override
    public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,
                                                           Optional&lt;DNSToSwitchMapping&gt; optionalDnsResolver,
                                                           HashedWheelTimer timer,
                                                           FeatureProvider featureProvider,
                                                           StatsLogger statsLogger,
                                                           BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L255">        this.bookieAddressResolver = bookieAddressResolver;</span>
        DNSToSwitchMapping dnsResolver;
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (optionalDnsResolver.isPresent()) {</span>
<span class="nc" id="L258">            dnsResolver = optionalDnsResolver.get();</span>
        } else {
<span class="nc" id="L260">            String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());</span>
            try {
<span class="nc" id="L262">                dnsResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);</span>
<span class="nc" id="L263">                dnsResolver.setBookieAddressResolver(bookieAddressResolver);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if (dnsResolver instanceof Configurable) {</span>
<span class="nc" id="L265">                    ((Configurable) dnsResolver).setConf(conf);</span>
                }

<span class="nc bnc" id="L268" title="All 2 branches missed.">                if (dnsResolver instanceof RackChangeNotifier) {</span>
<span class="nc" id="L269">                    ((RackChangeNotifier) dnsResolver).registerRackChangeListener(this);</span>
                }
<span class="nc" id="L271">            } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                if (!conf.getEnforceMinNumRacksPerWriteQuorum()) {</span>
<span class="nc" id="L273">                    LOG.warn(&quot;Failed to initialize DNS Resolver {}, used default subnet resolver because {}&quot;,</span>
<span class="nc" id="L274">                            dnsResolverName, re.getMessage());</span>
<span class="nc" id="L275">                    dnsResolver = new DefaultResolver(this::getDefaultRack);</span>
<span class="nc" id="L276">                    dnsResolver.setBookieAddressResolver(bookieAddressResolver);</span>
                } else {
                    /*
                     * if minNumRacksPerWriteQuorum is enforced, then it
                     * shouldn't continue in the case of failure to create
                     * dnsResolver.
                     */
<span class="nc" id="L283">                    throw re;</span>
                }
<span class="nc" id="L285">            }</span>
        }
<span class="nc" id="L287">        slowBookies = CacheBuilder.newBuilder()</span>
<span class="nc" id="L288">            .expireAfterWrite(conf.getBookieFailureHistoryExpirationMSec(), TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L289">            .build(new CacheLoader&lt;BookieId, Long&gt;() {</span>
                @Override
                public Long load(BookieId key) throws Exception {
<span class="nc" id="L292">                    return -1L;</span>
                }
            });
<span class="nc" id="L295">        return initialize(</span>
                dnsResolver,
                timer,
<span class="nc" id="L298">                conf.getBoolean(REPP_RANDOM_READ_REORDERING, false),</span>
<span class="nc" id="L299">                conf.getNetworkTopologyStabilizePeriodSeconds(),</span>
<span class="nc" id="L300">                conf.getReorderThresholdPendingRequests(),</span>
<span class="nc" id="L301">                conf.getDiskWeightBasedPlacementEnabled(),</span>
<span class="nc" id="L302">                conf.getBookieMaxWeightMultipleForWeightBasedPlacement(),</span>
<span class="nc" id="L303">                conf.getMinNumRacksPerWriteQuorum(),</span>
<span class="nc" id="L304">                conf.getEnforceMinNumRacksPerWriteQuorum(),</span>
<span class="nc" id="L305">                conf.getIgnoreLocalNodeInPlacementPolicy(),</span>
                statsLogger,
                bookieAddressResolver);
    }

    @Override
    public void uninitalize() {
        // do nothing
<span class="nc" id="L313">    }</span>

    /*
     * this method should be called in readlock scope of 'rwLock'
     */
    protected Set&lt;BookieId&gt; addDefaultRackBookiesIfMinNumRacksIsEnforced(
            Set&lt;BookieId&gt; excludeBookies) {
        Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet;
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (enforceMinNumRacksPerWriteQuorum) {</span>
<span class="nc" id="L322">            Set&lt;BookieId&gt; bookiesInDefaultRack = null;</span>
<span class="nc" id="L323">            Set&lt;Node&gt; defaultRackLeaves = topology.getLeaves(getDefaultRack());</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            for (Node node : defaultRackLeaves) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                if (node instanceof BookieNode) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                    if (bookiesInDefaultRack == null) {</span>
<span class="nc" id="L327">                        bookiesInDefaultRack = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
                    }
<span class="nc" id="L329">                    bookiesInDefaultRack.add(((BookieNode) node).getAddr());</span>
                } else {
<span class="nc" id="L331">                    LOG.error(&quot;found non-BookieNode: {} as leaf of defaultrack: {}&quot;, node, getDefaultRack());</span>
                }
<span class="nc" id="L333">            }</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">            if ((bookiesInDefaultRack == null) || bookiesInDefaultRack.isEmpty()) {</span>
<span class="nc" id="L335">                comprehensiveExclusionBookiesSet = excludeBookies;</span>
            } else {
<span class="nc" id="L337">                comprehensiveExclusionBookiesSet = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
<span class="nc" id="L338">                comprehensiveExclusionBookiesSet.addAll(bookiesInDefaultRack);</span>
<span class="nc" id="L339">                LOG.info(&quot;enforceMinNumRacksPerWriteQuorum is enabled, so Excluding bookies of defaultRack: {}&quot;,</span>
                        bookiesInDefaultRack);
            }
<span class="nc" id="L342">        } else {</span>
<span class="nc" id="L343">            comprehensiveExclusionBookiesSet = excludeBookies;</span>
        }
<span class="nc" id="L345">        return comprehensiveExclusionBookiesSet;</span>
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize, int writeQuorumSize,
            int ackQuorumSize, Map&lt;String, byte[]&gt; customMetadata, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L352">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L354">            Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet = addDefaultRackBookiesIfMinNumRacksIsEnforced(</span>
                    excludeBookies);
<span class="nc" id="L356">            PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsembleResult = newEnsembleInternal(ensembleSize,</span>
                    writeQuorumSize, ackQuorumSize, comprehensiveExclusionBookiesSet, null, null);
<span class="nc" id="L358">            return newEnsembleResult;</span>
        } finally {
<span class="nc" id="L360">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize,
                                                                  int writeQuorumSize,
                                                                  int ackQuorumSize,
                                                                  Set&lt;BookieId&gt; excludeBookies,
                                                                  Ensemble&lt;BookieNode&gt; parentEnsemble,
                                                                  Predicate&lt;BookieNode&gt; parentPredicate)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L372">        return newEnsembleInternal(</span>
                ensembleSize,
                writeQuorumSize,
                ackQuorumSize,
                excludeBookies,
                parentEnsemble,
                parentPredicate);
    }

    protected PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsembleInternal(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieId&gt; excludeBookies,
            Ensemble&lt;BookieNode&gt; parentEnsemble,
            Predicate&lt;BookieNode&gt; parentPredicate) throws BKNotEnoughBookiesException {
<span class="nc" id="L388">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L390">            Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(excludeBookies);</span>
<span class="nc" id="L391">            int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L392">            RRTopologyAwareCoverageEnsemble ensemble =</span>
                    new RRTopologyAwareCoverageEnsemble(
                            ensembleSize,
                            writeQuorumSize,
                            ackQuorumSize,
                            RACKNAME_DISTANCE_FROM_LEAVES,
                            parentEnsemble,
                            parentPredicate,
                            minNumRacksPerWriteQuorumForThisEnsemble);
<span class="nc" id="L401">            BookieNode prevNode = null;</span>
<span class="nc" id="L402">            int numRacks = topology.getNumOfRacks();</span>
            // only one rack, use the random algorithm.
<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (numRacks &lt; 2) {</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">                if (enforceMinNumRacksPerWriteQuorum &amp;&amp; (minNumRacksPerWriteQuorumForThisEnsemble &gt; 1)) {</span>
<span class="nc" id="L406">                    LOG.error(&quot;Only one rack available and minNumRacksPerWriteQuorum is enforced, so giving up&quot;);</span>
<span class="nc" id="L407">                    throw new BKNotEnoughBookiesException();</span>
                }
<span class="nc" id="L409">                List&lt;BookieNode&gt; bns = selectRandom(ensembleSize, excludeNodes, TruePredicate.INSTANCE,</span>
                        ensemble);
<span class="nc" id="L411">                ArrayList&lt;BookieId&gt; addrs = new ArrayList&lt;BookieId&gt;(ensembleSize);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                for (BookieNode bn : bns) {</span>
<span class="nc" id="L413">                    addrs.add(bn.getAddr());</span>
<span class="nc" id="L414">                }</span>
<span class="nc" id="L415">                return PlacementResult.of(addrs, PlacementPolicyAdherence.FAIL);</span>
            }
            //Choose different rack nodes.
<span class="nc" id="L418">            String curRack = null;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            for (int i = 0; i &lt; ensembleSize; i++) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (null == prevNode) {</span>
<span class="nc bnc" id="L421" title="All 4 branches missed.">                    if ((null == localNode) || defaultRack.equals(localNode.getNetworkLocation())) {</span>
<span class="nc" id="L422">                        curRack = NodeBase.ROOT;</span>
                    } else {
<span class="nc" id="L424">                        curRack = localNode.getNetworkLocation();</span>
                    }
                } else {
<span class="nc bnc" id="L427" title="All 2 branches missed.">                    if (!curRack.startsWith(&quot;~&quot;)) {</span>
<span class="nc" id="L428">                        curRack = &quot;~&quot; + prevNode.getNetworkLocation();</span>
                    } else {
<span class="nc" id="L430">                        curRack = curRack + NetworkTopologyImpl.NODE_SEPARATOR + prevNode.getNetworkLocation();</span>
                    }
                }
<span class="nc bnc" id="L433" title="All 2 branches missed.">                boolean firstBookieInTheEnsemble = (null == prevNode);</span>
                try {
<span class="nc" id="L435">                    prevNode = selectRandomFromRack(curRack, excludeNodes, ensemble, ensemble);</span>
<span class="nc" id="L436">                } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                    if (!curRack.equals(NodeBase.ROOT)) {</span>
<span class="nc" id="L438">                        curRack = NodeBase.ROOT;</span>
<span class="nc bnc" id="L439" title="All 4 branches missed.">                        prevNode = selectFromNetworkLocation(curRack, excludeNodes, ensemble, ensemble,</span>
                                !enforceMinNumRacksPerWriteQuorum || firstBookieInTheEnsemble);
                    } else {
<span class="nc" id="L442">                        throw e;</span>
                    }
<span class="nc" id="L444">                }</span>
            }
<span class="nc" id="L446">            List&lt;BookieId&gt; bookieList = ensemble.toList();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (ensembleSize != bookieList.size()) {</span>
<span class="nc" id="L448">                LOG.error(&quot;Not enough {} bookies are available to form an ensemble : {}.&quot;,</span>
<span class="nc" id="L449">                          ensembleSize, bookieList);</span>
<span class="nc" id="L450">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L452">            return PlacementResult.of(bookieList,</span>
<span class="nc" id="L453">                                      isEnsembleAdheringToPlacementPolicy(</span>
                                              bookieList, writeQuorumSize, ackQuorumSize));
        } finally {
<span class="nc" id="L456">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;BookieId&gt; replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,
            Map&lt;String, byte[]&gt; customMetadata, List&lt;BookieId&gt; currentEnsemble,
            BookieId bookieToReplace, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L465">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L467">            excludeBookies = addDefaultRackBookiesIfMinNumRacksIsEnforced(excludeBookies);</span>
<span class="nc" id="L468">            excludeBookies.addAll(currentEnsemble);</span>
<span class="nc" id="L469">            BookieNode bn = knownBookies.get(bookieToReplace);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (null == bn) {</span>
<span class="nc" id="L471">                bn = createBookieNode(bookieToReplace);</span>
            }

<span class="nc" id="L474">            Set&lt;Node&gt; ensembleNodes = convertBookiesToNodes(currentEnsemble);</span>
<span class="nc" id="L475">            Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(excludeBookies);</span>

<span class="nc" id="L477">            excludeNodes.addAll(ensembleNodes);</span>
<span class="nc" id="L478">            excludeNodes.add(bn);</span>
<span class="nc" id="L479">            ensembleNodes.remove(bn);</span>

<span class="nc" id="L481">            Set&lt;String&gt; networkLocationsToBeExcluded = getNetworkLocations(ensembleNodes);</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L484">                LOG.debug(&quot;Try to choose a new bookie to replace {} from ensemble {}, excluding {}.&quot;,</span>
                    bookieToReplace, ensembleNodes, excludeNodes);
            }
            // pick a candidate from same rack to replace
<span class="nc" id="L488">            BookieNode candidate = selectFromNetworkLocation(</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                    bn.getNetworkLocation(),</span>
                    networkLocationsToBeExcluded,
                    excludeNodes,
                    TruePredicate.INSTANCE,
                    EnsembleForReplacementWithNoConstraints.INSTANCE,
                    !enforceMinNumRacksPerWriteQuorum);
<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L496">                LOG.debug(&quot;Bookie {} is chosen to replace bookie {}.&quot;, candidate, bn);</span>
            }
<span class="nc" id="L498">            BookieId candidateAddr = candidate.getAddr();</span>
<span class="nc" id="L499">            List&lt;BookieId&gt; newEnsemble = new ArrayList&lt;BookieId&gt;(currentEnsemble);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (currentEnsemble.isEmpty()) {</span>
                /*
                 * in testing code there are test cases which would pass empty
                 * currentEnsemble
                 */
<span class="nc" id="L505">                newEnsemble.add(candidateAddr);</span>
            } else {
<span class="nc" id="L507">                newEnsemble.set(currentEnsemble.indexOf(bookieToReplace), candidateAddr);</span>
            }
<span class="nc" id="L509">            return PlacementResult.of(candidateAddr,</span>
<span class="nc" id="L510">                    isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
        } finally {
<span class="nc" id="L512">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(
            String networkLoc,
            Set&lt;Node&gt; excludeBookies,
            Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble,
            boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // select one from local rack
        try {
<span class="nc" id="L526">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L527">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L529">                LOG.error(</span>
                        &quot;Failed to choose a bookie from {} : &quot;
                                + &quot;excluded {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        networkLoc, excludeBookies);
<span class="nc" id="L533">                throw e;</span>
            }
<span class="nc" id="L535">            LOG.warn(&quot;Failed to choose a bookie from network location {}, &quot;</span>
                    + &quot;the bookies in the network location are {}, excluded bookies {}, &quot;
                    + &quot;current ensemble {}, fallback to choose bookie randomly from the cluster.&quot;,
<span class="nc" id="L538">                     networkLoc, topology.getLeaves(networkLoc), excludeBookies, ensemble);</span>
            // randomly choose one from whole cluster, ignore the provided predicate.
<span class="nc" id="L540">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(String networkLoc,
                                                   Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // first attempt to select one from local rack
        try {
<span class="nc" id="L554">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L555">        } catch (BKNotEnoughBookiesException e) {</span>
            /*
             * there is no enough bookie from local rack, select bookies from
             * the whole cluster and exclude the racks specified at
             * &lt;tt&gt;excludeRacks&lt;/tt&gt;.
             */
<span class="nc" id="L561">            LOG.warn(&quot;Failed to choose a bookie node from network location {}, &quot;</span>
                    + &quot;the bookies in the network location are {}, excluded bookies {}, &quot;
                    + &quot;current ensemble {}, fallback to choose bookie randomly from the cluster.&quot;,
<span class="nc" id="L564">                networkLoc, topology.getLeaves(networkLoc), excludeBookies, ensemble);</span>
<span class="nc" id="L565">            return selectFromNetworkLocation(excludeRacks, excludeBookies, predicate, ensemble, fallbackToRandom);</span>
        }
    }


    /**
     * It randomly selects a {@link BookieNode} that is not on the &lt;i&gt;excludeRacks&lt;/i&gt; set, excluding the nodes in
     * &lt;i&gt;excludeBookies&lt;/i&gt; set. If it fails to find one, it selects a random {@link BookieNode} from the whole
     * cluster.
     */
    @Override
    public BookieNode selectFromNetworkLocation(Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {

<span class="nc" id="L583">        List&lt;BookieNode&gt; knownNodes = new ArrayList&lt;&gt;(knownBookies.values());</span>
<span class="nc" id="L584">        Set&lt;Node&gt; fullExclusionBookiesList = new HashSet&lt;Node&gt;(excludeBookies);</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        for (BookieNode knownNode : knownNodes) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (excludeRacks.contains(knownNode.getNetworkLocation())) {</span>
<span class="nc" id="L587">                fullExclusionBookiesList.add(knownNode);</span>
            }
<span class="nc" id="L589">        }</span>

        try {
<span class="nc" id="L592">            return selectRandomInternal(knownNodes, 1, fullExclusionBookiesList, predicate, ensemble).get(0);</span>
<span class="nc" id="L593">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L595">                LOG.error(</span>
                        &quot;Failed to choose a bookie excluding Racks: {} &quot;
                                + &quot;Nodes: {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        excludeRacks, excludeBookies);
<span class="nc" id="L599">                throw e;</span>
            }

<span class="nc" id="L602">            LOG.warn(&quot;Failed to choose a bookie: excluded {}, fallback to choose bookie randomly from the cluster.&quot;,</span>
                    excludeBookies);
            // randomly choose one from whole cluster
<span class="nc" id="L605">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    private WeightedRandomSelection&lt;BookieNode&gt; prepareForWeightedSelection(List&lt;Node&gt; leaves) {
        // create a map of bookieNode-&gt;freeDiskSpace for this rack. The assumption is that
        // the number of nodes in a rack is of the order of 40, so it shouldn't be too bad
        // to build it every time during a ledger creation
<span class="nc" id="L613">        Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        for (Node n : leaves) {</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (!(n instanceof BookieNode)) {</span>
<span class="nc" id="L616">                continue;</span>
            }
<span class="nc" id="L618">            BookieNode bookie = (BookieNode) n;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if (this.bookieInfoMap.containsKey(bookie)) {</span>
<span class="nc" id="L620">                rackMap.put(bookie, this.bookieInfoMap.get(bookie));</span>
            } else {
<span class="nc" id="L622">                rackMap.put(bookie, new BookieInfo());</span>
            }
<span class="nc" id="L624">        }</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        if (rackMap.size() == 0) {</span>
<span class="nc" id="L626">            return null;</span>
        }

<span class="nc" id="L629">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(</span>
                maxWeightMultiple);
<span class="nc" id="L631">        wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L632">        return wRSelection;</span>
    }

    /**
     * Choose random node under a given network path.
     *
     * @param netPath
     *          network path
     * @param excludeBookies
     *          exclude bookies
     * @param predicate
     *          predicate to check whether the target is a good target.
     * @param ensemble
     *          ensemble structure
     * @return chosen bookie.
     */
    protected BookieNode selectRandomFromRack(String netPath, Set&lt;Node&gt; excludeBookies, Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble) throws BKNotEnoughBookiesException {
<span class="nc" id="L650">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="nc" id="L651">        List&lt;Node&gt; leaves = new ArrayList&lt;Node&gt;(topology.getLeaves(netPath));</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (!this.isWeighted) {</span>
<span class="nc" id="L653">            Collections.shuffle(leaves);</span>
        } else {
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (CollectionUtils.subtract(leaves, excludeBookies).size() &lt; 1) {</span>
<span class="nc" id="L656">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L658">            wRSelection = prepareForWeightedSelection(leaves);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L660">                throw new BKNotEnoughBookiesException();</span>
            }
        }

<span class="nc" id="L664">        Iterator&lt;Node&gt; it = leaves.iterator();</span>
<span class="nc" id="L665">        Set&lt;Node&gt; bookiesSeenSoFar = new HashSet&lt;Node&gt;();</span>
        while (true) {
            Node n;
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == leaves.size()) {</span>
                    // Don't loop infinitely.
<span class="nc" id="L671">                    break;</span>
                }
<span class="nc" id="L673">                n = wRSelection.getNextRandom();</span>
<span class="nc" id="L674">                bookiesSeenSoFar.add(n);</span>
            } else {
<span class="nc bnc" id="L676" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L677">                    n = it.next();</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L683">                continue;</span>
            }
<span class="nc bnc" id="L685" title="All 4 branches missed.">            if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {</span>
<span class="nc" id="L686">                continue;</span>
            }
<span class="nc" id="L688">            BookieNode bn = (BookieNode) n;</span>
            // got a good candidate
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (ensemble.addNode(bn)) {</span>
                // add the candidate to exclude set
<span class="nc" id="L692">                excludeBookies.add(bn);</span>
            }
<span class="nc" id="L694">            return bn;</span>
        }
<span class="nc" id="L696">        throw new BKNotEnoughBookiesException();</span>
    }

    /**
     * Choose a random node from whole cluster.
     *
     * @param numBookies
     *          number bookies to choose
     * @param excludeBookies
     *          bookies set to exclude.
     * @param ensemble
     *          ensemble to hold the bookie chosen.
     * @return the bookie node chosen.
     * @throws BKNotEnoughBookiesException
     */
    protected List&lt;BookieNode&gt; selectRandom(int numBookies,
                                            Set&lt;Node&gt; excludeBookies,
                                            Predicate&lt;BookieNode&gt; predicate,
                                            Ensemble&lt;BookieNode&gt; ensemble)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L716">        return selectRandomInternal(null,  numBookies, excludeBookies, predicate, ensemble);</span>
    }

    protected List&lt;BookieNode&gt; selectRandomInternal(List&lt;BookieNode&gt; bookiesToSelectFrom,
                                                    int numBookies,
                                                    Set&lt;Node&gt; excludeBookies,
                                                    Predicate&lt;BookieNode&gt; predicate,
                                                    Ensemble&lt;BookieNode&gt; ensemble)
        throws BKNotEnoughBookiesException {
<span class="nc" id="L725">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (bookiesToSelectFrom == null) {</span>
            // If the list is null, we need to select from the entire knownBookies set
<span class="nc" id="L728">            wRSelection = this.weightedSelection;</span>
<span class="nc" id="L729">            bookiesToSelectFrom = new ArrayList&lt;BookieNode&gt;(knownBookies.values());</span>
        }
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (isWeighted) {</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (CollectionUtils.subtract(bookiesToSelectFrom, excludeBookies).size() &lt; numBookies) {</span>
<span class="nc" id="L733">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc bnc" id="L735" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L736">                wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
            }

<span class="nc" id="L739">            Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">            for (BookieNode n : bookiesToSelectFrom) {</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L742">                    continue;</span>
                }
<span class="nc bnc" id="L744" title="All 2 branches missed.">                if (this.bookieInfoMap.containsKey(n)) {</span>
<span class="nc" id="L745">                    rackMap.put(n, this.bookieInfoMap.get(n));</span>
                } else {
<span class="nc" id="L747">                    rackMap.put(n, new BookieInfo());</span>
                }
<span class="nc" id="L749">            }</span>
<span class="nc" id="L750">            wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L751">        } else {</span>
<span class="nc" id="L752">            Collections.shuffle(bookiesToSelectFrom);</span>
        }

        BookieNode bookie;
<span class="nc" id="L756">        List&lt;BookieNode&gt; newBookies = new ArrayList&lt;BookieNode&gt;(numBookies);</span>
<span class="nc" id="L757">        Iterator&lt;BookieNode&gt; it = bookiesToSelectFrom.iterator();</span>
<span class="nc" id="L758">        Set&lt;BookieNode&gt; bookiesSeenSoFar = new HashSet&lt;BookieNode&gt;();</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        while (numBookies &gt; 0) {</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == bookiesToSelectFrom.size()) {</span>
                    // If we have gone through the whole available list of bookies,
                    // and yet haven't been able to satisfy the ensemble request, bail out.
                    // We don't want to loop infinitely.
<span class="nc" id="L765">                    break;</span>
                }
<span class="nc" id="L767">                bookie = wRSelection.getNextRandom();</span>
<span class="nc" id="L768">                bookiesSeenSoFar.add(bookie);</span>
            } else {
<span class="nc bnc" id="L770" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L771">                    bookie = it.next();</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (excludeBookies.contains(bookie)) {</span>
<span class="nc" id="L777">                continue;</span>
            }

            // When durability is being enforced; we must not violate the
            // predicate even when selecting a random bookie; as durability
            // guarantee is not best effort; correctness is implied by it
<span class="nc bnc" id="L783" title="All 4 branches missed.">            if (enforceDurability &amp;&amp; !predicate.apply(bookie, ensemble)) {</span>
<span class="nc" id="L784">                continue;</span>
            }

<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (ensemble.addNode(bookie)) {</span>
<span class="nc" id="L788">                excludeBookies.add(bookie);</span>
<span class="nc" id="L789">                newBookies.add(bookie);</span>
<span class="nc" id="L790">                --numBookies;</span>
            }
        }
<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (numBookies == 0) {</span>
<span class="nc" id="L794">            return newBookies;</span>
        }
<span class="nc" id="L796">        LOG.warn(&quot;Failed to find {} bookies : excludeBookies {}, allBookies {}.&quot;,</span>
<span class="nc" id="L797">            numBookies, excludeBookies, bookiesToSelectFrom);</span>

<span class="nc" id="L799">        throw new BKNotEnoughBookiesException();</span>
    }

    @Override
    public void registerSlowBookie(BookieId bookieSocketAddress, long entryId) {
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &lt;= 0) {</span>
            // only put bookies on slowBookies list if reorderThresholdPendingRequests is *not* set (0);
            // otherwise, rely on reordering of reads based on reorderThresholdPendingRequests
<span class="nc" id="L807">            slowBookies.put(bookieSocketAddress, entryId);</span>
        }
<span class="nc" id="L809">    }</span>

    @Override
    public DistributionSchedule.WriteSet reorderReadSequence(
            List&lt;BookieId&gt; ensemble,
            BookiesHealthInfo bookiesHealthInfo,
            DistributionSchedule.WriteSet writeSet) {
<span class="nc" id="L816">        Map&lt;Integer, String&gt; writeSetWithRegion = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L818">            writeSetWithRegion.put(writeSet.get(i), &quot;&quot;);</span>
        }
<span class="nc" id="L820">        return reorderReadSequenceWithRegion(</span>
<span class="nc" id="L821">            ensemble, writeSet, writeSetWithRegion, bookiesHealthInfo, false, &quot;&quot;, writeSet.size());</span>
    }

    /**
     * This function orders the read sequence with a given region. For region-unaware policies (e.g.
     * RackAware), we pass in false for regionAware and an empty myRegion. When this happens, any
     * remote list will stay empty. The ordering is as follows (the R* at the beginning of each list item
     * is only present for region aware policies).
     *      1. available (local) bookies
     *      2. R* a remote bookie (based on remoteNodeInReorderSequence
     *      3. R* remaining (local) bookies
     *      4. R* remaining remote bookies
     *      5. read only bookies
     *      6. slow bookies
     *      7. unavailable bookies
     *
     * @param ensemble
     *          ensemble of bookies
     * @param writeSet
     *          write set
     * @param writeSetWithRegion
     *          write set with region information
     * @param bookiesHealthInfo
     *          heuristics about health of boookies
     * @param regionAware
     *          whether or not a region-aware policy is used
     * @param myRegion
     *          current region of policy
     * @param remoteNodeInReorderSequence
     *          number of local bookies to try before trying a remote bookie
     * @return ordering of bookies to send read to
     */
    DistributionSchedule.WriteSet reorderReadSequenceWithRegion(
        List&lt;BookieId&gt; ensemble,
        DistributionSchedule.WriteSet writeSet,
        Map&lt;Integer, String&gt; writeSetWithRegion,
        BookiesHealthInfo bookiesHealthInfo,
        boolean regionAware,
        String myRegion,
        int remoteNodeInReorderSequence) {
<span class="nc bnc" id="L861" title="All 4 branches missed.">        boolean useRegionAware = regionAware &amp;&amp; (!myRegion.equals(UNKNOWN_REGION));</span>
<span class="nc" id="L862">        int ensembleSize = ensemble.size();</span>

        // For rack aware, If all the bookies in the write set are available, simply return the original write set,
        // to avoid creating more lists
<span class="nc" id="L866">        boolean isAnyBookieUnavailable = false;</span>

<span class="nc bnc" id="L868" title="All 4 branches missed.">        if (useRegionAware || reorderReadsRandom) {</span>
<span class="nc" id="L869">            isAnyBookieUnavailable = true;</span>
        } else {
<span class="nc bnc" id="L871" title="All 2 branches missed.">            for (int i = 0; i &lt; ensemble.size(); i++) {</span>
<span class="nc" id="L872">                BookieId bookieAddr = ensemble.get(i);</span>
<span class="nc bnc" id="L873" title="All 4 branches missed.">                if ((!knownBookies.containsKey(bookieAddr) &amp;&amp; !readOnlyBookies.contains(bookieAddr))</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">                    || slowBookies.getIfPresent(bookieAddr) != null) {</span>
                    // Found at least one bookie not available in the ensemble, or in slowBookies
<span class="nc" id="L876">                    isAnyBookieUnavailable = true;</span>
<span class="nc" id="L877">                    break;</span>
                }
            }
        }

<span class="nc" id="L882">        boolean reordered = false;</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &gt; 0) {</span>
            // if there are no slow or unavailable bookies, capture each bookie's number of
            // pending request to reorder requests based on a threshold of pending requests

            // number of pending requests per bookie (same index as writeSet)
<span class="nc" id="L888">            long[] pendingReqs = new long[writeSet.size()];</span>
<span class="nc" id="L889">            int bestBookieIdx = -1;</span>

<span class="nc bnc" id="L891" title="All 2 branches missed.">            for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L892">                pendingReqs[i] = bookiesHealthInfo.getBookiePendingRequests(ensemble.get(writeSet.get(i)));</span>
<span class="nc bnc" id="L893" title="All 4 branches missed.">                if (bestBookieIdx &lt; 0 || pendingReqs[i] &lt; pendingReqs[bestBookieIdx]) {</span>
<span class="nc" id="L894">                    bestBookieIdx = i;</span>
                }
            }

            // reorder the writeSet if the currently first bookie in our writeSet has at
            // least
            // reorderThresholdPendingRequests more outstanding request than the best bookie
<span class="nc bnc" id="L901" title="All 4 branches missed.">            if (bestBookieIdx &gt; 0 &amp;&amp; pendingReqs[0] &gt;= pendingReqs[bestBookieIdx] + reorderThresholdPendingRequests) {</span>
                // We're not reordering the entire write set, but only move the best bookie
                // to the first place. Chances are good that this bookie will be fast enough
                // to not trigger the speculativeReadTimeout. But even if it hits that timeout,
                // things may have changed by then so much that whichever bookie we put second
                // may actually not be the second-best choice any more.
<span class="nc bnc" id="L907" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L908">                    LOG.debug(&quot;read set reordered from {} ({} pending) to {} ({} pending)&quot;,</span>
<span class="nc" id="L909">                            ensemble.get(writeSet.get(0)), pendingReqs[0], ensemble.get(writeSet.get(bestBookieIdx)),</span>
<span class="nc" id="L910">                            pendingReqs[bestBookieIdx]);</span>
                }
<span class="nc" id="L912">                writeSet.moveAndShift(bestBookieIdx, 0);</span>
<span class="nc" id="L913">                reordered = true;</span>
            }
        }

<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (!isAnyBookieUnavailable) {</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (reordered) {</span>
<span class="nc" id="L919">                readReorderedCounter.registerSuccessfulValue(1);</span>
            }
<span class="nc" id="L921">            return writeSet;</span>
        }

<span class="nc bnc" id="L924" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L925">            int idx = writeSet.get(i);</span>
<span class="nc" id="L926">            BookieId address = ensemble.get(idx);</span>
<span class="nc" id="L927">            String region = writeSetWithRegion.get(idx);</span>
<span class="nc" id="L928">            Long lastFailedEntryOnBookie = bookiesHealthInfo.getBookieFailureHistory(address);</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (null == knownBookies.get(address)) {</span>
                // there isn't too much differences between readonly bookies
                // from unavailable bookies. since there
                // is no write requests to them, so we shouldn't try reading
                // from readonly bookie prior to writable bookies.
<span class="nc bnc" id="L934" title="All 2 branches missed.">                if ((null == readOnlyBookies)</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                    || !readOnlyBookies.contains(address)) {</span>
<span class="nc" id="L936">                    writeSet.set(i, idx | UNAVAIL_MASK);</span>
                } else {
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L939">                        long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
                        // use slow bookies with less pending requests first
<span class="nc" id="L941">                        long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L942">                        writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L943">                    } else {</span>
<span class="nc" id="L944">                        writeSet.set(i, idx | READ_ONLY_MASK);</span>
                    }
                }
<span class="nc bnc" id="L947" title="All 2 branches missed.">            } else if (lastFailedEntryOnBookie &lt; 0) {</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">                if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L949">                    long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
<span class="nc" id="L950">                    long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L951">                    writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L952">                } else {</span>
<span class="nc bnc" id="L953" title="All 4 branches missed.">                    if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L954">                        writeSet.set(i, idx | REMOTE_MASK);</span>
                    } else {
<span class="nc" id="L956">                        writeSet.set(i, idx | LOCAL_MASK);</span>
                    }
                }
            } else {
                // use bookies with earlier failed entryIds first
<span class="nc" id="L961">                long failIdx = lastFailedEntryOnBookie * ensembleSize + idx;</span>
<span class="nc bnc" id="L962" title="All 4 branches missed.">                if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L963">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | REMOTE_FAIL_MASK);</span>
                } else {
<span class="nc" id="L965">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | LOCAL_FAIL_MASK);</span>
                }
            }
        }

        // Add a mask to ensure the sort is stable, sort,
        // and then remove mask. This maintains stability as
        // long as there are fewer than 16 bookies in the write set.
<span class="nc bnc" id="L973" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L974">            writeSet.set(i, writeSet.get(i) | ((i &amp; 0xF) &lt;&lt; 20));</span>
        }
<span class="nc" id="L976">        writeSet.sort();</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L978">            writeSet.set(i, writeSet.get(i) &amp; ~((0xF) &lt;&lt; 20));</span>
        }

<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (reorderReadsRandom) {</span>
<span class="nc" id="L982">            shuffleWithMask(writeSet, LOCAL_MASK, MASK_BITS);</span>
<span class="nc" id="L983">            shuffleWithMask(writeSet, REMOTE_MASK, MASK_BITS);</span>
<span class="nc" id="L984">            shuffleWithMask(writeSet, READ_ONLY_MASK, MASK_BITS);</span>
<span class="nc" id="L985">            shuffleWithMask(writeSet, UNAVAIL_MASK, MASK_BITS);</span>
        }

        // nodes within a region are ordered as follows
        // (Random?) list of nodes that have no history of failure
        // Nodes with Failure history are ordered in the reverse
        // order of the most recent entry that generated an error
        // The sort will have put them in correct order,
        // so remove the bits that sort by age.
<span class="nc bnc" id="L994" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L995">            int mask = writeSet.get(i) &amp; MASK_BITS;</span>
<span class="nc" id="L996">            int idx = (writeSet.get(i) &amp; ~MASK_BITS) % ensembleSize;</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if (mask == LOCAL_FAIL_MASK) {</span>
<span class="nc" id="L998">                writeSet.set(i, LOCAL_MASK | idx);</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">            } else if (mask == REMOTE_FAIL_MASK) {</span>
<span class="nc" id="L1000">                writeSet.set(i, REMOTE_MASK | idx);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            } else if (mask == SLOW_MASK) {</span>
<span class="nc" id="L1002">                writeSet.set(i, SLOW_MASK | idx);</span>
            }
        }

        // Insert a node from the remote region at the specified location so
        // we try more than one region within the max allowed latency
<span class="nc" id="L1008">        int firstRemote = -1;</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            if ((writeSet.get(i) &amp; MASK_BITS) == REMOTE_MASK) {</span>
<span class="nc" id="L1011">                firstRemote = i;</span>
<span class="nc" id="L1012">                break;</span>
            }
        }
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        if (firstRemote != -1) {</span>
<span class="nc" id="L1016">            int i = 0;</span>
            for (; i &lt; remoteNodeInReorderSequence
<span class="nc bnc" id="L1018" title="All 4 branches missed.">                &amp;&amp; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                if ((writeSet.get(i) &amp; MASK_BITS) != LOCAL_MASK) {</span>
<span class="nc" id="L1020">                    break;</span>
                }
            }
<span class="nc" id="L1023">            writeSet.moveAndShift(firstRemote, i);</span>
        }


        // remove all masks
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L1029">            writeSet.set(i, writeSet.get(i) &amp; ~MASK_BITS);</span>
        }
<span class="nc" id="L1031">        readReorderedCounter.registerSuccessfulValue(1);</span>
<span class="nc" id="L1032">        return writeSet;</span>
    }

    // this method should be called in readlock scope of 'rwlock'
    @Override
    public PlacementPolicyAdherence isEnsembleAdheringToPlacementPolicy(List&lt;BookieId&gt; ensembleList,
            int writeQuorumSize, int ackQuorumSize) {
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if (CollectionUtils.isEmpty(ensembleList)) {</span>
<span class="nc" id="L1040">            return PlacementPolicyAdherence.FAIL;</span>
        }
<span class="nc" id="L1042">        int ensembleSize = ensembleList.size();</span>
<span class="nc" id="L1043">        int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1044">        HashSet&lt;String&gt; racksInQuorum = new HashSet&lt;String&gt;();</span>
        BookieId bookie;
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        for (int i = 0; i &lt; ensembleList.size(); i++) {</span>
<span class="nc" id="L1047">            racksInQuorum.clear();</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            for (int j = 0; j &lt; writeQuorumSize; j++) {</span>
<span class="nc" id="L1049">                bookie = ensembleList.get((i + j) % ensembleSize);</span>
                try {
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                    if (knownBookies.containsKey(bookie)) {</span>
<span class="nc" id="L1052">                        racksInQuorum.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                    } else if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1054">                        LOG.debug(&quot;bookie {} is not in the list of knownBookies&quot;, bookie);</span>
                    }
<span class="nc" id="L1056">                } catch (Exception e) {</span>
                    /*
                     * any issue/exception in analyzing whether ensemble is
                     * strictly adhering to placement policy should be
                     * swallowed.
                     */
<span class="nc" id="L1062">                    LOG.warn(&quot;Received exception while trying to get network location of bookie: {}&quot;, bookie, e);</span>
<span class="nc" id="L1063">                }</span>
            }
<span class="nc bnc" id="L1065" title="All 4 branches missed.">            if ((racksInQuorum.size() &lt; minNumRacksPerWriteQuorumForThisEnsemble)</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                    || (enforceMinNumRacksPerWriteQuorum &amp;&amp; racksInQuorum.contains(getDefaultRack()))) {</span>
<span class="nc" id="L1067">                return PlacementPolicyAdherence.FAIL;</span>
            }
        }
<span class="nc" id="L1070">        return PlacementPolicyAdherence.MEETS_STRICT;</span>
    }

    @Override
    public boolean areAckedBookiesAdheringToPlacementPolicy(Set&lt;BookieId&gt; ackedBookies,
                                                            int writeQuorumSize,
                                                            int ackQuorumSize) {
<span class="nc" id="L1077">        HashSet&lt;String&gt; rackCounter = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1078">        int minWriteQuorumNumRacksPerWriteQuorum = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>

<span class="nc" id="L1080">        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();</span>
<span class="nc" id="L1081">        readLock.lock();</span>
        try {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            for (BookieId bookie : ackedBookies) {</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                if (knownBookies.containsKey(bookie)) {</span>
<span class="nc" id="L1085">                    rackCounter.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">                } else if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1087">                    LOG.debug(&quot;bookie {} is not in the list of knownBookies&quot;, bookie);</span>
                }
<span class="nc" id="L1089">            }</span>

            // Check to make sure that ensemble is writing to `minNumberOfRacks`'s number of racks at least.
<span class="nc bnc" id="L1092" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1093">                LOG.debug(&quot;areAckedBookiesAdheringToPlacementPolicy returning {} because number of racks = {} and &quot;</span>
                          + &quot;minNumRacksPerWriteQuorum = {}&quot;,
<span class="nc bnc" id="L1095" title="All 2 branches missed.">                          rackCounter.size() &gt;= minNumRacksPerWriteQuorum,</span>
<span class="nc" id="L1096">                          rackCounter.size(),</span>
<span class="nc" id="L1097">                          minNumRacksPerWriteQuorum);</span>
            }
        } finally {
<span class="nc" id="L1100">            readLock.unlock();</span>
        }
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        return rackCounter.size() &gt;= minWriteQuorumNumRacksPerWriteQuorum;</span>
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; replaceToAdherePlacementPolicy(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieId&gt; excludeBookies,
            List&lt;BookieId&gt; currentEnsemble) {
<span class="nc" id="L1112">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L1114">            PlacementPolicyAdherence currentPlacementAdherence = isEnsembleAdheringToPlacementPolicy(</span>
                    currentEnsemble, writeQuorumSize, ackQuorumSize);
<span class="nc bnc" id="L1116" title="All 2 branches missed.">            if (PlacementPolicyAdherence.FAIL != currentPlacementAdherence) {</span>
<span class="nc" id="L1117">                return PlacementResult.of(new ArrayList&lt;&gt;(currentEnsemble), currentPlacementAdherence);</span>
            }
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            for (BookieId bookieId : currentEnsemble) {</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                if (!knownBookies.containsKey(bookieId)) {</span>
<span class="nc" id="L1121">                    excludeBookies.add(bookieId);</span>
                }
<span class="nc" id="L1123">            }</span>
<span class="nc" id="L1124">            int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1125">            int numRacks = topology.getNumOfRacks();</span>
            // only one rack or less than minNumRacksPerWriteQuorumForThisEnsemble, stop calculation to skip relocation
<span class="nc bnc" id="L1127" title="All 4 branches missed.">            if (numRacks &lt; 2 || numRacks &lt; minNumRacksPerWriteQuorumForThisEnsemble) {</span>
<span class="nc" id="L1128">                LOG.warn(&quot;Skip ensemble relocation because the cluster has only {} rack.&quot;, numRacks);</span>
<span class="nc" id="L1129">                return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
            }
<span class="nc" id="L1131">            PlacementResult&lt;List&lt;BookieId&gt;&gt; placementResult = PlacementResult.of(Collections.emptyList(),</span>
                    PlacementPolicyAdherence.FAIL);
<span class="nc" id="L1133">            int minDiffer = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            for (int i = 0; i &lt; currentEnsemble.size(); i++) {</span>
<span class="nc" id="L1135">                PlacementResult&lt;List&lt;BookieId&gt;&gt; result = doReplaceToAdherePlacementPolicy(ensembleSize,</span>
                        writeQuorumSize, ackQuorumSize, excludeBookies, currentEnsemble, i);
<span class="nc bnc" id="L1137" title="All 2 branches missed.">                if (PlacementPolicyAdherence.FAIL == result.getAdheringToPolicy()) {</span>
<span class="nc" id="L1138">                    continue;</span>
                }
<span class="nc" id="L1140">                int differ = differBetweenBookies(currentEnsemble, result.getResult());</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                if (differ &lt; minDiffer) {</span>
<span class="nc" id="L1142">                    minDiffer = differ;</span>
<span class="nc" id="L1143">                    placementResult = result;</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                    if (minDiffer == 1) {</span>
<span class="nc" id="L1145">                        break;</span>
                    }
                }
            }
<span class="nc" id="L1149">            return placementResult;</span>
        } finally {
<span class="nc" id="L1151">            rwLock.readLock().unlock();</span>
        }
    }

    private PlacementResult&lt;List&lt;BookieId&gt;&gt; doReplaceToAdherePlacementPolicy(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieId&gt; excludeBookies,
            List&lt;BookieId&gt; currentEnsemble,
            int startIndex) {
<span class="nc" id="L1162">        final List&lt;BookieNode&gt; provisionalEnsembleNodes = currentEnsemble.stream()</span>
<span class="nc" id="L1163">                .map(this::convertBookieToNode).collect(Collectors.toList());</span>
<span class="nc" id="L1164">        final Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(</span>
<span class="nc" id="L1165">                addDefaultRackBookiesIfMinNumRacksIsEnforced(excludeBookies));</span>
<span class="nc" id="L1166">        int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1167">        final RRTopologyAwareCoverageEnsemble ensemble =</span>
                new RRTopologyAwareCoverageEnsemble(
                        ensembleSize,
                        writeQuorumSize,
                        ackQuorumSize,
                        RACKNAME_DISTANCE_FROM_LEAVES,
                        null,
                        null,
                        minNumRacksPerWriteQuorumForThisEnsemble);
<span class="nc" id="L1176">        BookieNode prevNode = null;</span>
<span class="nc" id="L1177">        final BookieNode firstNode = provisionalEnsembleNodes.get(startIndex);</span>
        // use same bookie at first to reduce ledger replication
<span class="nc bnc" id="L1179" title="All 4 branches missed.">        if (!excludeNodes.contains(firstNode) &amp;&amp; ensemble.apply(firstNode, ensemble)</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">                &amp;&amp; ensemble.addNode(firstNode)) {</span>
<span class="nc" id="L1181">            excludeNodes.add(firstNode);</span>
<span class="nc" id="L1182">            prevNode = firstNode;</span>
        }
<span class="nc bnc" id="L1184" title="All 4 branches missed.">        for (int i = prevNode == null ? 0 : 1; i &lt; ensembleSize; i++) {</span>
<span class="nc" id="L1185">            int index = (startIndex + i) % ensembleSize;</span>
            final String curRack;
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            if (null == prevNode) {</span>
<span class="nc bnc" id="L1188" title="All 4 branches missed.">                if ((null == localNode) || defaultRack.equals(localNode.getNetworkLocation())) {</span>
<span class="nc" id="L1189">                    curRack = NodeBase.ROOT;</span>
                } else {
<span class="nc" id="L1191">                    curRack = localNode.getNetworkLocation();</span>
                }
            } else {
<span class="nc" id="L1194">                curRack = NetworkTopologyImpl.INVERSE + prevNode.getNetworkLocation();</span>
            }
            try {
<span class="nc" id="L1197">                prevNode = replaceToAdherePlacementPolicyInternal(</span>
                        curRack, excludeNodes, ensemble, ensemble,
                        provisionalEnsembleNodes, index, ensembleSize, minNumRacksPerWriteQuorumForThisEnsemble);
                // got a good candidate
<span class="nc bnc" id="L1201" title="All 2 branches missed.">                if (ensemble.addNode(prevNode)) {</span>
                    // add the candidate to exclude set
<span class="nc" id="L1203">                    excludeNodes.add(prevNode);</span>
                } else {
<span class="nc" id="L1205">                    throw new BKNotEnoughBookiesException();</span>
                }
                // replace to newer node
<span class="nc" id="L1208">                provisionalEnsembleNodes.set(index, prevNode);</span>
<span class="nc" id="L1209">            } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc" id="L1210">                LOG.warn(&quot;Skip ensemble relocation because the cluster has not enough bookies.&quot;);</span>
<span class="nc" id="L1211">                return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
<span class="nc" id="L1212">            }</span>
        }
<span class="nc" id="L1214">        List&lt;BookieId&gt; bookieList = ensemble.toList();</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if (ensembleSize != bookieList.size()) {</span>
<span class="nc" id="L1216">            LOG.warn(&quot;Not enough {} bookies are available to form an ensemble : {}.&quot;,</span>
<span class="nc" id="L1217">                    ensembleSize, bookieList);</span>
<span class="nc" id="L1218">            return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
        }
<span class="nc" id="L1220">        PlacementPolicyAdherence placementPolicyAdherence = isEnsembleAdheringToPlacementPolicy(bookieList,</span>
                writeQuorumSize, ackQuorumSize);
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        if (PlacementPolicyAdherence.FAIL == placementPolicyAdherence) {</span>
<span class="nc" id="L1223">            return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
        }
<span class="nc" id="L1225">        return PlacementResult.of(revertBookieListByIndex(bookieList, startIndex), placementPolicyAdherence);</span>
    }

    private List&lt;BookieId&gt; revertBookieListByIndex(List&lt;BookieId&gt; bookies, int startIndex) {
<span class="nc" id="L1229">        BookieId[] bookieIds = new BookieId[bookies.size()];</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">        for (int i = 0; i &lt; bookies.size(); i++) {</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (startIndex == bookies.size()) {</span>
<span class="nc" id="L1232">                startIndex = 0;</span>
            }
<span class="nc" id="L1234">            bookieIds[startIndex++] = bookies.get(i);</span>
        }
<span class="nc" id="L1236">        return Lists.newArrayList(bookieIds);</span>
    }

    private BookieNode replaceToAdherePlacementPolicyInternal(
            String netPath, Set&lt;Node&gt; excludeBookies, Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble, List&lt;BookieNode&gt; provisionalEnsembleNodes, int ensembleIndex,
            int ensembleSize, int minNumRacksPerWriteQuorumForThisEnsemble) throws BKNotEnoughBookiesException {
<span class="nc" id="L1243">        final BookieNode currentNode = provisionalEnsembleNodes.get(ensembleIndex);</span>
        // if the current bookie could be applied to the ensemble, apply it to minify the number of bookies replaced
<span class="nc bnc" id="L1245" title="All 4 branches missed.">        if (!excludeBookies.contains(currentNode) &amp;&amp; predicate.apply(currentNode, ensemble)) {</span>
<span class="nc" id="L1246">            return currentNode;</span>
        }
<span class="nc" id="L1248">        final List&lt;Pair&lt;String, List&lt;BookieNode&gt;&gt;&gt; conditionList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1249">        final Set&lt;String&gt; preExcludeRacks = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1250">        final Set&lt;String&gt; postExcludeRacks = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">        for (int i = 0; i &lt; minNumRacksPerWriteQuorumForThisEnsemble - 1; i++) {</span>
<span class="nc" id="L1252">            preExcludeRacks.add(provisionalEnsembleNodes.get(Math.floorMod((ensembleIndex - i - 1), ensembleSize))</span>
<span class="nc" id="L1253">                    .getNetworkLocation());</span>
<span class="nc" id="L1254">            postExcludeRacks.add(provisionalEnsembleNodes.get(Math.floorMod((ensembleIndex + i + 1), ensembleSize))</span>
<span class="nc" id="L1255">                    .getNetworkLocation());</span>
        }
        // adhere minNumRacksPerWriteQuorum by preExcludeRacks
        // avoid additional replace from write quorum candidates by preExcludeRacks and postExcludeRacks
        // avoid to use first candidate bookies for election by provisionalEnsembleNodes
<span class="nc" id="L1260">        conditionList.add(Pair.of(</span>
<span class="nc" id="L1261">                NetworkTopologyImpl.INVERSE + String.join(&quot;,&quot;,</span>
<span class="nc" id="L1262">                        Stream.concat(preExcludeRacks.stream(), postExcludeRacks.stream()).collect(Collectors.toSet())),</span>
                provisionalEnsembleNodes
        ));
        // avoid to use same rack between previous index by netPath
        // avoid to use first candidate bookies for election by provisionalEnsembleNodes
<span class="nc" id="L1267">        conditionList.add(Pair.of(netPath, provisionalEnsembleNodes));</span>
        // avoid to use same rack between previous index by netPath
<span class="nc" id="L1269">        conditionList.add(Pair.of(netPath, Collections.emptyList()));</span>

<span class="nc bnc" id="L1271" title="All 2 branches missed.">        for (Pair&lt;String, List&lt;BookieNode&gt;&gt; condition : conditionList) {</span>
<span class="nc" id="L1272">            WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>

<span class="nc" id="L1274">            final List&lt;Node&gt; leaves = new ArrayList&lt;&gt;(topology.getLeaves(condition.getLeft()));</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">            if (!isWeighted) {</span>
<span class="nc" id="L1276">                Collections.shuffle(leaves);</span>
            } else {
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                if (CollectionUtils.subtract(leaves, excludeBookies).size() &lt; 1) {</span>
<span class="nc" id="L1279">                    throw new BKNotEnoughBookiesException();</span>
                }
<span class="nc" id="L1281">                wRSelection = prepareForWeightedSelection(leaves);</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">                if (wRSelection == null) {</span>
<span class="nc" id="L1283">                    throw new BKNotEnoughBookiesException();</span>
                }
            }

<span class="nc" id="L1287">            final Iterator&lt;Node&gt; it = leaves.iterator();</span>
<span class="nc" id="L1288">            final Set&lt;Node&gt; bookiesSeenSoFar = new HashSet&lt;&gt;();</span>
            while (true) {
                Node n;
<span class="nc bnc" id="L1291" title="All 2 branches missed.">                if (isWeighted) {</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">                    if (bookiesSeenSoFar.size() == leaves.size()) {</span>
                        // Don't loop infinitely.
<span class="nc" id="L1294">                        break;</span>
                    }
<span class="nc" id="L1296">                    n = wRSelection.getNextRandom();</span>
<span class="nc" id="L1297">                    bookiesSeenSoFar.add(n);</span>
                } else {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                    if (it.hasNext()) {</span>
<span class="nc" id="L1300">                        n = it.next();</span>
                    } else {
                        break;
                    }
                }
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L1306">                    continue;</span>
                }
<span class="nc bnc" id="L1308" title="All 4 branches missed.">                if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {</span>
<span class="nc" id="L1309">                    continue;</span>
                }
                // additional excludeBookies
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                if (condition.getRight().contains(n)) {</span>
<span class="nc" id="L1313">                    continue;</span>
                }
<span class="nc" id="L1315">                BookieNode bn = (BookieNode) n;</span>
<span class="nc" id="L1316">                return bn;</span>
            }
<span class="nc" id="L1318">        }</span>
<span class="nc" id="L1319">        throw new BKNotEnoughBookiesException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>