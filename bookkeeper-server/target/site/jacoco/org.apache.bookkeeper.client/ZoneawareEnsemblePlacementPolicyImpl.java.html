<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ZoneawareEnsemblePlacementPolicyImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">ZoneawareEnsemblePlacementPolicyImpl.java</span></div><h1>ZoneawareEnsemblePlacementPolicyImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_JOINED;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_LEFT;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT;
import static org.apache.bookkeeper.client.BookKeeperClientStats.NUM_WRITABLE_BOOKIES_IN_DEFAULT_FAULTDOMAIN;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import io.netty.util.HashedWheelTimer;
import java.io.IOException;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.conf.Configurable;
import org.apache.bookkeeper.feature.FeatureProvider;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.net.BookieNode;
import org.apache.bookkeeper.net.DNSToSwitchMapping;
import org.apache.bookkeeper.net.NetworkTopology;
import org.apache.bookkeeper.net.NetworkTopologyImpl;
import org.apache.bookkeeper.net.Node;
import org.apache.bookkeeper.net.NodeBase;
import org.apache.bookkeeper.net.ScriptBasedMapping;
import org.apache.bookkeeper.net.StabilizeNetworkTopology;
import org.apache.bookkeeper.proto.BookieAddressResolver;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Simple zoneaware ensemble placement policy.
 */
public class ZoneawareEnsemblePlacementPolicyImpl extends TopologyAwareEnsemblePlacementPolicy {

<span class="nc" id="L76">    static final Logger LOG = LoggerFactory.getLogger(ZoneawareEnsemblePlacementPolicyImpl.class);</span>

    public static final String UNKNOWN_ZONE = &quot;UnknownZone&quot;;
    /*
     * this defaultFaultDomain is used as placeholder network location for
     * bookies for which network location can't be resolved. In
     * ZoneawareEnsemblePlacementPolicyImpl zone is the fault domain and upgrade
     * domain is logical concept to enable parallel patching by bringing down
     * all the bookies in the upgrade domain.
     */
<span class="nc" id="L86">    private String defaultFaultDomain = NetworkTopology.DEFAULT_ZONE_AND_UPGRADEDOMAIN;</span>
<span class="nc" id="L87">    protected ZoneAwareNodeLocation unresolvedNodeLocation = new ZoneAwareNodeLocation(</span>
            NetworkTopology.DEFAULT_ZONE, NetworkTopology.DEFAULT_UPGRADEDOMAIN);
    private final Random rand;
<span class="nc" id="L90">    protected StatsLogger statsLogger = null;</span>
    // Use a loading cache so slow bookies are expired. Use entryId as values.
    protected Cache&lt;BookieId, Long&gt; slowBookies;
<span class="nc" id="L93">    protected BookieNode myNode = null;</span>
<span class="nc" id="L94">    protected String myZone = null;</span>
<span class="nc" id="L95">    protected boolean reorderReadsRandom = false;</span>
<span class="nc" id="L96">    protected int stabilizePeriodSeconds = 0;</span>
<span class="nc" id="L97">    protected int reorderThresholdPendingRequests = 0;</span>
    protected int maxWeightMultiple;
    protected int minNumZonesPerWriteQuorum;
    protected int desiredNumZonesPerWriteQuorum;
    protected boolean enforceStrictZoneawarePlacement;
    protected HashedWheelTimer timer;
    protected final ConcurrentMap&lt;BookieId, ZoneAwareNodeLocation&gt; address2NodePlacement;

<span class="nc" id="L105">    @StatsDoc(name = FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT, help = &quot;Counter for number of times&quot;</span>
            + &quot; DNSResolverDecorator failed to resolve Network Location&quot;)
    protected Counter failedToResolveNetworkLocationCounter = null;
    @StatsDoc(name = NUM_WRITABLE_BOOKIES_IN_DEFAULT_FAULTDOMAIN, help = &quot;Gauge for the number of writable&quot;
            + &quot; Bookies in default fault domain&quot;)
    protected Gauge&lt;Integer&gt; numWritableBookiesInDefaultFaultDomain;

    /**
     * Zone and UpgradeDomain pair of a node.
     */
    public static class ZoneAwareNodeLocation {
        private final String zone;
        private final String upgradeDomain;
        private final String repString;

<span class="nc" id="L120">        public ZoneAwareNodeLocation(String zone, String upgradeDomain) {</span>
<span class="nc" id="L121">            this.zone = zone;</span>
<span class="nc" id="L122">            this.upgradeDomain = upgradeDomain;</span>
<span class="nc" id="L123">            repString = zone + upgradeDomain;</span>
<span class="nc" id="L124">        }</span>

        public String getZone() {
<span class="nc" id="L127">            return zone;</span>
        }

        public String getUpgradeDomain() {
<span class="nc" id="L131">            return upgradeDomain;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L136">            return repString.hashCode();</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L141" title="All 2 branches missed.">            return ((obj instanceof ZoneAwareNodeLocation)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                    &amp;&amp; repString.equals(((ZoneAwareNodeLocation) obj).repString));</span>
        }
    }


    ZoneawareEnsemblePlacementPolicyImpl() {
<span class="nc" id="L148">        super();</span>
<span class="nc" id="L149">        address2NodePlacement = new ConcurrentHashMap&lt;BookieId, ZoneAwareNodeLocation&gt;();</span>
<span class="nc" id="L150">        rand = new Random(System.currentTimeMillis());</span>
<span class="nc" id="L151">    }</span>

    protected ZoneAwareNodeLocation getZoneAwareNodeLocation(BookieId addr) {
<span class="nc" id="L154">        ZoneAwareNodeLocation nodeLocation = address2NodePlacement.get(addr);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (null == nodeLocation) {</span>
<span class="nc" id="L156">            String networkLocation = resolveNetworkLocation(addr);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (getDefaultFaultDomain().equals(networkLocation)) {</span>
<span class="nc" id="L158">                nodeLocation = unresolvedNodeLocation;</span>
            } else {
<span class="nc" id="L160">                String[] parts = StringUtils.split(NodeBase.normalize(networkLocation), NodeBase.PATH_SEPARATOR);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                if (parts.length != 2) {</span>
<span class="nc" id="L162">                    nodeLocation = unresolvedNodeLocation;</span>
                } else {
<span class="nc" id="L164">                    nodeLocation = new ZoneAwareNodeLocation(NodeBase.PATH_SEPARATOR_STR + parts[0],</span>
                            NodeBase.PATH_SEPARATOR_STR + parts[1]);
                }
            }
<span class="nc" id="L168">            address2NodePlacement.putIfAbsent(addr, nodeLocation);</span>
        }
<span class="nc" id="L170">        return nodeLocation;</span>
    }

    protected ZoneAwareNodeLocation getZoneAwareNodeLocation(BookieNode node) {
<span class="nc bnc" id="L174" title="All 4 branches missed.">        if (null == node || null == node.getAddr()) {</span>
<span class="nc" id="L175">            return unresolvedNodeLocation;</span>
        }
<span class="nc" id="L177">        return getZoneAwareNodeLocation(node.getAddr());</span>
    }

    @Override
    public EnsemblePlacementPolicy initialize(ClientConfiguration conf,
            Optional&lt;DNSToSwitchMapping&gt; optionalDnsResolver, HashedWheelTimer timer, FeatureProvider featureProvider,
            StatsLogger statsLogger, BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L184">        this.statsLogger = statsLogger;</span>
<span class="nc" id="L185">        this.bookieAddressResolver = bookieAddressResolver;</span>
<span class="nc" id="L186">        this.timer = timer;</span>
<span class="nc" id="L187">        this.bookiesJoinedCounter = statsLogger.getOpStatsLogger(BOOKIES_JOINED);</span>
<span class="nc" id="L188">        this.bookiesLeftCounter = statsLogger.getOpStatsLogger(BOOKIES_LEFT);</span>
<span class="nc" id="L189">        this.failedToResolveNetworkLocationCounter = statsLogger.getCounter(FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT);</span>
<span class="nc" id="L190">        this.numWritableBookiesInDefaultFaultDomain = new Gauge&lt;Integer&gt;() {</span>
            @Override
            public Integer getDefaultValue() {
<span class="nc" id="L193">                return 0;</span>
            }

            @Override
            public Integer getSample() {
<span class="nc" id="L198">                rwLock.readLock().lock();</span>
                try {
<span class="nc" id="L200">                    return topology.countNumOfAvailableNodes(getDefaultFaultDomain(), Collections.emptySet());</span>
                } finally {
<span class="nc" id="L202">                    rwLock.readLock().unlock();</span>
                }
            }
        };
<span class="nc" id="L206">        this.statsLogger.registerGauge(NUM_WRITABLE_BOOKIES_IN_DEFAULT_FAULTDOMAIN,</span>
                numWritableBookiesInDefaultFaultDomain);
<span class="nc" id="L208">        this.reorderThresholdPendingRequests = conf.getReorderThresholdPendingRequests();</span>
<span class="nc" id="L209">        this.isWeighted = conf.getDiskWeightBasedPlacementEnabled();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (this.isWeighted) {</span>
<span class="nc" id="L211">            this.maxWeightMultiple = conf.getBookieMaxWeightMultipleForWeightBasedPlacement();</span>
<span class="nc" id="L212">            this.weightedSelection = new DynamicWeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
<span class="nc" id="L213">            LOG.info(&quot;Weight based placement with max multiple of {}&quot;, this.maxWeightMultiple);</span>
        } else {
<span class="nc" id="L215">            LOG.info(&quot;Not weighted&quot;);</span>
        }
<span class="nc" id="L217">        this.minNumZonesPerWriteQuorum = conf.getMinNumZonesPerWriteQuorum();</span>
<span class="nc" id="L218">        this.desiredNumZonesPerWriteQuorum = conf.getDesiredNumZonesPerWriteQuorum();</span>
<span class="nc" id="L219">        this.enforceStrictZoneawarePlacement = conf.getEnforceStrictZoneawarePlacement();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (minNumZonesPerWriteQuorum &gt; desiredNumZonesPerWriteQuorum) {</span>
<span class="nc" id="L221">            LOG.error(</span>
                    &quot;It is misconfigured, for ZoneawareEnsemblePlacementPolicy, minNumZonesPerWriteQuorum: {} cann't be&quot;
                            + &quot; greater than desiredNumZonesPerWriteQuorum: {}&quot;,
<span class="nc" id="L224">                    minNumZonesPerWriteQuorum, desiredNumZonesPerWriteQuorum);</span>
<span class="nc" id="L225">            throw new IllegalArgumentException(&quot;minNumZonesPerWriteQuorum: &quot; + minNumZonesPerWriteQuorum</span>
                    + &quot; cann't be greater than desiredNumZonesPerWriteQuorum: &quot; + desiredNumZonesPerWriteQuorum);
        }
        DNSToSwitchMapping actualDNSResolver;
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (optionalDnsResolver.isPresent()) {</span>
<span class="nc" id="L230">            actualDNSResolver = optionalDnsResolver.get();</span>
        } else {
<span class="nc" id="L232">            String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());</span>
<span class="nc" id="L233">            actualDNSResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);</span>
<span class="nc" id="L234">            actualDNSResolver.setBookieAddressResolver(bookieAddressResolver);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (actualDNSResolver instanceof Configurable) {</span>
<span class="nc" id="L236">                ((Configurable) actualDNSResolver).setConf(conf);</span>
            }
        }

<span class="nc" id="L240">        this.dnsResolver = new DNSResolverDecorator(actualDNSResolver, () -&gt; this.getDefaultFaultDomain(),</span>
                failedToResolveNetworkLocationCounter);
<span class="nc" id="L242">        dnsResolver.setBookieAddressResolver(bookieAddressResolver);</span>
<span class="nc" id="L243">        this.stabilizePeriodSeconds = conf.getNetworkTopologyStabilizePeriodSeconds();</span>
        // create the network topology
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (stabilizePeriodSeconds &gt; 0) {</span>
<span class="nc" id="L246">            this.topology = new StabilizeNetworkTopology(timer, stabilizePeriodSeconds);</span>
        } else {
<span class="nc" id="L248">            this.topology = new NetworkTopologyImpl();</span>
        }
        try {
<span class="nc" id="L251">            myNode = createDummyLocalBookieNode(InetAddress.getLocalHost().getHostAddress());</span>
<span class="nc" id="L252">            myZone = getZoneAwareNodeLocation(myNode).getZone();</span>
<span class="nc" id="L253">        } catch (IOException e) {</span>
<span class="nc" id="L254">            LOG.error(&quot;Failed to get local host address : &quot;, e);</span>
<span class="nc" id="L255">            throw new RuntimeException(e);</span>
<span class="nc" id="L256">        }</span>
<span class="nc" id="L257">        LOG.info(&quot;Initialized zoneaware ensemble placement policy @ {} @ {} : {}.&quot;, myNode,</span>
<span class="nc" id="L258">                myNode.getNetworkLocation(), dnsResolver.getClass().getName());</span>

<span class="nc" id="L260">        slowBookies = CacheBuilder.newBuilder()</span>
<span class="nc" id="L261">                .expireAfterWrite(conf.getBookieFailureHistoryExpirationMSec(), TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L262">                .build(new CacheLoader&lt;BookieId, Long&gt;() {</span>
                    @Override
                    public Long load(BookieId key) throws Exception {
<span class="nc" id="L265">                        return -1L;</span>
                    }
                });
<span class="nc" id="L268">        return this;</span>
    }

    public ZoneawareEnsemblePlacementPolicyImpl withDefaultFaultDomain(String defaultFaultDomain) {
<span class="nc" id="L272">        checkNotNull(defaultFaultDomain, &quot;Default fault domain cannot be null&quot;);</span>

<span class="nc" id="L274">        String[] parts = StringUtils.split(NodeBase.normalize(defaultFaultDomain), NodeBase.PATH_SEPARATOR);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (parts.length != 2) {</span>
<span class="nc" id="L276">            LOG.error(&quot;provided defaultFaultDomain: {} is not valid&quot;, defaultFaultDomain);</span>
<span class="nc" id="L277">            throw new IllegalArgumentException(&quot;invalid defaultFaultDomain&quot;);</span>
        } else {
<span class="nc" id="L279">            unresolvedNodeLocation = new ZoneAwareNodeLocation(NodeBase.PATH_SEPARATOR_STR + parts[0],</span>
                    NodeBase.PATH_SEPARATOR_STR + parts[1]);
        }

<span class="nc" id="L283">        this.defaultFaultDomain = defaultFaultDomain;</span>
<span class="nc" id="L284">        return this;</span>
    }

    public String getDefaultFaultDomain() {
<span class="nc" id="L288">        return defaultFaultDomain;</span>
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize, int writeQuorumSize,
            int ackQuorumSize, Set&lt;BookieId&gt; excludeBookies,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Ensemble&lt;BookieNode&gt; parentEnsemble,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Predicate&lt;BookieNode&gt; parentPredicate)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L297">        throw new UnsupportedOperationException(</span>
                &quot;newEnsemble method with parentEnsemble and parentPredicate is not supported for &quot;
                        + &quot;ZoneawareEnsemblePlacementPolicyImpl&quot;);
    }

    @Override
    public BookieNode selectFromNetworkLocation(String networkLoc, Set&lt;Node&gt; excludeBookies,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Predicate&lt;BookieNode&gt; predicate,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Ensemble&lt;BookieNode&gt; ensemble,
            boolean fallbackToRandom) throws BKNotEnoughBookiesException {
<span class="nc" id="L307">        throw new UnsupportedOperationException(</span>
                &quot;selectFromNetworkLocation is not supported for ZoneawareEnsemblePlacementPolicyImpl&quot;);
    }

    @Override
    public BookieNode selectFromNetworkLocation(Set&lt;String&gt; excludeRacks, Set&lt;Node&gt; excludeBookies,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Predicate&lt;BookieNode&gt; predicate,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Ensemble&lt;BookieNode&gt; ensemble,
            boolean fallbackToRandom) throws BKNotEnoughBookiesException {
<span class="nc" id="L316">        throw new UnsupportedOperationException(</span>
                &quot;selectFromNetworkLocation is not supported for ZoneawareEnsemblePlacementPolicyImpl&quot;);
    }

    @Override
    public BookieNode selectFromNetworkLocation(String networkLoc, Set&lt;String&gt; excludeRacks, Set&lt;Node&gt; excludeBookies,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Predicate&lt;BookieNode&gt; predicate,
            org.apache.bookkeeper.client.ITopologyAwareEnsemblePlacementPolicy.Ensemble&lt;BookieNode&gt; ensemble,
            boolean fallbackToRandom) throws BKNotEnoughBookiesException {
<span class="nc" id="L325">        throw new UnsupportedOperationException(</span>
                &quot;selectFromNetworkLocation is not supported for ZoneawareEnsemblePlacementPolicyImpl&quot;);
    }

    @Override
    public void uninitalize() {
<span class="nc" id="L331">    }</span>

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize, int writeQuorumSize,
            int ackQuorumSize, Map&lt;String, byte[]&gt; customMetadata, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (enforceStrictZoneawarePlacement) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if (ensembleSize % writeQuorumSize != 0) {</span>
                /*
                 * if ensembleSize is not multiple of writeQuorumSize, then the
                 * write quorums which are wrapped will have bookies from just
                 * minNumberOfZones though bookies are available from
                 * desiredNumZones.
                 *
                 * lets say for example - desiredZones = 3, minZones = 2,
                 * ensembleSize = 5, writeQuorumSize = 3, ackQuorumSize = 2
                 *
                 * z1, z2, z3, z1, z2 is a legal ensemble. (lets assume here z1
                 * represents a node belonging to zone z1)
                 *
                 * the writeQuorum for entry 3 will be z1, z2 and z1, since
                 * ackQuorumSize is 2, an entry could be written just to two
                 * bookies that belong to z1. If the zone z1 goes down then the
                 * entry could potentially be unavailable until the zone z1 has
                 * come back.
                 *
                 * Also, it is not ideal to allow combination which fallsback to
                 * minZones, when bookies are available from desiredNumZones.
                 *
                 * So prohibiting this combination of configuration.
                 */
<span class="nc" id="L362">                LOG.error(&quot;It is illegal for ensembleSize to be not multiple of&quot;</span>
                        + &quot; writeQuorumSize When StrictZoneawarePlacement is enabled&quot;);
<span class="nc" id="L364">                throw new IllegalArgumentException(&quot;It is illegal for ensembleSize to be not multiple of&quot;</span>
                        + &quot; writeQuorumSize When StrictZoneawarePlacement is enabled&quot;);
            }
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (writeQuorumSize &lt;= minNumZonesPerWriteQuorum) {</span>
                /*
                 * if we allow writeQuorumSize &lt;= minNumZonesPerWriteQuorum,
                 * then replaceBookie may fail to find a candidate to replace a
                 * node when a zone goes down.
                 *
                 * lets say for example - desiredZones = 3, minZones = 2,
                 * ensembleSize = 6, writeQuorumSize = 2, ackQuorumSize = 2
                 *
                 * z1, z2, z3, z1, z2, z3 is a legal ensemble. (lets assume here
                 * z1 represents a node belonging to zone z1)
                 *
                 * Now if Zone z2 goes down, you need to replace Index 1 and 4.
                 * To replace index 1, you need to find a zone that is not z1
                 * and Z3 which is not possible.
                 *
                 * So prohibiting this combination of configuration.
                 */
<span class="nc" id="L385">                LOG.error(&quot;It is illegal for writeQuorumSize to be lesser than or equal&quot;</span>
                        + &quot; to minNumZonesPerWriteQuorum When StrictZoneawarePlacement is enabled&quot;);
<span class="nc" id="L387">                throw new IllegalArgumentException(&quot;It is illegal for writeQuorumSize to be lesser than or equal&quot;</span>
                        + &quot; to minNumZonesPerWriteQuorum When StrictZoneawarePlacement is enabled&quot;);
            }
        }
<span class="nc" id="L391">        int desiredNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, desiredNumZonesPerWriteQuorum);</span>
<span class="nc" id="L392">        List&lt;BookieId&gt; newEnsemble = new ArrayList&lt;BookieId&gt;(</span>
<span class="nc" id="L393">                Collections.nCopies(ensembleSize, null));</span>
<span class="nc" id="L394">        rwLock.readLock().lock();</span>
        try {
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (!enforceStrictZoneawarePlacement) {</span>
<span class="nc" id="L397">                return createNewEnsembleRandomly(newEnsemble, writeQuorumSize, ackQuorumSize, customMetadata,</span>
                        excludeBookies);
            }
<span class="nc" id="L400">            Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet = addDefaultFaultDomainBookies(excludeBookies);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            for (int index = 0; index &lt; ensembleSize; index++) {</span>
<span class="nc" id="L402">                BookieId selectedBookie = setBookieInTheEnsemble(ensembleSize, writeQuorumSize, newEnsemble,</span>
                        newEnsemble, index, desiredNumZonesPerWriteQuorumForThisEnsemble,
                        comprehensiveExclusionBookiesSet);
<span class="nc" id="L405">                comprehensiveExclusionBookiesSet.add(selectedBookie);</span>
            }
<span class="nc" id="L407">            return PlacementResult.of(newEnsemble,</span>
<span class="nc" id="L408">                    isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
        } finally {
<span class="nc" id="L410">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;BookieId&gt; replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,
            Map&lt;String, byte[]&gt; customMetadata, List&lt;BookieId&gt; currentEnsemble,
            BookieId bookieToReplace, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L419">        int bookieToReplaceIndex = currentEnsemble.indexOf(bookieToReplace);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        int desiredNumZonesPerWriteQuorumForThisEnsemble = (writeQuorumSize &lt; desiredNumZonesPerWriteQuorum)</span>
<span class="nc" id="L421">                ? writeQuorumSize : desiredNumZonesPerWriteQuorum;</span>
<span class="nc" id="L422">        List&lt;BookieId&gt; newEnsemble = new ArrayList&lt;BookieId&gt;(currentEnsemble);</span>
<span class="nc" id="L423">        rwLock.readLock().lock();</span>
        try {
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (!enforceStrictZoneawarePlacement) {</span>
<span class="nc" id="L426">                return selectBookieRandomly(newEnsemble, bookieToReplace, excludeBookies, writeQuorumSize,</span>
                        ackQuorumSize);
            }
<span class="nc" id="L429">            Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet = addDefaultFaultDomainBookies(excludeBookies);</span>
<span class="nc" id="L430">            comprehensiveExclusionBookiesSet.addAll(currentEnsemble);</span>
<span class="nc" id="L431">            BookieId candidateAddr = setBookieInTheEnsemble(ensembleSize, writeQuorumSize, currentEnsemble,</span>
                    newEnsemble, bookieToReplaceIndex, desiredNumZonesPerWriteQuorumForThisEnsemble,
                    comprehensiveExclusionBookiesSet);
<span class="nc" id="L434">            return PlacementResult.of(candidateAddr,</span>
<span class="nc" id="L435">                    isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
        } finally {
<span class="nc" id="L437">            rwLock.readLock().unlock();</span>
        }
    }

    private PlacementResult&lt;List&lt;BookieId&gt;&gt; createNewEnsembleRandomly(List&lt;BookieId&gt; newEnsemble,
            int writeQuorumSize, int ackQuorumSize, Map&lt;String, byte[]&gt; customMetadata,
            Set&lt;BookieId&gt; excludeBookies) throws BKNotEnoughBookiesException {
<span class="nc" id="L444">        int ensembleSize = newEnsemble.size();</span>
<span class="nc" id="L445">        Set&lt;BookieNode&gt; bookiesToConsider = getBookiesToConsider(excludeBookies);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (bookiesToConsider.size() &lt; newEnsemble.size()) {</span>
<span class="nc" id="L447">            LOG.error(&quot;Not enough bookies are available to form ensemble of size: {}&quot;, newEnsemble.size());</span>
<span class="nc" id="L448">            throw new BKNotEnoughBookiesException();</span>
        }

<span class="nc bnc" id="L451" title="All 2 branches missed.">        for (int i = 0; i &lt; ensembleSize; i++) {</span>
<span class="nc" id="L452">            BookieNode candidateNode = selectCandidateNode(bookiesToConsider);</span>
<span class="nc" id="L453">            newEnsemble.set(i, candidateNode.getAddr());</span>
<span class="nc" id="L454">            bookiesToConsider.remove(candidateNode);</span>
        }
<span class="nc" id="L456">        return PlacementResult.of(newEnsemble,</span>
<span class="nc" id="L457">                isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
    }

    private PlacementResult&lt;BookieId&gt; selectBookieRandomly(List&lt;BookieId&gt; newEnsemble,
            BookieId bookieToReplace, Set&lt;BookieId&gt; excludeBookies, int writeQuorumSize,
            int ackQuorumSize) throws BKNotEnoughBookiesException {
<span class="nc" id="L463">        Set&lt;BookieId&gt; bookiesToExcludeIncludingEnsemble = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
<span class="nc" id="L464">        bookiesToExcludeIncludingEnsemble.addAll(newEnsemble);</span>
<span class="nc" id="L465">        Set&lt;BookieNode&gt; bookiesToConsider = getBookiesToConsider(bookiesToExcludeIncludingEnsemble);</span>
<span class="nc" id="L466">        int bookieToReplaceIndex = newEnsemble.indexOf(bookieToReplace);</span>

<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (bookiesToConsider.isEmpty()) {</span>
<span class="nc" id="L469">            LOG.error(&quot;There is no bookie available to replace a bookie&quot;);</span>
<span class="nc" id="L470">            throw new BKNotEnoughBookiesException();</span>
        }
<span class="nc" id="L472">        BookieId candidateAddr = (selectCandidateNode(bookiesToConsider)).getAddr();</span>
<span class="nc" id="L473">        newEnsemble.set(bookieToReplaceIndex, candidateAddr);</span>
<span class="nc" id="L474">        return PlacementResult.of(candidateAddr,</span>
<span class="nc" id="L475">                isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
    }

    private Set&lt;BookieNode&gt; getBookiesToConsider(Set&lt;BookieId&gt; excludeBookies) {
<span class="nc" id="L479">        Set&lt;Node&gt; leaves = topology.getLeaves(NodeBase.ROOT);</span>
<span class="nc" id="L480">        Set&lt;BookieNode&gt; bookiesToConsider = new HashSet&lt;BookieNode&gt;();</span>
        BookieNode bookieNode;
<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (Node leaf : leaves) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (leaf instanceof BookieNode) {</span>
<span class="nc" id="L484">                bookieNode = ((BookieNode) leaf);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                if (excludeBookies.contains(bookieNode.getAddr())) {</span>
<span class="nc" id="L486">                    continue;</span>
                }
<span class="nc" id="L488">                bookiesToConsider.add(bookieNode);</span>
            }
<span class="nc" id="L490">        }</span>
<span class="nc" id="L491">        return bookiesToConsider;</span>
    }

    /*
     * This method finds the appropriate bookie for newEnsemble by finding
     * bookie to replace at bookieToReplaceIndex in the currentEnsemble.
     *
     * It goes through following filtering process 1) Exclude zones of
     * desiredNumZonesPerWriteQuorumForThisEnsemble neighboring nodes 2) Find
     * bookies to consider by excluding zones (found from previous step) and
     * excluding UDs of the zones to consider. 3) If it can't find eligible
     * bookie, then keep reducing the number of neighboring nodes to
     * minNumZonesPerWriteQuorum and repeat step 2. 4) If it still can't find
     * eligible bookies then find the zones to exclude such that in a writeset
     * there will be bookies from atleast minNumZonesPerWriteQuorum zones and
     * repeat step 2 5) After getting the list of eligible candidates select a
     * node randomly. 6) If step-4 couldn't find eligible candidates then throw
     * BKNotEnoughBookiesException.
     *
     * Example: Ensemble:6 Qw:6 desiredNumZonesPerWriteQuorumForThisEnsemble:3
     * minNumZonesPerWriteQuorum:2 The selection process is as follows:
     *
     * 1) Find bookies by excluding zones of
     * (desiredNumZonesPerWriteQuorumForThisEnsemble -1) neighboring bookies on
     * the left and and the right side of the bookieToReplaceIndex. i.e Zones of
     * 2 bookies(3-1) on both sides of the index in question will be excluded to
     * find bookies. 2) Get the set of zones of the bookies selected above. 3)
     * Get the UpgradeDomains to exclude of the each zone selected above to make
     * sure bookies of writeSets containing bookieToReplaceIndex are from
     * different UD if they belong to same zone. 4) now from the zones selected
     * in step 2, apply the filter of UDs to exclude found in previous step and
     * get the eligible bookies. 5) If no bookie matches this filter, then
     * instead of aiming for unique UDs, fallback to UDs to exclude such that if
     * bookies are from same zone in the writeSets containing
     * bookieToReplaceIndex then they must be atleast from 2 different UDs. 6)
     * now from the zones selected in step 2, apply the filter of UDs to exclude
     * found in previous step and get the eligible bookies. 7) If no bookie
     * matches this filter, repeat from Step1 to Step6 by decreasing neighboring
     * exclude zones from (desiredNumZonesPerWriteQuorumForThisEnsemble - 1),
     * which is 2 to (minNumZonesPerWriteQuorum - 1), which is 1 8) If even
     * after this, bookies are not found matching the criteria fallback to
     * minNumZonesPerWriteQuorum, for this find the zones to exclude such that
     * in writesets containing this bookieToReplaceIndex there will be bookies
     * from atleast minNumZonesPerWriteQuorum zones, which is 2. 9) Get the set
     * of the zones of the bookies by excluding zones selected above. 10) repeat
     * Step3 to Step6. 11) After getting the list of eligible candidates select
     * a node randomly. 12) If even after Step10 there are no eligible
     * candidates then throw BKNotEnoughBookiesException.
     */
    private BookieId setBookieInTheEnsemble(int ensembleSize, int writeQuorumSize,
            List&lt;BookieId&gt; currentEnsemble, List&lt;BookieId&gt; newEnsemble, int bookieToReplaceIndex,
            int desiredNumZonesPerWriteQuorumForThisEnsemble, Set&lt;BookieId&gt; excludeBookies)
                    throws BKNotEnoughBookiesException {
<span class="nc" id="L544">        BookieId bookieToReplace = currentEnsemble.get(bookieToReplaceIndex);</span>
<span class="nc" id="L545">        Set&lt;String&gt; zonesToExclude = null;</span>
<span class="nc" id="L546">        Set&lt;BookieNode&gt; bookiesToConsiderAfterExcludingZonesAndUDs = null;</span>
<span class="nc" id="L547">        for (int numberOfNeighborsToConsider = (desiredNumZonesPerWriteQuorumForThisEnsemble</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                - 1); numberOfNeighborsToConsider &gt;= (minNumZonesPerWriteQuorum - 1); numberOfNeighborsToConsider--) {</span>
<span class="nc" id="L549">            zonesToExclude = getZonesOfNeighboringNodesInEnsemble(currentEnsemble, bookieToReplaceIndex,</span>
                    (numberOfNeighborsToConsider));
<span class="nc" id="L551">            bookiesToConsiderAfterExcludingZonesAndUDs = getBookiesToConsiderAfterExcludingZonesAndUDs(ensembleSize,</span>
                    writeQuorumSize, currentEnsemble, bookieToReplaceIndex, excludeBookies, zonesToExclude);
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (!bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) {</span>
<span class="nc" id="L554">                break;</span>
            }
        }
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) {</span>
<span class="nc" id="L558">            zonesToExclude = getZonesToExcludeToMaintainMinZones(currentEnsemble, bookieToReplaceIndex,</span>
                    writeQuorumSize);
<span class="nc" id="L560">            bookiesToConsiderAfterExcludingZonesAndUDs = getBookiesToConsiderAfterExcludingZonesAndUDs(ensembleSize,</span>
                    writeQuorumSize, currentEnsemble, bookieToReplaceIndex, excludeBookies, zonesToExclude);
        }
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) {</span>
<span class="nc" id="L564">            LOG.error(&quot;Not enough bookies are available to replaceBookie : {} in ensemble : {} with excludeBookies {}.&quot;,</span>
                    bookieToReplace, currentEnsemble, excludeBookies);
<span class="nc" id="L566">            throw new BKNotEnoughBookiesException();</span>
        }

<span class="nc" id="L569">        BookieId candidateAddr = selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs).getAddr();</span>
<span class="nc" id="L570">        newEnsemble.set(bookieToReplaceIndex, candidateAddr);</span>
<span class="nc" id="L571">        return candidateAddr;</span>
    }

    /*
     * this method should be called in readlock scope of 'rwLock'. This method
     * returns a new set, by adding excludedBookies and bookies in
     * defaultfaultdomain.
     */
    protected Set&lt;BookieId&gt; addDefaultFaultDomainBookies(Set&lt;BookieId&gt; excludeBookies) {
<span class="nc" id="L580">        Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
<span class="nc" id="L581">        Set&lt;Node&gt; defaultFaultDomainLeaves = topology.getLeaves(getDefaultFaultDomain());</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">        for (Node node : defaultFaultDomainLeaves) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (node instanceof BookieNode) {</span>
<span class="nc" id="L584">                comprehensiveExclusionBookiesSet.add(((BookieNode) node).getAddr());</span>
            } else {
<span class="nc" id="L586">                LOG.error(&quot;found non-BookieNode: {} as leaf of defaultFaultDomain: {}&quot;, node, getDefaultFaultDomain());</span>
            }
<span class="nc" id="L588">        }</span>
<span class="nc" id="L589">        return comprehensiveExclusionBookiesSet;</span>
    }

    /*
     * Select bookie randomly from the bookiesToConsiderAfterExcludingUDs set.
     * If diskWeightBasedPlacement is enabled then it will select node randomly
     * based on node weight.
     */
    private BookieNode selectCandidateNode(Set&lt;BookieNode&gt; bookiesToConsiderAfterExcludingUDs) {
<span class="nc" id="L598">        BookieNode candidate = null;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (!this.isWeighted) {</span>
<span class="nc" id="L600">            int randSelIndex = rand.nextInt(bookiesToConsiderAfterExcludingUDs.size());</span>
<span class="nc" id="L601">            int ind = 0;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            for (BookieNode bookieNode : bookiesToConsiderAfterExcludingUDs) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                if (ind == randSelIndex) {</span>
<span class="nc" id="L604">                    candidate = bookieNode;</span>
<span class="nc" id="L605">                    break;</span>
                }
<span class="nc" id="L607">                ind++;</span>
<span class="nc" id="L608">            }</span>
<span class="nc" id="L609">        } else {</span>
<span class="nc" id="L610">            candidate = weightedSelection.getNextRandom(bookiesToConsiderAfterExcludingUDs);</span>
        }
<span class="nc" id="L612">        return candidate;</span>
    }

    private String getExcludedZonesString(Set&lt;String&gt; excludeZones) {
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (excludeZones.isEmpty()) {</span>
<span class="nc" id="L617">            return &quot;&quot;;</span>
        }
<span class="nc" id="L619">        StringBuilder excludedZonesString = new StringBuilder(NetworkTopologyImpl.INVERSE);</span>
<span class="nc" id="L620">        boolean firstZone = true;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        for (String excludeZone : excludeZones) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (!firstZone) {</span>
<span class="nc" id="L623">                excludedZonesString.append(NetworkTopologyImpl.NODE_SEPARATOR);</span>
            }
<span class="nc" id="L625">            excludedZonesString.append(excludeZone);</span>
<span class="nc" id="L626">            firstZone = false;</span>
<span class="nc" id="L627">        }</span>
<span class="nc" id="L628">        return excludedZonesString.toString();</span>
    }

    private Set&lt;BookieNode&gt; getBookiesToConsider(String excludedZonesString, Set&lt;BookieId&gt; excludeBookies) {
<span class="nc" id="L632">        Set&lt;BookieNode&gt; bookiesToConsider = new HashSet&lt;BookieNode&gt;();</span>
<span class="nc" id="L633">        Set&lt;Node&gt; leaves = topology.getLeaves(excludedZonesString);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        for (Node leaf : leaves) {</span>
<span class="nc" id="L635">            BookieNode bookieNode = ((BookieNode) leaf);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (excludeBookies.contains(bookieNode.getAddr())) {</span>
<span class="nc" id="L637">                continue;</span>
            }
<span class="nc" id="L639">            bookiesToConsider.add(bookieNode);</span>
<span class="nc" id="L640">        }</span>
<span class="nc" id="L641">        return bookiesToConsider;</span>
    }

    /*
     * For the position of 'bookieToReplaceIndex' in currentEnsemble, get the
     * set of bookies eligible by excluding the 'excludeZones' and
     * 'excludeBookies'. After excluding excludeZones and excludeBookies, it
     * would first try to exclude upgrade domains of neighboring nodes
     * (writeset) so the bookie would be from completely new upgrade domain
     * of a zone, if a writeset contains bookie from the zone. If Bookie is
     * not found matching this criteria, then it will fallback to maintain min
     * upgrade domains (two) from a zone, such that if multiple bookies in a
     * write quorum are from the same zone then they will be spread across two
     * upgrade domains.
     */
    private Set&lt;BookieNode&gt; getBookiesToConsiderAfterExcludingZonesAndUDs(int ensembleSize, int writeQuorumSize,
            List&lt;BookieId&gt; currentEnsemble, int bookieToReplaceIndex,
            Set&lt;BookieId&gt; excludeBookies, Set&lt;String&gt; excludeZones) {
<span class="nc" id="L659">        Set&lt;BookieNode&gt; bookiesToConsiderAfterExcludingZonesAndUDs = new HashSet&lt;BookieNode&gt;();</span>
<span class="nc" id="L660">        HashMap&lt;String, Set&lt;String&gt;&gt; excludingUDsOfZonesToConsider = new HashMap&lt;String, Set&lt;String&gt;&gt;();</span>
<span class="nc" id="L661">        Set&lt;BookieNode&gt; bookiesToConsiderAfterExcludingZones = getBookiesToConsider(</span>
<span class="nc" id="L662">                getExcludedZonesString(excludeZones), excludeBookies);</span>

<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (!bookiesToConsiderAfterExcludingZones.isEmpty()) {</span>
<span class="nc" id="L665">            Set&lt;String&gt; zonesToConsider = getZonesOfBookies(bookiesToConsiderAfterExcludingZones);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">            for (String zoneToConsider : zonesToConsider) {</span>
<span class="nc" id="L667">                Set&lt;String&gt; upgradeDomainsOfAZoneInNeighboringNodes = getUpgradeDomainsOfAZoneInNeighboringNodes(</span>
                        currentEnsemble, bookieToReplaceIndex, writeQuorumSize, zoneToConsider);
<span class="nc" id="L669">                excludingUDsOfZonesToConsider.put(zoneToConsider, upgradeDomainsOfAZoneInNeighboringNodes);</span>
<span class="nc" id="L670">            }</span>

<span class="nc" id="L672">            updateBookiesToConsiderAfterExcludingZonesAndUDs(bookiesToConsiderAfterExcludingZonesAndUDs,</span>
                    bookiesToConsiderAfterExcludingZones, excludingUDsOfZonesToConsider);

            /*
             * If no eligible bookie is found, then instead of aiming for unique
             * UDs, fallback to UDs to exclude such that if bookies are from
             * same zone in the writeSets containing bookieToReplaceIndex then
             * they must be atleast from 2 different UDs
             */
<span class="nc bnc" id="L681" title="All 2 branches missed.">            if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) {</span>
<span class="nc" id="L682">                excludingUDsOfZonesToConsider.clear();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">                for (String zoneToConsider : zonesToConsider) {</span>
<span class="nc" id="L684">                    Set&lt;String&gt; udsToExcludeToMaintainMinUDsInWriteQuorums =</span>
<span class="nc" id="L685">                            getUDsToExcludeToMaintainMinUDsInWriteQuorums(currentEnsemble, bookieToReplaceIndex,</span>
                                    writeQuorumSize, zoneToConsider);
<span class="nc" id="L687">                    excludingUDsOfZonesToConsider.put(zoneToConsider, udsToExcludeToMaintainMinUDsInWriteQuorums);</span>
<span class="nc" id="L688">                }</span>

<span class="nc" id="L690">                updateBookiesToConsiderAfterExcludingZonesAndUDs(bookiesToConsiderAfterExcludingZonesAndUDs,</span>
                        bookiesToConsiderAfterExcludingZones, excludingUDsOfZonesToConsider);
            }
        }
<span class="nc" id="L694">        return bookiesToConsiderAfterExcludingZonesAndUDs;</span>
    }

    /*
     * Filter bookies which belong to excludingUDs of zones to consider from
     * 'bookiesToConsider' set and add them to
     * 'bookiesToConsiderAfterExcludingUDs' set.
     */
    private void updateBookiesToConsiderAfterExcludingZonesAndUDs(Set&lt;BookieNode&gt; bookiesToConsiderAfterExcludingUDs,
            Set&lt;BookieNode&gt; bookiesToConsider, HashMap&lt;String, Set&lt;String&gt;&gt; excludingUDsOfZonesToConsider) {
<span class="nc bnc" id="L704" title="All 2 branches missed.">        for (BookieNode bookieToConsider : bookiesToConsider) {</span>
<span class="nc" id="L705">            ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieToConsider);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (excludingUDsOfZonesToConsider.get(nodeLocation.getZone()).contains(nodeLocation.getUpgradeDomain())) {</span>
<span class="nc" id="L707">                continue;</span>
            }
<span class="nc" id="L709">            bookiesToConsiderAfterExcludingUDs.add(bookieToConsider);</span>
<span class="nc" id="L710">        }</span>
<span class="nc" id="L711">    }</span>

    /*
     * Gets the set of zones of neighboring nodes.
     */
    private Set&lt;String&gt; getZonesOfNeighboringNodesInEnsemble(List&lt;BookieId&gt; currentEnsemble, int indexOfNode,
            int numOfNeighboringNodes) {
<span class="nc" id="L718">        Set&lt;String&gt; zonesOfNeighboringNodes = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L719">        int ensembleSize = currentEnsemble.size();</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">        for (int i = (-1 * numOfNeighboringNodes); i &lt;= numOfNeighboringNodes; i++) {</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L722">                continue;</span>
            }
<span class="nc" id="L724">            int index = (indexOfNode + i + ensembleSize) % ensembleSize;</span>
<span class="nc" id="L725">            BookieId addrofNode = currentEnsemble.get(index);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (addrofNode == null) {</span>
<span class="nc" id="L727">                continue;</span>
            }
<span class="nc" id="L729">            String zoneOfNode = getZoneAwareNodeLocation(addrofNode).getZone();</span>
<span class="nc" id="L730">            zonesOfNeighboringNodes.add(zoneOfNode);</span>
        }
<span class="nc" id="L732">        return zonesOfNeighboringNodes;</span>
    }

    /*
     * This method returns set of zones to exclude for the position of
     * 'indexOfNode', so that writequorums, containing this index, would have
     * atleast minNumZonesPerWriteQuorum.
     */
    private Set&lt;String&gt; getZonesToExcludeToMaintainMinZones(List&lt;BookieId&gt; currentEnsemble, int indexOfNode,
            int writeQuorumSize) {
<span class="nc" id="L742">        int ensSize = currentEnsemble.size();</span>
<span class="nc" id="L743">        Set&lt;String&gt; zonesToExclude = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L744">        Set&lt;String&gt; zonesInWriteQuorum = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        for (int i = -(writeQuorumSize - 1); i &lt;= 0; i++) {</span>
<span class="nc" id="L746">            zonesInWriteQuorum.clear();</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            for (int j = 0; j &lt; writeQuorumSize; j++) {</span>
<span class="nc" id="L748">                int indexInEnsemble = (i + j + indexOfNode + ensSize) % ensSize;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (indexInEnsemble == indexOfNode) {</span>
<span class="nc" id="L750">                    continue;</span>
                }
<span class="nc" id="L752">                BookieId bookieAddr = currentEnsemble.get(indexInEnsemble);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if (bookieAddr == null) {</span>
<span class="nc" id="L754">                    continue;</span>
                }
<span class="nc" id="L756">                ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieAddr);</span>
<span class="nc" id="L757">                zonesInWriteQuorum.add(nodeLocation.getZone());</span>
            }
<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (zonesInWriteQuorum.size() &lt;= (minNumZonesPerWriteQuorum - 1)) {</span>
<span class="nc" id="L760">                zonesToExclude.addAll(zonesInWriteQuorum);</span>
            }
        }
<span class="nc" id="L763">        return zonesToExclude;</span>
    }

    private Set&lt;String&gt; getZonesOfBookies(Collection&lt;BookieNode&gt; bookieNodes) {
<span class="nc" id="L767">        Set&lt;String&gt; zonesOfBookies = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">        for (BookieNode bookieNode : bookieNodes) {</span>
<span class="nc" id="L769">            ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieNode);</span>
<span class="nc" id="L770">            zonesOfBookies.add(nodeLocation.getZone());</span>
<span class="nc" id="L771">        }</span>
<span class="nc" id="L772">        return zonesOfBookies;</span>
    }

    /*
     * Gets the set of upgradedomains of neighboring nodes (writeQuorumSize)
     * which belong to this 'zone'.
     */
    private Set&lt;String&gt; getUpgradeDomainsOfAZoneInNeighboringNodes(List&lt;BookieId&gt; currentEnsemble,
            int indexOfNode, int writeQuorumSize, String zone) {
<span class="nc" id="L781">        int ensSize = currentEnsemble.size();</span>
<span class="nc" id="L782">        Set&lt;String&gt; upgradeDomainsOfAZoneInNeighboringNodes = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        for (int i = -(writeQuorumSize - 1); i &lt;= (writeQuorumSize - 1); i++) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L785">                continue;</span>
            }
<span class="nc" id="L787">            int indexInEnsemble = (indexOfNode + i + ensSize) % ensSize;</span>
<span class="nc" id="L788">            BookieId bookieAddr = currentEnsemble.get(indexInEnsemble);</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (bookieAddr == null) {</span>
<span class="nc" id="L790">                continue;</span>
            }
<span class="nc" id="L792">            ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieAddr);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (nodeLocation.getZone().equals(zone)) {</span>
<span class="nc" id="L794">                upgradeDomainsOfAZoneInNeighboringNodes.add(nodeLocation.getUpgradeDomain());</span>
            }
        }
<span class="nc" id="L797">        return upgradeDomainsOfAZoneInNeighboringNodes;</span>
    }

    /*
     * This method returns set of UpgradeDomains to exclude if a bookie from
     * the 'zone' has to be selected for the position of 'indexOfNode', then if
     * there are multiple bookies from the 'zone' in a write quorum then they
     * will be atleast from minimum of two upgrade domains.
     */
    private Set&lt;String&gt; getUDsToExcludeToMaintainMinUDsInWriteQuorums(List&lt;BookieId&gt; currentEnsemble,
            int indexOfNode, int writeQuorumSize, String zone) {
<span class="nc" id="L808">        int ensSize = currentEnsemble.size();</span>
<span class="nc" id="L809">        Set&lt;String&gt; upgradeDomainsToExclude = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L810">        Set&lt;String&gt; upgradeDomainsOfThisZoneInWriteQuorum = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        for (int i = -(writeQuorumSize - 1); i &lt;= 0; i++) {</span>
<span class="nc" id="L812">            upgradeDomainsOfThisZoneInWriteQuorum.clear();</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">            for (int j = 0; j &lt; writeQuorumSize; j++) {</span>
<span class="nc" id="L814">                int indexInEnsemble = (i + j + indexOfNode + ensSize) % ensSize;</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                if (indexInEnsemble == indexOfNode) {</span>
<span class="nc" id="L816">                    continue;</span>
                }
<span class="nc" id="L818">                BookieId bookieAddr = currentEnsemble.get(indexInEnsemble);</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">                if (bookieAddr == null) {</span>
<span class="nc" id="L820">                    continue;</span>
                }
<span class="nc" id="L822">                ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieAddr);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">                if (nodeLocation.getZone().equals(zone)) {</span>
<span class="nc" id="L824">                    upgradeDomainsOfThisZoneInWriteQuorum.add(nodeLocation.getUpgradeDomain());</span>
                }
            }
<span class="nc bnc" id="L827" title="All 2 branches missed.">            if (upgradeDomainsOfThisZoneInWriteQuorum.size() == 1) {</span>
<span class="nc" id="L828">                upgradeDomainsToExclude.addAll(upgradeDomainsOfThisZoneInWriteQuorum);</span>
            }
        }
<span class="nc" id="L831">        return upgradeDomainsToExclude;</span>
    }

    @Override
    public void registerSlowBookie(BookieId bookieSocketAddress, long entryId) {
        // TODO Auto-generated method stub
<span class="nc" id="L837">    }</span>

    @Override
    public DistributionSchedule.WriteSet reorderReadSequence(List&lt;BookieId&gt; ensemble,
            BookiesHealthInfo bookiesHealthInfo, DistributionSchedule.WriteSet writeSet) {
<span class="nc" id="L842">        return writeSet;</span>
    }

    @Override
    public DistributionSchedule.WriteSet reorderReadLACSequence(List&lt;BookieId&gt; ensemble,
            BookiesHealthInfo bookiesHealthInfo, DistributionSchedule.WriteSet writeSet) {
<span class="nc" id="L848">        DistributionSchedule.WriteSet retList = reorderReadSequence(ensemble, bookiesHealthInfo, writeSet);</span>
<span class="nc" id="L849">        retList.addMissingIndices(ensemble.size());</span>
<span class="nc" id="L850">        return retList;</span>
    }

    /*
     * In ZoneAwareEnsemblePlacementPolicy if bookies in the writeset are from
     * 'desiredNumOfZones' then it is considered as MEETS_STRICT if they are
     * from 'minNumOfZones' then it is considered as MEETS_SOFT otherwise
     * considered as FAIL. Also in a writeset if there are multiple bookies from
     * the same zone then they are expected to be from different upgrade
     * domains.
     */
    @Override
    public PlacementPolicyAdherence isEnsembleAdheringToPlacementPolicy(List&lt;BookieId&gt; ensembleList,
            int writeQuorumSize, int ackQuorumSize) {
<span class="nc bnc" id="L864" title="All 2 branches missed.">        if (CollectionUtils.isEmpty(ensembleList)) {</span>
<span class="nc" id="L865">            return PlacementPolicyAdherence.FAIL;</span>
        }
<span class="nc" id="L867">        PlacementPolicyAdherence placementPolicyAdherence = PlacementPolicyAdherence.MEETS_STRICT;</span>
<span class="nc" id="L868">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L870">            HashMap&lt;String, Set&lt;String&gt;&gt; bookiesLocationInWriteSet = new HashMap&lt;String, Set&lt;String&gt;&gt;();</span>
<span class="nc" id="L871">            HashMap&lt;String, Integer&gt; numOfBookiesInZones = new HashMap&lt;String, Integer&gt;();</span>
            BookieId bookieNode;
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if (ensembleList.size() % writeQuorumSize != 0) {</span>
<span class="nc" id="L874">                placementPolicyAdherence = PlacementPolicyAdherence.FAIL;</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L876">                    LOG.debug(</span>
                            &quot;For ensemble: {}, ensembleSize: {} is not a multiple of writeQuorumSize: {}&quot;,
<span class="nc" id="L878">                            ensembleList, ensembleList.size(), writeQuorumSize);</span>
                }
<span class="nc" id="L880">                return placementPolicyAdherence;</span>
            }
<span class="nc bnc" id="L882" title="All 2 branches missed.">            if (writeQuorumSize &lt;= minNumZonesPerWriteQuorum) {</span>
<span class="nc" id="L883">                placementPolicyAdherence = PlacementPolicyAdherence.FAIL;</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L885">                    LOG.debug(</span>
                            &quot;For ensemble: {}, writeQuorumSize: {} is less than or equal to&quot;
                            + &quot; minNumZonesPerWriteQuorum: {}&quot;,
<span class="nc" id="L888">                            ensembleList, writeQuorumSize, minNumZonesPerWriteQuorum);</span>
                }
<span class="nc" id="L890">                return placementPolicyAdherence;</span>
            }
<span class="nc" id="L892">            int desiredNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, desiredNumZonesPerWriteQuorum);</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">            for (int i = 0; i &lt; ensembleList.size(); i++) {</span>
<span class="nc" id="L894">                bookiesLocationInWriteSet.clear();</span>
<span class="nc" id="L895">                numOfBookiesInZones.clear();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">                for (int j = 0; j &lt; writeQuorumSize; j++) {</span>
<span class="nc" id="L897">                    int indexOfNode = (i + j) % ensembleList.size();</span>
<span class="nc" id="L898">                    bookieNode = ensembleList.get(indexOfNode);</span>
<span class="nc" id="L899">                    ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieNode);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                    if (nodeLocation.equals(unresolvedNodeLocation)) {</span>
<span class="nc" id="L901">                        placementPolicyAdherence = PlacementPolicyAdherence.FAIL;</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">                        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L903">                            LOG.debug(&quot;ensemble: {}, contains bookie: {} for which network location is unresolvable&quot;,</span>
                                    ensembleList, bookieNode);
                        }
<span class="nc" id="L906">                        return placementPolicyAdherence;</span>
                    }
<span class="nc" id="L908">                    String zone = nodeLocation.getZone();</span>
<span class="nc" id="L909">                    String upgradeDomain = nodeLocation.getUpgradeDomain();</span>
<span class="nc" id="L910">                    Set&lt;String&gt; udsOfThisZoneInThisWriteSet = bookiesLocationInWriteSet.get(zone);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">                    if (udsOfThisZoneInThisWriteSet == null) {</span>
<span class="nc" id="L912">                        udsOfThisZoneInThisWriteSet = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L913">                        udsOfThisZoneInThisWriteSet.add(upgradeDomain);</span>
<span class="nc" id="L914">                        bookiesLocationInWriteSet.put(zone, udsOfThisZoneInThisWriteSet);</span>
<span class="nc" id="L915">                        numOfBookiesInZones.put(zone, 1);</span>
                    } else {
<span class="nc" id="L917">                        udsOfThisZoneInThisWriteSet.add(upgradeDomain);</span>
<span class="nc" id="L918">                        Integer numOfNodesInAZone = numOfBookiesInZones.get(zone);</span>
<span class="nc" id="L919">                        numOfBookiesInZones.put(zone, (numOfNodesInAZone + 1));</span>
                    }
                }
<span class="nc bnc" id="L922" title="All 2 branches missed.">                if (numOfBookiesInZones.entrySet().size() &lt; minNumZonesPerWriteQuorum) {</span>
<span class="nc" id="L923">                    placementPolicyAdherence = PlacementPolicyAdherence.FAIL;</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L925">                        LOG.debug(&quot;in ensemble: {}, writeset starting at: {} doesn't contain bookies from&quot;</span>
<span class="nc" id="L926">                                + &quot; minNumZonesPerWriteQuorum: {}&quot;, ensembleList, i, minNumZonesPerWriteQuorum);</span>
                    }
<span class="nc" id="L928">                    return placementPolicyAdherence;</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">                } else if (numOfBookiesInZones.entrySet().size() &gt;= desiredNumZonesPerWriteQuorumForThisEnsemble) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                    if (!validateMinUDsAreMaintained(numOfBookiesInZones, bookiesLocationInWriteSet)) {</span>
<span class="nc" id="L931">                        placementPolicyAdherence = PlacementPolicyAdherence.FAIL;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">                        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L933">                            LOG.debug(&quot;in ensemble: {}, writeset starting at: {} doesn't maintain min of 2 UDs&quot;</span>
<span class="nc" id="L934">                                    + &quot; when there are multiple bookies from the same zone.&quot;, ensembleList, i);</span>
                        }
<span class="nc" id="L936">                        return placementPolicyAdherence;</span>
                    }
                } else {
<span class="nc bnc" id="L939" title="All 2 branches missed.">                    if (!validateMinUDsAreMaintained(numOfBookiesInZones, bookiesLocationInWriteSet)) {</span>
<span class="nc" id="L940">                        placementPolicyAdherence = PlacementPolicyAdherence.FAIL;</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">                        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L942">                            LOG.debug(&quot;in ensemble: {}, writeset starting at: {} doesn't maintain min of 2 UDs&quot;</span>
<span class="nc" id="L943">                                    + &quot; when there are multiple bookies from the same zone.&quot;, ensembleList, i);</span>
                        }
<span class="nc" id="L945">                        return placementPolicyAdherence;</span>
                    }
<span class="nc bnc" id="L947" title="All 2 branches missed.">                    if (placementPolicyAdherence == PlacementPolicyAdherence.MEETS_STRICT) {</span>
<span class="nc" id="L948">                        placementPolicyAdherence = PlacementPolicyAdherence.MEETS_SOFT;</span>
                    }
                }
            }
        } finally {
<span class="nc" id="L953">            rwLock.readLock().unlock();</span>
        }
<span class="nc" id="L955">        return placementPolicyAdherence;</span>
    }

    private boolean validateMinUDsAreMaintained(HashMap&lt;String, Integer&gt; numOfNodesInZones,
            HashMap&lt;String, Set&lt;String&gt;&gt; nodesLocationInWriteSet) {
<span class="nc bnc" id="L960" title="All 2 branches missed.">        for (Entry&lt;String, Integer&gt; numOfNodesInZone : numOfNodesInZones.entrySet()) {</span>
<span class="nc" id="L961">            String zone = numOfNodesInZone.getKey();</span>
<span class="nc" id="L962">            Integer numOfNodesInThisZone = numOfNodesInZone.getValue();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (numOfNodesInThisZone &gt; 1) {</span>
<span class="nc" id="L964">                Set&lt;String&gt; udsOfThisZone = nodesLocationInWriteSet.get(zone);</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">                if (udsOfThisZone.size() &lt; 2) {</span>
<span class="nc" id="L966">                    return false;</span>
                }
            }
<span class="nc" id="L969">        }</span>
<span class="nc" id="L970">        return true;</span>
    }

    @Override
    public boolean areAckedBookiesAdheringToPlacementPolicy(Set&lt;BookieId&gt; ackedBookies, int writeQuorumSize,
            int ackQuorumSize) {
<span class="nc" id="L976">        HashSet&lt;String&gt; zonesOfAckedBookies = new HashSet&lt;&gt;();</span>
<span class="nc" id="L977">        int minNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumZonesPerWriteQuorum);</span>
<span class="nc" id="L978">        boolean areAckedBookiesAdheringToPlacementPolicy = false;</span>
<span class="nc" id="L979">        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();</span>
<span class="nc" id="L980">        readLock.lock();</span>
        try {
<span class="nc bnc" id="L982" title="All 2 branches missed.">            for (BookieId ackedBookie : ackedBookies) {</span>
<span class="nc" id="L983">                zonesOfAckedBookies.add(getZoneAwareNodeLocation(ackedBookie).getZone());</span>
<span class="nc" id="L984">            }</span>
<span class="nc" id="L985">            areAckedBookiesAdheringToPlacementPolicy = ((zonesOfAckedBookies</span>
<span class="nc bnc" id="L986" title="All 4 branches missed.">                    .size() &gt;= minNumZonesPerWriteQuorumForThisEnsemble) &amp;&amp; (ackedBookies.size() &gt;= ackQuorumSize));</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L988">                LOG.debug(</span>
                        &quot;areAckedBookiesAdheringToPlacementPolicy returning {}, because number of ackedBookies = {},&quot;
                                + &quot; number of Zones of ackedbookies = {},&quot;
                                + &quot; number of minNumZonesPerWriteQuorumForThisEnsemble = {}&quot;,
<span class="nc" id="L992">                        areAckedBookiesAdheringToPlacementPolicy, ackedBookies.size(), zonesOfAckedBookies.size(),</span>
<span class="nc" id="L993">                        minNumZonesPerWriteQuorumForThisEnsemble);</span>
            }
        } finally {
<span class="nc" id="L996">            readLock.unlock();</span>
        }
<span class="nc" id="L998">        return areAckedBookiesAdheringToPlacementPolicy;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>