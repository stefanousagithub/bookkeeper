<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgerChecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">LedgerChecker.java</span></div><h1>LedgerChecker.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import io.netty.buffer.ByteBuf;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.bookkeeper.client.BKException.Code;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.proto.BookieClient;
import org.apache.bookkeeper.proto.BookieProtocol;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A utility class to check the complete ledger and finds the UnderReplicated fragments if any.
 *
 * &lt;p&gt;NOTE: This class is tended to be used by this project only. External users should not rely on it directly.
 */
public class LedgerChecker {
<span class="nc" id="L51">    private static final Logger LOG = LoggerFactory.getLogger(LedgerChecker.class);</span>

    public final BookieClient bookieClient;
    public final BookieWatcher bookieWatcher;

    final Semaphore semaphore;

<span class="nc" id="L58">    static class InvalidFragmentException extends Exception {</span>
        private static final long serialVersionUID = 1467201276417062353L;
    }

    /**
     * This will collect all the entry read call backs and finally it will give
     * call back to previous call back API which is waiting for it once it meets
     * the expected call backs from down.
     */
    private class ReadManyEntriesCallback implements ReadEntryCallback {
<span class="nc" id="L68">        AtomicBoolean completed = new AtomicBoolean(false);</span>
        final AtomicLong numEntries;
        final LedgerFragment fragment;
        final GenericCallback&lt;LedgerFragment&gt; cb;

        ReadManyEntriesCallback(long numEntries, LedgerFragment fragment,
<span class="nc" id="L74">                GenericCallback&lt;LedgerFragment&gt; cb) {</span>
<span class="nc" id="L75">            this.numEntries = new AtomicLong(numEntries);</span>
<span class="nc" id="L76">            this.fragment = fragment;</span>
<span class="nc" id="L77">            this.cb = cb;</span>
<span class="nc" id="L78">        }</span>

        @Override
        public void readEntryComplete(int rc, long ledgerId, long entryId,
                ByteBuf buffer, Object ctx) {
<span class="nc" id="L83">            releasePermit();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">            if (rc == BKException.Code.OK) {</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                if (numEntries.decrementAndGet() == 0</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">                        &amp;&amp; !completed.getAndSet(true)) {</span>
<span class="nc" id="L87">                    cb.operationComplete(rc, fragment);</span>
                }
<span class="nc bnc" id="L89" title="All 2 branches missed.">            } else if (!completed.getAndSet(true)) {</span>
<span class="nc" id="L90">                cb.operationComplete(rc, fragment);</span>
            }
<span class="nc" id="L92">        }</span>
    }

    /**
     * This will collect the bad bookies inside a ledger fragment.
     */
    private static class LedgerFragmentCallback implements GenericCallback&lt;LedgerFragment&gt; {

        private final LedgerFragment fragment;
        private final int bookieIndex;
        // bookie index -&gt; return code
        private final Map&lt;Integer, Integer&gt; badBookies;
        private final AtomicInteger numBookies;
        private final GenericCallback&lt;LedgerFragment&gt; cb;

        LedgerFragmentCallback(LedgerFragment lf,
                               int bookieIndex,
                               GenericCallback&lt;LedgerFragment&gt; cb,
                               Map&lt;Integer, Integer&gt; badBookies,
<span class="nc" id="L111">                               AtomicInteger numBookies) {</span>
<span class="nc" id="L112">            this.fragment = lf;</span>
<span class="nc" id="L113">            this.bookieIndex = bookieIndex;</span>
<span class="nc" id="L114">            this.cb = cb;</span>
<span class="nc" id="L115">            this.badBookies = badBookies;</span>
<span class="nc" id="L116">            this.numBookies = numBookies;</span>
<span class="nc" id="L117">        }</span>

        @Override
        public void operationComplete(int rc, LedgerFragment lf) {
<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (BKException.Code.OK != rc) {</span>
<span class="nc" id="L122">                synchronized (badBookies) {</span>
<span class="nc" id="L123">                    badBookies.put(bookieIndex, rc);</span>
<span class="nc" id="L124">                }</span>
            }
<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (numBookies.decrementAndGet() == 0) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if (badBookies.isEmpty()) {</span>
<span class="nc" id="L128">                    cb.operationComplete(BKException.Code.OK, fragment);</span>
                } else {
<span class="nc" id="L130">                    int rcToReturn = BKException.Code.NoBookieAvailableException;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                    for (Map.Entry&lt;Integer, Integer&gt; entry : badBookies.entrySet()) {</span>
<span class="nc" id="L132">                        rcToReturn = entry.getValue();</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                        if (entry.getValue() == BKException.Code.ClientClosedException) {</span>
<span class="nc" id="L134">                            break;</span>
                        }
<span class="nc" id="L136">                    }</span>
<span class="nc" id="L137">                    cb.operationComplete(rcToReturn,</span>
<span class="nc" id="L138">                            fragment.subset(badBookies.keySet()));</span>
                }
            }
<span class="nc" id="L141">        }</span>
    }

    public LedgerChecker(BookKeeper bkc) {
<span class="nc" id="L145">        this(bkc.getBookieClient(), bkc.getBookieWatcher());</span>
<span class="nc" id="L146">    }</span>

    public LedgerChecker(BookieClient client, BookieWatcher watcher) {
<span class="nc" id="L149">        this(client, watcher, -1);</span>
<span class="nc" id="L150">    }</span>

    public LedgerChecker(BookKeeper bkc, int inFlightReadEntryNum) {
<span class="nc" id="L153">        this(bkc.getBookieClient(), bkc.getBookieWatcher(), inFlightReadEntryNum);</span>
<span class="nc" id="L154">    }</span>

<span class="nc" id="L156">    public LedgerChecker(BookieClient client, BookieWatcher watcher, int inFlightReadEntryNum) {</span>
<span class="nc" id="L157">        bookieClient = client;</span>
<span class="nc" id="L158">        bookieWatcher = watcher;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (inFlightReadEntryNum &gt; 0) {</span>
<span class="nc" id="L160">            semaphore = new Semaphore(inFlightReadEntryNum);</span>
        } else {
<span class="nc" id="L162">            semaphore = null;</span>
        }
<span class="nc" id="L164">    }</span>

    /**
     * Acquires a permit from permit manager,
     * blocking until all are available.
     */
    public void acquirePermit() throws InterruptedException {
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (null != semaphore) {</span>
<span class="nc" id="L172">            semaphore.acquire(1);</span>
        }
<span class="nc" id="L174">    }</span>

    /**
     * Release a given permit.
     */
    public void releasePermit() {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (null != semaphore) {</span>
<span class="nc" id="L181">            semaphore.release();</span>
        }
<span class="nc" id="L183">    }</span>

    /**
     * Verify a ledger fragment to collect bad bookies.
     *
     * @param fragment
     *          fragment to verify
     * @param cb
     *          callback
     * @throws InvalidFragmentException
     */
    private void verifyLedgerFragment(LedgerFragment fragment,
                                      GenericCallback&lt;LedgerFragment&gt; cb,
                                      Long percentageOfLedgerFragmentToBeVerified)
            throws InvalidFragmentException, BKException, InterruptedException {
<span class="nc" id="L198">        Set&lt;Integer&gt; bookiesToCheck = fragment.getBookiesIndexes();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (bookiesToCheck.isEmpty()) {</span>
<span class="nc" id="L200">            cb.operationComplete(BKException.Code.OK, fragment);</span>
<span class="nc" id="L201">            return;</span>
        }

<span class="nc" id="L204">        AtomicInteger numBookies = new AtomicInteger(bookiesToCheck.size());</span>
<span class="nc" id="L205">        Map&lt;Integer, Integer&gt; badBookies = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (Integer bookieIndex : bookiesToCheck) {</span>
<span class="nc" id="L207">            LedgerFragmentCallback lfCb = new LedgerFragmentCallback(</span>
<span class="nc" id="L208">                    fragment, bookieIndex, cb, badBookies, numBookies);</span>
<span class="nc" id="L209">            verifyLedgerFragment(fragment, bookieIndex, lfCb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L210">        }</span>
<span class="nc" id="L211">    }</span>

    /**
     * Verify a bookie inside a ledger fragment.
     *
     * @param fragment
     *          ledger fragment
     * @param bookieIndex
     *          bookie index in the fragment
     * @param cb
     *          callback
     * @throws InvalidFragmentException
     */
    private void verifyLedgerFragment(LedgerFragment fragment,
                                      int bookieIndex,
                                      GenericCallback&lt;LedgerFragment&gt; cb,
                                      long percentageOfLedgerFragmentToBeVerified)
            throws InvalidFragmentException, InterruptedException {
<span class="nc" id="L229">        long firstStored = fragment.getFirstStoredEntryId(bookieIndex);</span>
<span class="nc" id="L230">        long lastStored = fragment.getLastStoredEntryId(bookieIndex);</span>

<span class="nc" id="L232">        BookieId bookie = fragment.getAddress(bookieIndex);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (null == bookie) {</span>
<span class="nc" id="L234">            throw new InvalidFragmentException();</span>
        }

<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (firstStored == LedgerHandle.INVALID_ENTRY_ID) {</span>
            // this fragment is not on this bookie
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (lastStored != LedgerHandle.INVALID_ENTRY_ID) {</span>
<span class="nc" id="L240">                throw new InvalidFragmentException();</span>
            }

<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (bookieWatcher.isBookieUnavailable(fragment.getAddress(bookieIndex))) {</span>
                // fragment is on this bookie, but already know it's unavailable, so skip the call
<span class="nc" id="L245">                cb.operationComplete(BKException.Code.BookieHandleNotAvailableException, fragment);</span>
            } else {
<span class="nc" id="L247">                cb.operationComplete(BKException.Code.OK, fragment);</span>
            }
<span class="nc bnc" id="L249" title="All 2 branches missed.">        } else if (bookieWatcher.isBookieUnavailable(fragment.getAddress(bookieIndex))) {</span>
            // fragment is on this bookie, but already know it's unavailable, so skip the call
<span class="nc" id="L251">            cb.operationComplete(BKException.Code.BookieHandleNotAvailableException, fragment);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        } else if (firstStored == lastStored) {</span>
<span class="nc" id="L253">            acquirePermit();</span>
<span class="nc" id="L254">            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(1,</span>
                    fragment, cb);
<span class="nc" id="L256">            bookieClient.readEntry(bookie, fragment.getLedgerId(), firstStored,</span>
                                   manycb, null, BookieProtocol.FLAG_NONE);
<span class="nc" id="L258">        } else {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (lastStored &lt;= firstStored) {</span>
<span class="nc" id="L260">                cb.operationComplete(Code.IncorrectParameterException, null);</span>
<span class="nc" id="L261">                return;</span>
            }

<span class="nc" id="L264">            long lengthOfLedgerFragment = lastStored - firstStored + 1;</span>

<span class="nc" id="L266">            int numberOfEntriesToBeVerified =</span>
                (int) (lengthOfLedgerFragment * (percentageOfLedgerFragmentToBeVerified / 100.0));

<span class="nc" id="L269">            TreeSet&lt;Long&gt; entriesToBeVerified = new TreeSet&lt;Long&gt;();</span>

<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (numberOfEntriesToBeVerified &lt; lengthOfLedgerFragment) {</span>
                // Evenly pick random entries over the length of the fragment
<span class="nc bnc" id="L273" title="All 2 branches missed.">                if (numberOfEntriesToBeVerified &gt; 0) {</span>
<span class="nc" id="L274">                    int lengthOfBucket = (int) (lengthOfLedgerFragment / numberOfEntriesToBeVerified);</span>
<span class="nc" id="L275">                    for (long index = firstStored;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                         index &lt; (lastStored - lengthOfBucket - 1);</span>
<span class="nc" id="L277">                         index += lengthOfBucket) {</span>
<span class="nc" id="L278">                        long potentialEntryId = ThreadLocalRandom.current().nextInt((lengthOfBucket)) + index;</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                        if (fragment.isStoredEntryId(potentialEntryId, bookieIndex)) {</span>
<span class="nc" id="L280">                            entriesToBeVerified.add(potentialEntryId);</span>
                        }
                    }
                }
<span class="nc" id="L284">                entriesToBeVerified.add(firstStored);</span>
<span class="nc" id="L285">                entriesToBeVerified.add(lastStored);</span>
            } else {
                // Verify the entire fragment
<span class="nc bnc" id="L288" title="All 2 branches missed.">                while (firstStored &lt;= lastStored) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                    if (fragment.isStoredEntryId(firstStored, bookieIndex)) {</span>
<span class="nc" id="L290">                        entriesToBeVerified.add(firstStored);</span>
                    }
<span class="nc" id="L292">                    firstStored++;</span>
                }
            }
<span class="nc" id="L295">            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(entriesToBeVerified.size(),</span>
                    fragment, cb);
<span class="nc bnc" id="L297" title="All 2 branches missed.">            for (Long entryID: entriesToBeVerified) {</span>
<span class="nc" id="L298">                acquirePermit();</span>
<span class="nc" id="L299">                bookieClient.readEntry(bookie, fragment.getLedgerId(), entryID, manycb, null, BookieProtocol.FLAG_NONE);</span>
<span class="nc" id="L300">            }</span>
        }
<span class="nc" id="L302">    }</span>

    /**
     * Callback for checking whether an entry exists or not.
     * It is used to differentiate the cases where it has been written
     * but now cannot be read, and where it never has been written.
     */
    private class EntryExistsCallback implements ReadEntryCallback {
<span class="nc" id="L310">        AtomicBoolean entryMayExist = new AtomicBoolean(false);</span>
        final AtomicInteger numReads;
        final GenericCallback&lt;Boolean&gt; cb;

        EntryExistsCallback(int numReads,
<span class="nc" id="L315">                            GenericCallback&lt;Boolean&gt; cb) {</span>
<span class="nc" id="L316">            this.numReads = new AtomicInteger(numReads);</span>
<span class="nc" id="L317">            this.cb = cb;</span>
<span class="nc" id="L318">        }</span>

        @Override
        public void readEntryComplete(int rc, long ledgerId, long entryId,
                                      ByteBuf buffer, Object ctx) {
<span class="nc" id="L323">            releasePermit();</span>
<span class="nc bnc" id="L324" title="All 6 branches missed.">            if (BKException.Code.NoSuchEntryException != rc &amp;&amp; BKException.Code.NoSuchLedgerExistsException != rc</span>
                    &amp;&amp; BKException.Code.NoSuchLedgerExistsOnMetadataServerException != rc) {
<span class="nc" id="L326">                entryMayExist.set(true);</span>
            }

<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (numReads.decrementAndGet() == 0) {</span>
<span class="nc" id="L330">                cb.operationComplete(rc, entryMayExist.get());</span>
            }
<span class="nc" id="L332">        }</span>
    }

    /**
     * This will collect all the fragment read call backs and finally it will
     * give call back to above call back API which is waiting for it once it
     * meets the expected call backs from down.
     */
    private static class FullLedgerCallback implements
            GenericCallback&lt;LedgerFragment&gt; {
        final Set&lt;LedgerFragment&gt; badFragments;
        final AtomicLong numFragments;
        final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb;

        FullLedgerCallback(long numFragments,
<span class="nc" id="L347">                GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb) {</span>
<span class="nc" id="L348">            badFragments = new LinkedHashSet&lt;&gt;();</span>
<span class="nc" id="L349">            this.numFragments = new AtomicLong(numFragments);</span>
<span class="nc" id="L350">            this.cb = cb;</span>
<span class="nc" id="L351">        }</span>

        @Override
        public void operationComplete(int rc, LedgerFragment result) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (rc == BKException.Code.ClientClosedException) {</span>
<span class="nc" id="L356">                cb.operationComplete(BKException.Code.ClientClosedException, badFragments);</span>
<span class="nc" id="L357">                return;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            } else if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L359">                badFragments.add(result);</span>
            }
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (numFragments.decrementAndGet() == 0) {</span>
<span class="nc" id="L362">                cb.operationComplete(BKException.Code.OK, badFragments);</span>
            }
<span class="nc" id="L364">        }</span>
    }

    /**
     * Check that all the fragments in the passed in ledger, and report those
     * which are missing.
     */
    public void checkLedger(final LedgerHandle lh,
                            final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb) {
<span class="nc" id="L373">        checkLedger(lh, cb, 0L);</span>
<span class="nc" id="L374">    }</span>

    public void checkLedger(final LedgerHandle lh,
                            final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb,
                            long percentageOfLedgerFragmentToBeVerified) {
        // build a set of all fragment replicas
<span class="nc" id="L380">        final Set&lt;LedgerFragment&gt; fragments = new LinkedHashSet&lt;&gt;();</span>

<span class="nc" id="L382">        Long curEntryId = null;</span>
<span class="nc" id="L383">        List&lt;BookieId&gt; curEnsemble = null;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        for (Map.Entry&lt;Long, ? extends List&lt;BookieId&gt;&gt; e : lh</span>
<span class="nc" id="L385">                .getLedgerMetadata().getAllEnsembles().entrySet()) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">            if (curEntryId != null) {</span>
<span class="nc" id="L387">                Set&lt;Integer&gt; bookieIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                for (int i = 0; i &lt; curEnsemble.size(); i++) {</span>
<span class="nc" id="L389">                    bookieIndexes.add(i);</span>
                }
<span class="nc" id="L391">                fragments.add(new LedgerFragment(lh, curEntryId,</span>
<span class="nc" id="L392">                        e.getKey() - 1, bookieIndexes));</span>
            }
<span class="nc" id="L394">            curEntryId = e.getKey();</span>
<span class="nc" id="L395">            curEnsemble = e.getValue();</span>
<span class="nc" id="L396">        }</span>

        /* Checking the last segment of the ledger can be complicated in some cases.
         * In the case that the ledger is closed, we can just check the fragments of
         * the segment as normal even if no data has ever been written to.
         * In the case that the ledger is open, but enough entries have been written,
         * for lastAddConfirmed to be set above the start entry of the segment, we
         * can also check as normal.
         * However, if ledger is open, sometimes lastAddConfirmed cannot be trusted,
         * such as when it's lower than the first entry id, or not set at all,
         * we cannot be sure if there has been data written to the segment.
         * For this reason, we have to send a read request
         * to the bookies which should have the first entry. If they respond with
         * NoSuchEntry we can assume it was never written. If they respond with anything
         * else, we must assume the entry has been written, so we run the check.
         */
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (curEntryId != null) {</span>
<span class="nc" id="L413">            long lastEntry = lh.getLastAddConfirmed();</span>

<span class="nc bnc" id="L415" title="All 4 branches missed.">            if (!lh.isClosed() &amp;&amp; lastEntry &lt; curEntryId) {</span>
<span class="nc" id="L416">                lastEntry = curEntryId;</span>
            }

<span class="nc" id="L419">            Set&lt;Integer&gt; bookieIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int i = 0; i &lt; curEnsemble.size(); i++) {</span>
<span class="nc" id="L421">                bookieIndexes.add(i);</span>
            }
<span class="nc" id="L423">            final LedgerFragment lastLedgerFragment = new LedgerFragment(lh, curEntryId,</span>
                    lastEntry, bookieIndexes);

            // Check for the case that no last confirmed entry has been set
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (curEntryId == lastEntry) {</span>
<span class="nc" id="L428">                final long entryToRead = curEntryId;</span>

<span class="nc" id="L430">                final CompletableFuture&lt;Void&gt; future = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L431">                future.whenCompleteAsync((re, ex) -&gt; {</span>
<span class="nc" id="L432">                    checkFragments(fragments, cb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L433">                });</span>

<span class="nc" id="L435">                final EntryExistsCallback eecb = new EntryExistsCallback(lh.getLedgerMetadata().getWriteQuorumSize(),</span>
<span class="nc" id="L436">                                              new GenericCallback&lt;Boolean&gt;() {</span>
                                                  @Override
                                                  public void operationComplete(int rc, Boolean result) {
<span class="nc bnc" id="L439" title="All 2 branches missed.">                                                      if (result) {</span>
<span class="nc" id="L440">                                                          fragments.add(lastLedgerFragment);</span>
                                                      }
<span class="nc" id="L442">                                                      future.complete(null);</span>
<span class="nc" id="L443">                                                  }</span>
                                              });

<span class="nc" id="L446">                DistributionSchedule ds = lh.getDistributionSchedule();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                for (int i = 0; i &lt; ds.getWriteQuorumSize(); i++) {</span>
                    try {
<span class="nc" id="L449">                        acquirePermit();</span>
<span class="nc" id="L450">                        BookieId addr = curEnsemble.get(ds.getWriteSetBookieIndex(entryToRead, i));</span>
<span class="nc" id="L451">                        bookieClient.readEntry(addr, lh.getId(), entryToRead,</span>
                                eecb, null, BookieProtocol.FLAG_NONE);
<span class="nc" id="L453">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L454">                        LOG.error(&quot;InterruptedException when checking entry : {}&quot;, entryToRead, e);</span>
<span class="nc" id="L455">                    }</span>
                }
<span class="nc" id="L457">                return;</span>
            } else {
<span class="nc" id="L459">                fragments.add(lastLedgerFragment);</span>
            }
        }
<span class="nc" id="L462">        checkFragments(fragments, cb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L463">    }</span>

    private void checkFragments(Set&lt;LedgerFragment&gt; fragments,
                                GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb,
                                long percentageOfLedgerFragmentToBeVerified) {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (fragments.size() == 0) { // no fragments to verify</span>
<span class="nc" id="L469">            cb.operationComplete(BKException.Code.OK, fragments);</span>
<span class="nc" id="L470">            return;</span>
        }

        // verify all the collected fragment replicas
<span class="nc" id="L474">        FullLedgerCallback allFragmentsCb = new FullLedgerCallback(fragments</span>
<span class="nc" id="L475">                .size(), cb);</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        for (LedgerFragment r : fragments) {</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L478">                LOG.debug(&quot;Checking fragment {}&quot;, r);</span>
            }
            try {
<span class="nc" id="L481">                verifyLedgerFragment(r, allFragmentsCb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L482">            } catch (InvalidFragmentException ife) {</span>
<span class="nc" id="L483">                LOG.error(&quot;Invalid fragment found : {}&quot;, r);</span>
<span class="nc" id="L484">                allFragmentsCb.operationComplete(</span>
                        BKException.Code.IncorrectParameterException, r);
<span class="nc" id="L486">            } catch (BKException e) {</span>
<span class="nc" id="L487">                LOG.error(&quot;BKException when checking fragment : {}&quot;, r, e);</span>
<span class="nc" id="L488">            } catch (InterruptedException e) {</span>
<span class="nc" id="L489">                LOG.error(&quot;InterruptedException when checking fragment : {}&quot;, r, e);</span>
<span class="nc" id="L490">            }</span>
<span class="nc" id="L491">        }</span>
<span class="nc" id="L492">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>