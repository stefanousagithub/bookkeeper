<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReadOnlyLedgerHandle.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">ReadOnlyLedgerHandle.java</span></div><h1>ReadOnlyLedgerHandle.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkState;

import com.google.common.annotations.VisibleForTesting;
import java.security.GeneralSecurityException;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.RejectedExecutionException;
import org.apache.bookkeeper.client.AsyncCallback.AddCallback;
import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;
import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;
import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;
import org.apache.bookkeeper.client.api.LedgerMetadata;
import org.apache.bookkeeper.client.api.WriteFlag;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.LedgerMetadataListener;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryListener;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.TimedGenericCallback;
import org.apache.bookkeeper.versioning.Version;
import org.apache.bookkeeper.versioning.Versioned;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Read only ledger handle. This ledger handle allows you to
 * read from a ledger but not to write to it. It overrides all
 * the public write operations from LedgerHandle.
 * It should be returned for BookKeeper#openLedger operations.
 */
class ReadOnlyLedgerHandle extends LedgerHandle implements LedgerMetadataListener {
<span class="nc" id="L57">    private static final Logger LOG = LoggerFactory.getLogger(ReadOnlyLedgerHandle.class);</span>

<span class="nc" id="L59">    private Object metadataLock = new Object();</span>
<span class="nc" id="L60">    private final NavigableMap&lt;Long, List&lt;BookieId&gt;&gt; newEnsemblesFromRecovery = new TreeMap&lt;&gt;();</span>

    class MetadataUpdater implements Runnable {

        final Versioned&lt;LedgerMetadata&gt; newMetadata;

<span class="nc" id="L66">        MetadataUpdater(Versioned&lt;LedgerMetadata&gt; metadata) {</span>
<span class="nc" id="L67">            this.newMetadata = metadata;</span>
<span class="nc" id="L68">        }</span>

        @Override
        public void run() {
            while (true) {
<span class="nc" id="L73">                Versioned&lt;LedgerMetadata&gt; currentMetadata = getVersionedLedgerMetadata();</span>
<span class="nc" id="L74">                Version.Occurred occurred = currentMetadata.getVersion().compare(newMetadata.getVersion());</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">                if (Version.Occurred.BEFORE == occurred) {</span>
<span class="nc" id="L76">                    synchronized (ReadOnlyLedgerHandle.this) {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">                        if (setLedgerMetadata(currentMetadata, newMetadata)) {</span>
<span class="nc" id="L78">                            LOG.info(&quot;Updated ledger metadata for ledger {} to {}, version {}.&quot;,</span>
<span class="nc" id="L79">                                     ledgerId, newMetadata.getValue().toSafeString(), newMetadata.getVersion());</span>
<span class="nc" id="L80">                            break;</span>
                        }
<span class="nc" id="L82">                    }</span>
                } else {
                    break;
                }
<span class="nc" id="L86">            }</span>
<span class="nc" id="L87">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L91">            return String.format(&quot;MetadataUpdater(%d)&quot;, ledgerId);</span>
        }
    }

    ReadOnlyLedgerHandle(ClientContext clientCtx,
                         long ledgerId, Versioned&lt;LedgerMetadata&gt; metadata,
                         BookKeeper.DigestType digestType, byte[] password,
                         boolean watch)
            throws GeneralSecurityException, NumberFormatException {
<span class="nc" id="L100">        super(clientCtx, ledgerId, metadata, digestType, password, WriteFlag.NONE);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (watch) {</span>
<span class="nc" id="L102">            clientCtx.getLedgerManager().registerLedgerMetadataListener(ledgerId, this);</span>
        }
<span class="nc" id="L104">    }</span>

    @Override
    public void close()
            throws InterruptedException, BKException {
<span class="nc" id="L109">        clientCtx.getLedgerManager().unregisterLedgerMetadataListener(ledgerId, this);</span>
<span class="nc" id="L110">    }</span>

    @Override
    public void asyncClose(CloseCallback cb, Object ctx) {
<span class="nc" id="L114">        clientCtx.getLedgerManager().unregisterLedgerMetadataListener(ledgerId, this);</span>
<span class="nc" id="L115">        cb.closeComplete(BKException.Code.OK, this, ctx);</span>
<span class="nc" id="L116">    }</span>

    @Override
    public long addEntry(byte[] data) throws InterruptedException, BKException {
<span class="nc" id="L120">        return addEntry(data, 0, data.length);</span>
    }

    @Override
    public long addEntry(byte[] data, int offset, int length)
            throws InterruptedException, BKException {
<span class="nc" id="L126">        LOG.error(&quot;Tried to add entry on a Read-Only ledger handle, ledgerid=&quot; + ledgerId);</span>
<span class="nc" id="L127">        throw BKException.create(BKException.Code.IllegalOpException);</span>
    }

    @Override
    public void asyncAddEntry(final byte[] data, final AddCallback cb,
                              final Object ctx) {
<span class="nc" id="L133">        asyncAddEntry(data, 0, data.length, cb, ctx);</span>
<span class="nc" id="L134">    }</span>

    @Override
    public void asyncAddEntry(final byte[] data, final int offset, final int length,
                              final AddCallback cb, final Object ctx) {
<span class="nc" id="L139">        LOG.error(&quot;Tried to add entry on a Read-Only ledger handle, ledgerid=&quot; + ledgerId);</span>
<span class="nc" id="L140">        cb.addComplete(BKException.Code.IllegalOpException, this,</span>
                       LedgerHandle.INVALID_ENTRY_ID, ctx);
<span class="nc" id="L142">    }</span>

    @Override
    public void onChanged(long lid, Versioned&lt;LedgerMetadata&gt; newMetadata) {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L147">            LOG.debug(&quot;Received ledger metadata update on {} : {}&quot;, lid, newMetadata);</span>
        }
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (this.ledgerId != lid) {</span>
<span class="nc" id="L150">            return;</span>
        }
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (null == newMetadata) {</span>
<span class="nc" id="L153">            return;</span>
        }
<span class="nc" id="L155">        Versioned&lt;LedgerMetadata&gt; currentMetadata = getVersionedLedgerMetadata();</span>
<span class="nc" id="L156">        Version.Occurred occurred = currentMetadata.getVersion().compare(newMetadata.getVersion());</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L158">            LOG.debug(&quot;Try to update metadata from {} to {} : {}&quot;,</span>
                      currentMetadata, newMetadata, occurred);
        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (Version.Occurred.BEFORE == occurred) { // the metadata is updated</span>
            try {
<span class="nc" id="L163">                clientCtx.getMainWorkerPool().executeOrdered(ledgerId, new MetadataUpdater(newMetadata));</span>
<span class="nc" id="L164">            } catch (RejectedExecutionException ree) {</span>
<span class="nc" id="L165">                LOG.error(&quot;Failed on submitting updater to update ledger metadata on ledger {} : {}&quot;,</span>
<span class="nc" id="L166">                        ledgerId, newMetadata);</span>
<span class="nc" id="L167">            }</span>
        }
<span class="nc" id="L169">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L173">        return String.format(&quot;ReadOnlyLedgerHandle(lid = %d, id = %d)&quot;, ledgerId, super.hashCode());</span>
    }

    @Override
    protected void initializeWriteHandleState() {
        // Essentially a noop, we don't want to set up write handle state here for a ReadOnlyLedgerHandle
<span class="nc" id="L179">        explicitLacFlushPolicy = ExplicitLacFlushPolicy.VOID_EXPLICITLAC_FLUSH_POLICY;</span>
<span class="nc" id="L180">    }</span>

    @Override
    public void asyncReadLastEntry(ReadCallback cb, Object ctx) {
<span class="nc" id="L184">        asyncReadLastConfirmed(new ReadLastConfirmedCallback() {</span>
            @Override
            public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                    if (lastConfirmed &lt; 0) {</span>
                        // Ledger was empty, so there is no last entry to read
<span class="nc" id="L190">                        cb.readComplete(BKException.Code.NoSuchEntryException, ReadOnlyLedgerHandle.this, null, ctx);</span>
                    } else {
<span class="nc" id="L192">                        asyncReadEntriesInternal(lastConfirmed, lastConfirmed, cb, ctx, false);</span>
                    }
                } else {
<span class="nc" id="L195">                    LOG.error(&quot;ReadException in asyncReadLastEntry, ledgerId: {}, lac: {}, rc:{}&quot;,</span>
<span class="nc" id="L196">                        lastConfirmed, ledgerId, rc);</span>
<span class="nc" id="L197">                    cb.readComplete(rc, ReadOnlyLedgerHandle.this, null, ctx);</span>
                }
<span class="nc" id="L199">            }</span>
        }, ctx);
<span class="nc" id="L201">    }</span>

    /**
     * For a read only ledger handle, this method will only ever be called during recovery,
     * when we are reading forward from LAC and writing back those entries. As such,
     * unlike with LedgerHandle, we do not want to persist changes to the metadata as they occur,
     * but rather, we want to defer the persistence until recovery has completed, and do it all
     * on the close.
     */
    @Override
    void handleBookieFailure(final Map&lt;Integer, BookieId&gt; failedBookies) {
        // handleBookieFailure should always run in the ordered executor thread for this
        // ledger, so this synchronized should be unnecessary, but putting it here now
        // just in case (can be removed when we validate threads)
<span class="nc" id="L215">        synchronized (metadataLock) {</span>
<span class="nc" id="L216">            String logContext = String.format(&quot;[RecoveryEnsembleChange(ledger:%d)]&quot;, ledgerId);</span>

<span class="nc" id="L218">            long lac = getLastAddConfirmed();</span>
<span class="nc" id="L219">            LedgerMetadata metadata = getLedgerMetadata();</span>
<span class="nc" id="L220">            List&lt;BookieId&gt; currentEnsemble = getCurrentEnsemble();</span>
            try {
<span class="nc" id="L222">                List&lt;BookieId&gt; newEnsemble = EnsembleUtils.replaceBookiesInEnsemble(</span>
<span class="nc" id="L223">                        clientCtx.getBookieWatcher(), metadata, currentEnsemble, failedBookies, logContext);</span>
<span class="nc" id="L224">                Set&lt;Integer&gt; replaced = EnsembleUtils.diffEnsemble(currentEnsemble, newEnsemble);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                if (!replaced.isEmpty()) {</span>
<span class="nc" id="L226">                    newEnsemblesFromRecovery.put(lac + 1, newEnsemble);</span>
<span class="nc" id="L227">                    unsetSuccessAndSendWriteRequest(newEnsemble, replaced);</span>
                }
<span class="nc" id="L229">            } catch (BKException.BKNotEnoughBookiesException e) {</span>
<span class="nc" id="L230">                LOG.error(&quot;Could not get additional bookie to remake ensemble, closing ledger: {}&quot;, ledgerId);</span>

<span class="nc" id="L232">                handleUnrecoverableErrorDuringAdd(e.getCode());</span>
<span class="nc" id="L233">                return;</span>
<span class="nc" id="L234">            }</span>
<span class="nc" id="L235">        }</span>
<span class="nc" id="L236">    }</span>

    @Override
    void handleUnrecoverableErrorDuringAdd(int rc) {
<span class="nc" id="L240">        errorOutPendingAdds(rc);</span>
<span class="nc" id="L241">    }</span>

    void recover(GenericCallback&lt;Void&gt; finalCb) {
<span class="nc" id="L244">        recover(finalCb, null, false);</span>
<span class="nc" id="L245">    }</span>

    /**
     * Recover the ledger.
     *
     * @param finalCb
     *          callback after recovery is done.
     * @param listener
     *          read entry listener on recovery reads.
     * @param forceRecovery
     *          force the recovery procedure even the ledger metadata shows the ledger is closed.
     */
    void recover(GenericCallback&lt;Void&gt; finalCb,
                 final @VisibleForTesting ReadEntryListener listener,
                 final boolean forceRecovery) {
<span class="nc" id="L260">        final GenericCallback&lt;Void&gt; cb = new TimedGenericCallback&lt;Void&gt;(</span>
            finalCb,
            BKException.Code.OK,
<span class="nc" id="L263">            clientCtx.getClientStats().getRecoverOpLogger());</span>

<span class="nc" id="L265">        MetadataUpdateLoop.NeedsUpdatePredicate needsUpdate =</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            (metadata) -&gt; metadata.getState() == LedgerMetadata.State.OPEN;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (forceRecovery) {</span>
            // in the force recovery case, we want to update the metadata
            // to IN_RECOVERY, even if the ledger is already closed
<span class="nc bnc" id="L270" title="All 2 branches missed.">            needsUpdate = (metadata) -&gt; metadata.getState() != LedgerMetadata.State.IN_RECOVERY;</span>
        }
<span class="nc" id="L272">        new MetadataUpdateLoop(</span>
<span class="nc" id="L273">                clientCtx.getLedgerManager(), getId(),</span>
                this::getVersionedLedgerMetadata,
                needsUpdate,
<span class="nc" id="L276">                (metadata) -&gt; LedgerMetadataBuilder.from(metadata).withInRecoveryState().build(),</span>
                this::setLedgerMetadata)
<span class="nc" id="L278">            .run()</span>
<span class="nc" id="L279">            .thenCompose((metadata) -&gt; {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                    if (metadata.getValue().isClosed()) {</span>
<span class="nc" id="L281">                        return CompletableFuture.completedFuture(ReadOnlyLedgerHandle.this);</span>
                    } else {
<span class="nc" id="L283">                        return new LedgerRecoveryOp(ReadOnlyLedgerHandle.this, clientCtx)</span>
<span class="nc" id="L284">                            .setEntryListener(listener)</span>
<span class="nc" id="L285">                            .initiate();</span>
                    }
            })
<span class="nc" id="L288">            .thenCompose((ignore) -&gt; closeRecovered())</span>
<span class="nc" id="L289">            .whenComplete((ignore, ex) -&gt; {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                    if (ex != null) {</span>
<span class="nc" id="L291">                        cb.operationComplete(</span>
<span class="nc" id="L292">                                BKException.getExceptionCode(ex, BKException.Code.UnexpectedConditionException), null);</span>
                    } else {
<span class="nc" id="L294">                        cb.operationComplete(BKException.Code.OK, null);</span>
                    }
<span class="nc" id="L296">            });</span>
<span class="nc" id="L297">    }</span>

    CompletableFuture&lt;Versioned&lt;LedgerMetadata&gt;&gt; closeRecovered() {
        long lac, len;
<span class="nc" id="L301">        synchronized (this) {</span>
<span class="nc" id="L302">            lac = lastAddConfirmed;</span>
<span class="nc" id="L303">            len = length;</span>
<span class="nc" id="L304">        }</span>
<span class="nc" id="L305">        LOG.info(&quot;Closing recovered ledger {} at entry {}&quot;, getId(), lac);</span>
<span class="nc" id="L306">        CompletableFuture&lt;Versioned&lt;LedgerMetadata&gt;&gt; f = new MetadataUpdateLoop(</span>
<span class="nc" id="L307">                clientCtx.getLedgerManager(), getId(),</span>
                this::getVersionedLedgerMetadata,
<span class="nc bnc" id="L309" title="All 2 branches missed.">                (metadata) -&gt; metadata.getState() == LedgerMetadata.State.IN_RECOVERY,</span>
                (metadata) -&gt; {
<span class="nc" id="L311">                    LedgerMetadataBuilder builder = LedgerMetadataBuilder.from(metadata);</span>
<span class="nc" id="L312">                    Long lastEnsembleKey = LedgerMetadataUtils.getLastEnsembleKey(metadata);</span>
<span class="nc" id="L313">                    synchronized (metadataLock) {</span>
<span class="nc" id="L314">                        newEnsemblesFromRecovery.entrySet().forEach(</span>
                                (e) -&gt; {
<span class="nc bnc" id="L316" title="All 2 branches missed.">                                    checkState(e.getKey() &gt;= lastEnsembleKey,</span>
                                               &quot;Once a ledger is in recovery, noone can add ensembles without closing&quot;);
                                    // Occurs when a bookie need to be replaced at very start of recovery
<span class="nc bnc" id="L319" title="All 2 branches missed.">                                    if (lastEnsembleKey.equals(e.getKey())) {</span>
<span class="nc" id="L320">                                        builder.replaceEnsembleEntry(e.getKey(), e.getValue());</span>
                                    } else {
<span class="nc" id="L322">                                        builder.newEnsembleEntry(e.getKey(), e.getValue());</span>
                                    }
<span class="nc" id="L324">                                });</span>
<span class="nc" id="L325">                    }</span>
<span class="nc" id="L326">                    return builder.withClosedState().withLastEntryId(lac).withLength(len).build();</span>
                },
<span class="nc" id="L328">                this::setLedgerMetadata).run();</span>
<span class="nc" id="L329">        f.whenComplete((result, exception) -&gt; {</span>
<span class="nc" id="L330">            synchronized (metadataLock) {</span>
<span class="nc" id="L331">                newEnsemblesFromRecovery.clear();</span>
<span class="nc" id="L332">            }</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (exception != null) {</span>
<span class="nc" id="L334">                LOG.error(&quot;When closeRecovered,failed on clearing newEnsemblesFromRecovery.&quot;, exception);</span>
            }
<span class="nc" id="L336">        });</span>
<span class="nc" id="L337">        return f;</span>
    }

    @Override
    List&lt;BookieId&gt; getCurrentEnsemble() {
<span class="nc" id="L342">        synchronized (metadataLock) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (!newEnsemblesFromRecovery.isEmpty()) {</span>
<span class="nc" id="L344">                return newEnsemblesFromRecovery.lastEntry().getValue();</span>
            } else {
<span class="nc" id="L346">                return super.getCurrentEnsemble();</span>
            }
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>