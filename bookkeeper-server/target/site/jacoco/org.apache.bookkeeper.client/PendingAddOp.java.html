<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PendingAddOp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">PendingAddOp.java</span></div><h1>PendingAddOp.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.bookkeeper.proto.BookieProtocol.FLAG_HIGH_PRIORITY;
import static org.apache.bookkeeper.proto.BookieProtocol.FLAG_NONE;
import static org.apache.bookkeeper.proto.BookieProtocol.FLAG_RECOVERY_ADD;

import com.google.common.collect.ImmutableMap;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.netty.buffer.ByteBuf;
import io.netty.util.Recycler;
import io.netty.util.Recycler.Handle;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.ReferenceCounted;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.apache.bookkeeper.client.AsyncCallback.AddCallbackWithLatency;
import org.apache.bookkeeper.client.api.WriteFlag;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.util.MathUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This represents a pending add operation. When it has got success from all
 * bookies, it sees if its at the head of the pending adds queue, and if yes,
 * sends ack back to the application. If a bookie fails, a replacement is made
 * and placed at the same position in the ensemble. The pending adds are then
 * rereplicated.
 *
 *
 */
class PendingAddOp implements WriteCallback {
<span class="nc" id="L56">    private static final Logger LOG = LoggerFactory.getLogger(PendingAddOp.class);</span>

    ByteBuf payload;
    ReferenceCounted toSend;
    AddCallbackWithLatency cb;
    Object ctx;
    long entryId;
    int entryLength;

    DistributionSchedule.AckSet ackSet;
<span class="nc" id="L66">    boolean completed = false;</span>

    LedgerHandle lh;
    ClientContext clientCtx;
<span class="nc" id="L70">    boolean isRecoveryAdd = false;</span>
    volatile long requestTimeNanos;
    long qwcLatency; // Quorum Write Completion Latency after response from quorum bookies.
    Set&lt;BookieId&gt; addEntrySuccessBookies;
    long writeDelayedStartTime; // min fault domains completion latency after response from ack quorum bookies

    long currentLedgerLength;
    int pendingWriteRequests;
    boolean callbackTriggered;
    boolean hasRun;
    EnumSet&lt;WriteFlag&gt; writeFlags;
<span class="nc" id="L81">    boolean allowFailFast = false;</span>
    List&lt;BookieId&gt; ensemble;

    @SuppressFBWarnings(&quot;IS2_INCONSISTENT_SYNC&quot;)
    static PendingAddOp create(LedgerHandle lh, ClientContext clientCtx,
                               List&lt;BookieId&gt; ensemble,
                               ByteBuf payload, EnumSet&lt;WriteFlag&gt; writeFlags,
                               AddCallbackWithLatency cb, Object ctx) {
<span class="nc" id="L89">        PendingAddOp op = RECYCLER.get();</span>
<span class="nc" id="L90">        op.lh = lh;</span>
<span class="nc" id="L91">        op.clientCtx = clientCtx;</span>
<span class="nc" id="L92">        op.isRecoveryAdd = false;</span>
<span class="nc" id="L93">        op.cb = cb;</span>
<span class="nc" id="L94">        op.ctx = ctx;</span>
<span class="nc" id="L95">        op.entryId = LedgerHandle.INVALID_ENTRY_ID;</span>
<span class="nc" id="L96">        op.currentLedgerLength = -1;</span>
<span class="nc" id="L97">        op.payload = payload;</span>
<span class="nc" id="L98">        op.entryLength = payload.readableBytes();</span>

<span class="nc" id="L100">        op.completed = false;</span>
<span class="nc" id="L101">        op.ensemble = ensemble;</span>
<span class="nc" id="L102">        op.ackSet = lh.getDistributionSchedule().getAckSet();</span>
<span class="nc" id="L103">        op.pendingWriteRequests = 0;</span>
<span class="nc" id="L104">        op.callbackTriggered = false;</span>
<span class="nc" id="L105">        op.hasRun = false;</span>
<span class="nc" id="L106">        op.requestTimeNanos = Long.MAX_VALUE;</span>
<span class="nc" id="L107">        op.allowFailFast = false;</span>
<span class="nc" id="L108">        op.qwcLatency = 0;</span>
<span class="nc" id="L109">        op.writeFlags = writeFlags;</span>

<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (op.addEntrySuccessBookies == null) {</span>
<span class="nc" id="L112">            op.addEntrySuccessBookies = new HashSet&lt;&gt;();</span>
        } else {
<span class="nc" id="L114">            op.addEntrySuccessBookies.clear();</span>
        }
<span class="nc" id="L116">        op.writeDelayedStartTime = -1;</span>

<span class="nc" id="L118">        return op;</span>
    }

    /**
     * Enable the recovery add flag for this operation.
     * @see LedgerHandle#asyncRecoveryAddEntry
     */
    PendingAddOp enableRecoveryAdd() {
<span class="nc" id="L126">        isRecoveryAdd = true;</span>
<span class="nc" id="L127">        return this;</span>
    }

    PendingAddOp allowFailFastOnUnwritableChannel() {
<span class="nc" id="L131">        allowFailFast = true;</span>
<span class="nc" id="L132">        return this;</span>
    }

    void setEntryId(long entryId) {
<span class="nc" id="L136">        this.entryId = entryId;</span>
<span class="nc" id="L137">    }</span>

    void setLedgerLength(long ledgerLength) {
<span class="nc" id="L140">        this.currentLedgerLength = ledgerLength;</span>
<span class="nc" id="L141">    }</span>

    long getEntryId() {
<span class="nc" id="L144">        return this.entryId;</span>
    }

    private void sendWriteRequest(List&lt;BookieId&gt; ensemble, int bookieIndex) {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        int flags = isRecoveryAdd ? FLAG_RECOVERY_ADD | FLAG_HIGH_PRIORITY : FLAG_NONE;</span>

<span class="nc" id="L150">        clientCtx.getBookieClient().addEntry(ensemble.get(bookieIndex),</span>
<span class="nc" id="L151">                                             lh.ledgerId, lh.ledgerKey, entryId, toSend, this, bookieIndex,</span>
                                             flags, allowFailFast, lh.writeFlags);
<span class="nc" id="L153">        ++pendingWriteRequests;</span>
<span class="nc" id="L154">    }</span>

    boolean maybeTimeout() {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (MathUtils.elapsedNanos(requestTimeNanos) &gt;= clientCtx.getConf().addEntryQuorumTimeoutNanos) {</span>
<span class="nc" id="L158">            timeoutQuorumWait();</span>
<span class="nc" id="L159">            return true;</span>
        }
<span class="nc" id="L161">        return false;</span>
    }

    synchronized void timeoutQuorumWait() {
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (completed) {</span>
<span class="nc" id="L166">            return;</span>
        }

<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (addEntrySuccessBookies.size() &gt;= lh.getLedgerMetadata().getAckQuorumSize()) {</span>
            // If ackQuorum number of bookies have acknowledged the write but still not complete, indicates
            // failures due to not having been written to enough fault domains. Increment corresponding
            // counter.
<span class="nc" id="L173">            clientCtx.getClientStats().getWriteTimedOutDueToNotEnoughFaultDomains().inc();</span>
        }

<span class="nc" id="L176">        lh.handleUnrecoverableErrorDuringAdd(BKException.Code.AddEntryQuorumTimeoutException);</span>
<span class="nc" id="L177">    }</span>

    synchronized void unsetSuccessAndSendWriteRequest(List&lt;BookieId&gt; ensemble, int bookieIndex) {
        // update the ensemble
<span class="nc" id="L181">        this.ensemble = ensemble;</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (toSend == null) {</span>
            // this addOp hasn't yet had its mac computed. When the mac is
            // computed, its write requests will be sent, so no need to send it
            // now
<span class="nc" id="L187">            return;</span>
        }
        // Suppose that unset doesn't happen on the write set of an entry. In this
        // case we don't need to resend the write request upon an ensemble change.
        // We do need to invoke #sendAddSuccessCallbacks() for such entries because
        // they may have already completed, but they are just waiting for the ensemble
        // to change.
        // E.g.
        // ensemble (A, B, C, D), entry k is written to (A, B, D). An ensemble change
        // happens to replace C with E. Entry k does not complete until C is
        // replaced with E successfully. When the ensemble change completes, it tries
        // to unset entry k. C however is not in k's write set, so no entry is written
        // again, and no one triggers #sendAddSuccessCallbacks. Consequently, k never
        // completes.
        //
        // We call sendAddSuccessCallback when unsetting t cover this case.
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (!lh.distributionSchedule.hasEntry(entryId, bookieIndex)) {</span>
<span class="nc" id="L204">            lh.sendAddSuccessCallbacks();</span>
<span class="nc" id="L205">            return;</span>
        }

<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (callbackTriggered) {</span>
<span class="nc" id="L209">            return;</span>
        }

<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L213">            LOG.debug(&quot;Unsetting success for ledger: &quot; + lh.ledgerId + &quot; entry: &quot; + entryId + &quot; bookie index: &quot;</span>
                      + bookieIndex);
        }

        // if we had already heard a success from this array index, need to
        // increment our number of responses that are pending, since we are
        // going to unset this success
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (!ackSet.removeBookieAndCheck(bookieIndex)) {</span>
            // unset completed if this results in loss of ack quorum
<span class="nc" id="L222">            completed = false;</span>
        }

<span class="nc" id="L225">        sendWriteRequest(ensemble, bookieIndex);</span>
<span class="nc" id="L226">    }</span>

    /**
     * Initiate the add operation.
     */
    public synchronized void initiate() {
<span class="nc" id="L232">        hasRun = true;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (callbackTriggered) {</span>
            // this should only be true if the request was failed due
            // to another request ahead in the pending queue,
            // so we can just ignore this request
<span class="nc" id="L237">            maybeRecycle();</span>
<span class="nc" id="L238">            return;</span>
        }

<span class="nc" id="L241">        this.requestTimeNanos = MathUtils.nowInNano();</span>
<span class="nc" id="L242">        checkNotNull(lh);</span>
<span class="nc" id="L243">        checkNotNull(lh.macManager);</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">        int flags = isRecoveryAdd ? FLAG_RECOVERY_ADD | FLAG_HIGH_PRIORITY : FLAG_NONE;</span>
<span class="nc" id="L246">        this.toSend = lh.macManager.computeDigestAndPackageForSending(</span>
                entryId, lh.lastAddConfirmed, currentLedgerLength,
                payload, lh.ledgerKey, flags);
        // ownership of RefCounted ByteBuf was passed to computeDigestAndPackageForSending
<span class="nc" id="L250">        payload = null;</span>

        // We are about to send. Check if we need to make an ensemble change
        // because of delayed write errors
<span class="nc" id="L254">        lh.maybeHandleDelayedWriteBookieFailure();</span>

        // Iterate over set and trigger the sendWriteRequests
<span class="nc bnc" id="L257" title="All 2 branches missed.">        for (int i = 0; i &lt; lh.distributionSchedule.getWriteQuorumSize(); i++) {</span>
<span class="nc" id="L258">            sendWriteRequest(ensemble, lh.distributionSchedule.getWriteSetBookieIndex(entryId, i));</span>
        }
<span class="nc" id="L260">    }</span>

    @Override
    public synchronized void writeComplete(int rc, long ledgerId, long entryId, BookieId addr, Object ctx) {
<span class="nc" id="L264">        int bookieIndex = (Integer) ctx;</span>
<span class="nc" id="L265">        --pendingWriteRequests;</span>

<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (!ensemble.get(bookieIndex).equals(addr)) {</span>
            // ensemble has already changed, failure of this addr is immaterial
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L270">                LOG.debug(&quot;Write did not succeed: &quot; + ledgerId + &quot;, &quot; + entryId + &quot;. But we have already fixed it.&quot;);</span>
            }
<span class="nc" id="L272">            return;</span>
        }

        // must record all acks, even if complete (completion can be undone by an ensemble change)
<span class="nc" id="L276">        boolean ackQuorum = false;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (BKException.Code.OK == rc) {</span>
<span class="nc" id="L278">            ackQuorum = ackSet.completeBookieAndCheck(bookieIndex);</span>
<span class="nc" id="L279">            addEntrySuccessBookies.add(ensemble.get(bookieIndex));</span>
        }

<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (completed) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
                // Got an error after satisfying AQ. This means we are under replicated at the create itself.
                // Update the stat to reflect it.
<span class="nc" id="L286">                clientCtx.getClientStats().getAddOpUrCounter().inc();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (!clientCtx.getConf().disableEnsembleChangeFeature.isAvailable()</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                        &amp;&amp; !clientCtx.getConf().delayEnsembleChange) {</span>
<span class="nc" id="L289">                    lh.notifyWriteFailed(bookieIndex, addr);</span>
                }
            }
            // even the add operation is completed, but because we don't reset completed flag back to false when
            // #unsetSuccessAndSendWriteRequest doesn't break ack quorum constraint. we still have current pending
            // add op is completed but never callback. so do a check here to complete again.
            //
            // E.g. entry x is going to complete.
            //
            // 1) entry x + k hits a failure. lh.handleBookieFailure increases blockAddCompletions to 1, for ensemble
            //    change
            // 2) entry x receives all responses, sets completed to true but fails to send success callback because
            //    blockAddCompletions is 1
            // 3) ensemble change completed. lh unset success starting from x to x+k, but since the unset doesn't break
            //    ackSet constraint. #removeBookieAndCheck doesn't set completed back to false.
            // 4) so when the retry request on new bookie completes, it finds the pending op is already completed.
            //    we have to trigger #sendAddSuccessCallbacks
            //
<span class="nc" id="L307">            sendAddSuccessCallbacks();</span>
            // I am already finished, ignore incoming responses.
            // otherwise, we might hit the following error handling logic, which might cause bad things.
<span class="nc" id="L310">            maybeRecycle();</span>
<span class="nc" id="L311">            return;</span>
        }

<span class="nc bnc" id="L314" title="All 6 branches missed.">        switch (rc) {</span>
        case BKException.Code.OK:
            // continue
<span class="nc" id="L317">            break;</span>
        case BKException.Code.ClientClosedException:
            // bookie client is closed.
<span class="nc" id="L320">            lh.errorOutPendingAdds(rc);</span>
<span class="nc" id="L321">            return;</span>
        case BKException.Code.IllegalOpException:
            // illegal operation requested, like using unsupported feature in v2 protocol
<span class="nc" id="L324">            lh.handleUnrecoverableErrorDuringAdd(rc);</span>
<span class="nc" id="L325">            return;</span>
        case BKException.Code.LedgerFencedException:
<span class="nc" id="L327">            LOG.warn(&quot;Fencing exception on write: L{} E{} on {}&quot;,</span>
<span class="nc" id="L328">                    ledgerId, entryId, addr);</span>
<span class="nc" id="L329">            lh.handleUnrecoverableErrorDuringAdd(rc);</span>
<span class="nc" id="L330">            return;</span>
        case BKException.Code.UnauthorizedAccessException:
<span class="nc" id="L332">            LOG.warn(&quot;Unauthorized access exception on write: L{} E{} on {}&quot;,</span>
<span class="nc" id="L333">                    ledgerId, entryId, addr);</span>
<span class="nc" id="L334">            lh.handleUnrecoverableErrorDuringAdd(rc);</span>
<span class="nc" id="L335">            return;</span>
        default:
<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (clientCtx.getConf().delayEnsembleChange) {</span>
<span class="nc bnc" id="L338" title="All 4 branches missed.">                if (ackSet.failBookieAndCheck(bookieIndex, addr)</span>
                        || rc == BKException.Code.WriteOnReadOnlyBookieException) {
<span class="nc" id="L340">                    Map&lt;Integer, BookieId&gt; failedBookies = ackSet.getFailedBookies();</span>
<span class="nc" id="L341">                    LOG.warn(&quot;Failed to write entry ({}, {}) to bookies {}, handling failures.&quot;,</span>
<span class="nc" id="L342">                            ledgerId, entryId, failedBookies);</span>
                    // we can't meet ack quorum requirement, trigger ensemble change.
<span class="nc" id="L344">                    lh.handleBookieFailure(failedBookies);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                } else if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L346">                    LOG.debug(&quot;Failed to write entry ({}, {}) to bookie ({}, {}),&quot;</span>
                                    + &quot; but it didn't break ack quorum, delaying ensemble change : {}&quot;,
<span class="nc" id="L348">                            ledgerId, entryId, bookieIndex, addr, BKException.getMessage(rc));</span>
                }
            } else {
<span class="nc" id="L351">                LOG.warn(&quot;Failed to write entry ({}, {}) to bookie ({}, {}): {}&quot;,</span>
<span class="nc" id="L352">                        ledgerId, entryId, bookieIndex, addr, BKException.getMessage(rc));</span>
<span class="nc" id="L353">                lh.handleBookieFailure(ImmutableMap.of(bookieIndex, addr));</span>
            }
<span class="nc" id="L355">            return;</span>
        }

<span class="nc bnc" id="L358" title="All 4 branches missed.">        if (ackQuorum &amp;&amp; !completed) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (clientCtx.getConf().enforceMinNumFaultDomainsForWrite</span>
<span class="nc" id="L360">                &amp;&amp; !(clientCtx.getPlacementPolicy()</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                              .areAckedBookiesAdheringToPlacementPolicy(addEntrySuccessBookies,</span>
<span class="nc" id="L362">                                                                        lh.getLedgerMetadata().getWriteQuorumSize(),</span>
<span class="nc" id="L363">                                                                        lh.getLedgerMetadata().getAckQuorumSize()))) {</span>
<span class="nc" id="L364">                LOG.warn(&quot;Write success for entry ID {} delayed, not acknowledged by bookies in enough fault domains&quot;,</span>
<span class="nc" id="L365">                         entryId);</span>
                // Increment to indicate write did not complete due to not enough fault domains
<span class="nc" id="L367">                clientCtx.getClientStats().getWriteDelayedDueToNotEnoughFaultDomains().inc();</span>

                // Only do this for the first time.
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (writeDelayedStartTime == -1) {</span>
<span class="nc" id="L371">                    writeDelayedStartTime = MathUtils.nowInNano();</span>
                }
            } else {
<span class="nc" id="L374">                completed = true;</span>
<span class="nc" id="L375">                this.qwcLatency = MathUtils.elapsedNanos(requestTimeNanos);</span>

<span class="nc bnc" id="L377" title="All 2 branches missed.">                if (writeDelayedStartTime != -1) {</span>
<span class="nc" id="L378">                    clientCtx.getClientStats()</span>
<span class="nc" id="L379">                             .getWriteDelayedDueToNotEnoughFaultDomainsLatency()</span>
<span class="nc" id="L380">                             .registerSuccessfulEvent(MathUtils.elapsedNanos(writeDelayedStartTime),</span>
                                                      TimeUnit.NANOSECONDS);
                }

<span class="nc" id="L384">                sendAddSuccessCallbacks();</span>
            }
        }
<span class="nc" id="L387">    }</span>

    void sendAddSuccessCallbacks() {
<span class="nc" id="L390">        lh.sendAddSuccessCallbacks();</span>
<span class="nc" id="L391">    }</span>

    synchronized void submitCallback(final int rc) {
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L395">            LOG.debug(&quot;Submit callback (lid:{}, eid: {}). rc:{}&quot;, lh.getId(), entryId, rc);</span>
        }

<span class="nc" id="L398">        long latencyNanos = MathUtils.elapsedNanos(requestTimeNanos);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L400">            clientCtx.getClientStats().getAddOpLogger().registerFailedEvent(latencyNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L401">            LOG.error(&quot;Write of ledger entry to quorum failed: L{} E{}&quot;,</span>
<span class="nc" id="L402">                      lh.getId(), entryId);</span>
        } else {
<span class="nc" id="L404">            clientCtx.getClientStats().getAddOpLogger().registerSuccessfulEvent(latencyNanos, TimeUnit.NANOSECONDS);</span>
        }
<span class="nc" id="L406">        cb.addCompleteWithLatency(rc, lh, entryId, qwcLatency, ctx);</span>
<span class="nc" id="L407">        callbackTriggered = true;</span>

<span class="nc" id="L409">        maybeRecycle();</span>
<span class="nc" id="L410">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L414">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L415">        sb.append(&quot;PendingAddOp(lid:&quot;).append(lh.ledgerId)</span>
<span class="nc" id="L416">          .append(&quot;, eid:&quot;).append(entryId).append(&quot;, completed:&quot;)</span>
<span class="nc" id="L417">          .append(completed).append(&quot;)&quot;);</span>
<span class="nc" id="L418">        return sb.toString();</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L423">        return (int) entryId;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L428" title="All 2 branches missed.">       if (o instanceof PendingAddOp) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">           return (this.entryId == ((PendingAddOp) o).entryId);</span>
       }
<span class="nc bnc" id="L431" title="All 2 branches missed.">       return (this == o);</span>
    }

    private final Handle&lt;PendingAddOp&gt; recyclerHandle;
<span class="nc" id="L435">    private static final Recycler&lt;PendingAddOp&gt; RECYCLER = new Recycler&lt;PendingAddOp&gt;() {</span>
        @Override
        protected PendingAddOp newObject(Recycler.Handle&lt;PendingAddOp&gt; handle) {
<span class="nc" id="L438">            return new PendingAddOp(handle);</span>
        }
    };

<span class="nc" id="L442">    private PendingAddOp(Handle&lt;PendingAddOp&gt; recyclerHandle) {</span>
<span class="nc" id="L443">        this.recyclerHandle = recyclerHandle;</span>
<span class="nc" id="L444">    }</span>


    private synchronized void maybeRecycle() {
        /**
         * We have opportunity to recycle two objects here.
         * PendingAddOp#toSend and LedgerHandle#pendingAddOp
         *
         * A. LedgerHandle#pendingAddOp: This can be released after all 3 conditions are met.
         *    - After the callback is run
         *    - After safeRun finished by the executor
         *    - Write responses are returned from all bookies
         *      as BookieClient Holds a reference from the point the addEntry requests are sent.
         *
         * B. ByteBuf can be released after 2 of the conditions are met.
         *    - After the callback is run as we will not retry the write after callback
         *    - After safeRun finished by the executor
         * BookieClient takes and releases on this buffer immediately after sending the data.
         *
         * The object can only be recycled after the above conditions are met
         * otherwise we could end up recycling twice and all
         * joy that goes along with that.
         */
<span class="nc bnc" id="L467" title="All 4 branches missed.">        if (hasRun &amp;&amp; callbackTriggered) {</span>
<span class="nc" id="L468">            ReferenceCountUtil.release(toSend);</span>
<span class="nc" id="L469">            toSend = null;</span>
        }
        // only recycle a pending add op after it has been run.
<span class="nc bnc" id="L472" title="All 6 branches missed.">        if (hasRun &amp;&amp; toSend == null &amp;&amp; pendingWriteRequests == 0) {</span>
<span class="nc" id="L473">            recyclePendAddOpObject();</span>
        }
<span class="nc" id="L475">    }</span>

    public synchronized void recyclePendAddOpObject() {
<span class="nc" id="L478">        entryId = LedgerHandle.INVALID_ENTRY_ID;</span>
<span class="nc" id="L479">        currentLedgerLength = -1;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (payload != null) {</span>
<span class="nc" id="L481">            ReferenceCountUtil.release(payload);</span>
<span class="nc" id="L482">            payload = null;</span>
        }
<span class="nc" id="L484">        cb = null;</span>
<span class="nc" id="L485">        ctx = null;</span>
<span class="nc" id="L486">        ensemble = null;</span>
<span class="nc" id="L487">        ackSet.recycle();</span>
<span class="nc" id="L488">        ackSet = null;</span>
<span class="nc" id="L489">        lh = null;</span>
<span class="nc" id="L490">        clientCtx = null;</span>
<span class="nc" id="L491">        isRecoveryAdd = false;</span>
<span class="nc" id="L492">        completed = false;</span>
<span class="nc" id="L493">        pendingWriteRequests = 0;</span>
<span class="nc" id="L494">        callbackTriggered = false;</span>
<span class="nc" id="L495">        hasRun = false;</span>
<span class="nc" id="L496">        allowFailFast = false;</span>
<span class="nc" id="L497">        writeFlags = null;</span>
<span class="nc" id="L498">        addEntrySuccessBookies.clear();</span>
<span class="nc" id="L499">        writeDelayedStartTime = -1;</span>

<span class="nc" id="L501">        recyclerHandle.recycle(this);</span>
<span class="nc" id="L502">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>