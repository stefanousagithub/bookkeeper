<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BookieProtoEncoding.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.proto</a> &gt; <span class="el_source">BookieProtoEncoding.java</span></div><h1>BookieProtoEncoding.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.proto;

import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLite;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.ByteBufInputStream;
import io.netty.buffer.ByteBufOutputStream;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.util.ReferenceCountUtil;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;
import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;
import org.apache.bookkeeper.proto.checksum.MacDigestManager;
import org.apache.bookkeeper.util.ByteBufList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A class for encoding and decoding the Bookkeeper protocol.
 */
<span class="nc" id="L50">public class BookieProtoEncoding {</span>
<span class="nc" id="L51">    private static final Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);</span>

    /**
     * Threshold under which an entry is considered to be &quot;small&quot;.
     *
     * Small entries payloads are copied instead of being passed around as references.
     */
    public static final int SMALL_ENTRY_SIZE_THRESHOLD = 16 * 1024;

    /**
     * An encoder/decoder interface for the Bookkeeper protocol.
     */
    public interface EnDecoder {
        /**
         * Encode a &lt;i&gt;object&lt;/i&gt; into channel buffer.
         *
         * @param object
         *          object.
         * @return encode buffer.
         * @throws Exception
         */
        Object encode(Object object, ByteBufAllocator allocator) throws Exception;

        /**
         * Decode a &lt;i&gt;packet&lt;/i&gt; into an object.
         *
         * @param packet
         *          received packet.
         * @return parsed object.
         * @throws Exception
         */
        Object decode(ByteBuf packet) throws Exception;

    }

    /**
     * An encoder/decoder for the Bookkeeper protocol before version 3.
     */
    public static class RequestEnDeCoderPreV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

        //This empty master key is used when an empty password is provided which is the hash of an empty string
        private static final byte[] emptyPasswordMasterKey;
        static {
            try {
<span class="nc" id="L96">                emptyPasswordMasterKey = MacDigestManager.genDigest(&quot;ledger&quot;, new byte[0]);</span>
<span class="nc" id="L97">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L98">                throw new RuntimeException(e);</span>
<span class="nc" id="L99">            }</span>
<span class="nc" id="L100">        }</span>

<span class="nc" id="L102">        public RequestEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L103">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L104">        }</span>

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator)
                throws Exception {
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (!(msg instanceof BookieProtocol.Request)) {</span>
<span class="nc" id="L110">                return msg;</span>
            }
<span class="nc" id="L112">            BookieProtocol.Request r = (BookieProtocol.Request) msg;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (r instanceof BookieProtocol.ReadRequest) {</span>
<span class="nc" id="L114">                int totalHeaderSize = 4 // for request type</span>
                    + 8 // for ledgerId
                    + 8; // for entryId
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L118">                    totalHeaderSize += BookieProtocol.MASTER_KEY_LENGTH;</span>
                }

<span class="nc" id="L121">                ByteBuf buf = allocator.buffer(totalHeaderSize + 4 /* frame size */);</span>
<span class="nc" id="L122">                buf.writeInt(totalHeaderSize);</span>
<span class="nc" id="L123">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L124">                buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L125">                buf.writeLong(r.getEntryId());</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L127">                    buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
                }
<span class="nc" id="L129">                r.recycle();</span>
<span class="nc" id="L130">                return buf;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            } else if (r instanceof BookieProtocol.AuthRequest) {</span>
<span class="nc" id="L132">                BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthRequest) r).getAuthMessage();</span>
<span class="nc" id="L133">                int totalHeaderSize = 4; // for request type</span>
<span class="nc" id="L134">                int totalSize = totalHeaderSize + am.getSerializedSize();</span>
<span class="nc" id="L135">                ByteBuf buf = allocator.buffer(totalSize + 4 /* frame size */);</span>
<span class="nc" id="L136">                buf.writeInt(totalSize);</span>
<span class="nc" id="L137">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L138">                ByteBufOutputStream bufStream = new ByteBufOutputStream(buf);</span>
<span class="nc" id="L139">                am.writeTo(bufStream);</span>
<span class="nc" id="L140">                return buf;</span>
            } else {
<span class="nc" id="L142">                return msg;</span>
            }
        }

        @Override
        public Object decode(ByteBuf packet)
                throws Exception {
<span class="nc" id="L149">            int packetHeader = packet.readInt();</span>
<span class="nc" id="L150">            byte version = PacketHeader.getVersion(packetHeader);</span>
<span class="nc" id="L151">            byte opCode = PacketHeader.getOpCode(packetHeader);</span>
<span class="nc" id="L152">            short flags = PacketHeader.getFlags(packetHeader);</span>

            // packet format is different between ADDENTRY and READENTRY
<span class="nc" id="L155">            long ledgerId = -1;</span>
<span class="nc" id="L156">            long entryId = BookieProtocol.INVALID_ENTRY_ID;</span>

<span class="nc bnc" id="L158" title="All 4 branches missed.">            switch (opCode) {</span>
            case BookieProtocol.ADDENTRY: {
<span class="nc" id="L160">                byte[] masterKey = readMasterKey(packet);</span>

                // Read ledger and entry id without advancing the reader index
<span class="nc" id="L163">                ledgerId = packet.getLong(packet.readerIndex());</span>
<span class="nc" id="L164">                entryId = packet.getLong(packet.readerIndex() + 8);</span>
                // mark the reader index so that any resets will return to the
                // start of the payload
<span class="nc" id="L167">                packet.markReaderIndex();</span>
<span class="nc" id="L168">                return BookieProtocol.ParsedAddRequest.create(</span>
                        version, ledgerId, entryId, flags,
                        masterKey, packet);
            }

            case BookieProtocol.READENTRY:
<span class="nc" id="L174">                ledgerId = packet.readLong();</span>
<span class="nc" id="L175">                entryId = packet.readLong();</span>

<span class="nc bnc" id="L177" title="All 4 branches missed.">                if ((flags &amp; BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING</span>
                    &amp;&amp; version &gt;= 2) {
<span class="nc" id="L179">                    byte[] masterKey = readMasterKey(packet);</span>
<span class="nc" id="L180">                    return BookieProtocol.ReadRequest.create(version, ledgerId, entryId, flags, masterKey);</span>
                } else {
<span class="nc" id="L182">                    return BookieProtocol.ReadRequest.create(version, ledgerId, entryId, flags, null);</span>
                }
            case BookieProtocol.AUTH:
<span class="nc" id="L185">                BookkeeperProtocol.AuthMessage.Builder builder = BookkeeperProtocol.AuthMessage.newBuilder();</span>
<span class="nc" id="L186">                builder.mergeFrom(new ByteBufInputStream(packet), extensionRegistry);</span>
<span class="nc" id="L187">                return new BookieProtocol.AuthRequest(version, builder.build());</span>

            default:
<span class="nc" id="L190">                throw new IllegalStateException(&quot;Received unknown request op code = &quot; + opCode);</span>
            }
        }

        private static byte[] readMasterKey(ByteBuf packet) {
<span class="nc" id="L195">            byte[] masterKey = null;</span>

            // check if the master key is an empty master key
<span class="nc" id="L198">            boolean isEmptyKey = true;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            for (int i = 0; i &lt; BookieProtocol.MASTER_KEY_LENGTH; i++) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if (packet.getByte(packet.readerIndex() + i) != emptyPasswordMasterKey[i]) {</span>
<span class="nc" id="L201">                    isEmptyKey = false;</span>
<span class="nc" id="L202">                    break;</span>
                }
            }

<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (isEmptyKey) {</span>
                // avoid new allocations if incoming master key is empty and use the static master key
<span class="nc" id="L208">                masterKey = emptyPasswordMasterKey;</span>
<span class="nc" id="L209">                packet.readerIndex(packet.readerIndex() + BookieProtocol.MASTER_KEY_LENGTH);</span>
            } else {
                // Master key is set, we need to copy and check it
<span class="nc" id="L212">                masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];</span>
<span class="nc" id="L213">                packet.readBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
            }

<span class="nc" id="L216">            return masterKey;</span>
        }
    }

    /**
     * A response encoder/decoder for the Bookkeeper protocol before version 3.
     */
    public static class ResponseEnDeCoderPreV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="nc" id="L226">        public ResponseEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L227">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L228">        }</span>

        private static final int RESPONSE_HEADERS_SIZE = 24;

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator)
                throws Exception {
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (!(msg instanceof BookieProtocol.Response)) {</span>
<span class="nc" id="L236">                return msg;</span>
            }
<span class="nc" id="L238">            BookieProtocol.Response r = (BookieProtocol.Response) msg;</span>

            try {
<span class="nc bnc" id="L241" title="All 2 branches missed.">                if (msg instanceof BookieProtocol.ReadResponse) {</span>
<span class="nc" id="L242">                    BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse) r;</span>
<span class="nc" id="L243">                    int payloadSize = rr.getData().readableBytes();</span>
<span class="nc" id="L244">                    int responseSize = RESPONSE_HEADERS_SIZE + payloadSize;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                    boolean isSmallEntry = payloadSize &lt; SMALL_ENTRY_SIZE_THRESHOLD;</span>

<span class="nc" id="L247">                    int bufferSize = 4 /* frame size */ + RESPONSE_HEADERS_SIZE</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                            + (isSmallEntry ? payloadSize : 0);</span>
<span class="nc" id="L249">                    ByteBuf buf = allocator.buffer(bufferSize);</span>
<span class="nc" id="L250">                    buf.writeInt(responseSize);</span>
<span class="nc" id="L251">                    buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>
<span class="nc" id="L252">                    buf.writeInt(r.getErrorCode());</span>
<span class="nc" id="L253">                    buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L254">                    buf.writeLong(r.getEntryId());</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">                    if (isSmallEntry) {</span>
<span class="nc" id="L257">                        buf.writeBytes(rr.getData());</span>
<span class="nc" id="L258">                        rr.release();</span>
<span class="nc" id="L259">                        return buf;</span>
                    } else {
<span class="nc" id="L261">                        return ByteBufList.get(buf, rr.getData());</span>
                    }
<span class="nc bnc" id="L263" title="All 2 branches missed.">                } else if (msg instanceof BookieProtocol.AddResponse) {</span>
<span class="nc" id="L264">                    ByteBuf buf = allocator.buffer(RESPONSE_HEADERS_SIZE + 4 /* frame size */);</span>
<span class="nc" id="L265">                    buf.writeInt(RESPONSE_HEADERS_SIZE);</span>
<span class="nc" id="L266">                    buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>
<span class="nc" id="L267">                    buf.writeInt(r.getErrorCode());</span>
<span class="nc" id="L268">                    buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L269">                    buf.writeLong(r.getEntryId());</span>
<span class="nc" id="L270">                    return buf;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                } else if (msg instanceof BookieProtocol.AuthResponse) {</span>
<span class="nc" id="L272">                    BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthResponse) r).getAuthMessage();</span>
<span class="nc" id="L273">                    int payloadSize = 4 + am.getSerializedSize();</span>
<span class="nc" id="L274">                    int bufferSize = payloadSize + 4 /* frame size */;</span>

<span class="nc" id="L276">                    ByteBuf buf = allocator.buffer(bufferSize);</span>
<span class="nc" id="L277">                    buf.writeInt(payloadSize);</span>
<span class="nc" id="L278">                    buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>
<span class="nc" id="L279">                    buf.writeBytes(am.toByteArray());</span>
<span class="nc" id="L280">                    return buf;</span>
                } else {
<span class="nc" id="L282">                    LOG.error(&quot;Cannot encode unknown response type {}&quot;, msg.getClass().getName());</span>
<span class="nc" id="L283">                    return msg;</span>
                }
            } finally {
<span class="nc" id="L286">                r.recycle();</span>
            }
        }
        @Override
        public Object decode(ByteBuf buffer)
                throws Exception {
            int rc;
            long ledgerId, entryId;

<span class="nc" id="L295">            int packetHeader = buffer.readInt();</span>
<span class="nc" id="L296">            byte version = PacketHeader.getVersion(packetHeader);</span>
<span class="nc" id="L297">            byte opCode = PacketHeader.getOpCode(packetHeader);</span>

<span class="nc bnc" id="L299" title="All 4 branches missed.">            switch (opCode) {</span>
            case BookieProtocol.ADDENTRY:
<span class="nc" id="L301">                rc = buffer.readInt();</span>
<span class="nc" id="L302">                ledgerId = buffer.readLong();</span>
<span class="nc" id="L303">                entryId = buffer.readLong();</span>
<span class="nc" id="L304">                return BookieProtocol.AddResponse.create(version, rc, ledgerId, entryId);</span>
            case BookieProtocol.READENTRY:
<span class="nc" id="L306">                rc = buffer.readInt();</span>
<span class="nc" id="L307">                ledgerId = buffer.readLong();</span>
<span class="nc" id="L308">                entryId = buffer.readLong();</span>

<span class="nc" id="L310">                return new BookieProtocol.ReadResponse(</span>
<span class="nc" id="L311">                        version, rc, ledgerId, entryId, buffer.retainedSlice());</span>
            case BookieProtocol.AUTH:
<span class="nc" id="L313">                ByteBufInputStream bufStream = new ByteBufInputStream(buffer);</span>
<span class="nc" id="L314">                BookkeeperProtocol.AuthMessage.Builder builder = BookkeeperProtocol.AuthMessage.newBuilder();</span>
<span class="nc" id="L315">                builder.mergeFrom(bufStream, extensionRegistry);</span>
<span class="nc" id="L316">                BookkeeperProtocol.AuthMessage am = builder.build();</span>
<span class="nc" id="L317">                return new BookieProtocol.AuthResponse(version, am);</span>
            default:
<span class="nc" id="L319">                throw new IllegalStateException(&quot;Received unknown response : op code = &quot; + opCode);</span>
            }
        }

        public static void serializeAddResponseInto(int rc, BookieProtocol.ParsedAddRequest req, ByteBuf buf) {
<span class="nc" id="L324">            buf.writeInt(RESPONSE_HEADERS_SIZE); // Frame size</span>
<span class="nc" id="L325">            buf.writeInt(PacketHeader.toInt(req.getProtocolVersion(), req.getOpCode(), (short) 0));</span>
<span class="nc" id="L326">            buf.writeInt(rc); // rc-code</span>
<span class="nc" id="L327">            buf.writeLong(req.getLedgerId());</span>
<span class="nc" id="L328">            buf.writeLong(req.getEntryId());</span>
<span class="nc" id="L329">        }</span>
    }

    /**
     * A request encoder/decoder for the Bookkeeper protocol version 3.
     */
    public static class RequestEnDecoderV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="nc" id="L338">        public RequestEnDecoderV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L339">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L340">        }</span>

        @Override
        public Object decode(ByteBuf packet) throws Exception {
<span class="nc" id="L344">            return BookkeeperProtocol.Request.parseFrom(new ByteBufInputStream(packet), extensionRegistry);</span>
        }

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {
<span class="nc" id="L349">            BookkeeperProtocol.Request request = (BookkeeperProtocol.Request) msg;</span>
<span class="nc" id="L350">            return serializeProtobuf(request, allocator);</span>
        }

    }

    /**
     * A response encoder/decoder for the Bookkeeper protocol version 3.
     */
    public static class ResponseEnDecoderV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="nc" id="L361">        public ResponseEnDecoderV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L362">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L363">        }</span>

        @Override
        public Object decode(ByteBuf packet) throws Exception {
<span class="nc" id="L367">            return BookkeeperProtocol.Response.parseFrom(new ByteBufInputStream(packet),</span>
                                                         extensionRegistry);
        }

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {
<span class="nc" id="L373">            BookkeeperProtocol.Response response = (BookkeeperProtocol.Response) msg;</span>
<span class="nc" id="L374">            return serializeProtobuf(response, allocator);</span>
        }

    }

    private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) {
<span class="nc" id="L380">        int size = msg.getSerializedSize();</span>
<span class="nc" id="L381">        int frameSize = size + 4;</span>

        // Protobuf serialization is the last step of the netty pipeline. We used to allocate
        // a heap buffer while serializing and pass it down to netty library.
        // In AbstractChannel#filterOutboundMessage(), netty copies that data to a direct buffer if
        // it is currently in heap (otherwise skips it and uses it directly).
        // Allocating a direct buffer reducing unncessary CPU cycles for buffer copies in BK client
        // and also helps alleviate pressure off the GC, since there is less memory churn.
        // Bookies aren't usually CPU bound. This change improves READ_ENTRY code paths by a small factor as well.
<span class="nc" id="L390">        ByteBuf buf = allocator.directBuffer(frameSize, frameSize);</span>
<span class="nc" id="L391">        buf.writeInt(size);</span>

        try {
<span class="nc" id="L394">            msg.writeTo(CodedOutputStream.newInstance(buf.nioBuffer(buf.writerIndex(), size)));</span>
<span class="nc" id="L395">        } catch (IOException e) {</span>
            // This is in-memory serialization, should not fail
<span class="nc" id="L397">            throw new RuntimeException(e);</span>
<span class="nc" id="L398">        }</span>

        // Advance writer idx
<span class="nc" id="L401">        buf.writerIndex(frameSize);</span>
<span class="nc" id="L402">        return buf;</span>
    }

    /**
     * A request message encoder.
     */
    @Sharable
    public static class RequestEncoder extends ChannelOutboundHandlerAdapter {

        final EnDecoder reqPreV3;
        final EnDecoder reqV3;

<span class="nc" id="L414">        public RequestEncoder(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L415">            reqPreV3 = new RequestEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L416">            reqV3 = new RequestEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L417">        }</span>

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L422">                LOG.trace(&quot;Encode request {} to channel {}.&quot;, msg, ctx.channel());</span>
            }
<span class="nc bnc" id="L424" title="All 4 branches missed.">            if (msg instanceof ByteBuf || msg instanceof ByteBufList) {</span>
<span class="nc" id="L425">                ctx.write(msg, promise);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            } else if (msg instanceof BookkeeperProtocol.Request) {</span>
<span class="nc" id="L427">                ctx.write(reqV3.encode(msg, ctx.alloc()), promise);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            } else if (msg instanceof BookieProtocol.Request) {</span>
<span class="nc" id="L429">                ctx.write(reqPreV3.encode(msg, ctx.alloc()), promise);</span>
            } else {
<span class="nc" id="L431">                LOG.error(&quot;Invalid request to encode to {}: {}&quot;, ctx.channel(), msg.getClass().getName());</span>
<span class="nc" id="L432">                ctx.write(msg, promise);</span>
            }
<span class="nc" id="L434">        }</span>
    }

    /**
     * A request message decoder.
     */
    @Sharable
    public static class RequestDecoder extends ChannelInboundHandlerAdapter {
        final EnDecoder reqPreV3;
        final EnDecoder reqV3;
        boolean usingV3Protocol;

<span class="nc" id="L446">        RequestDecoder(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L447">            reqPreV3 = new RequestEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L448">            reqV3 = new RequestEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L449">            usingV3Protocol = true;</span>
<span class="nc" id="L450">        }</span>

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L455">                LOG.trace(&quot;Received request {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
            }
            try {
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (!(msg instanceof ByteBuf)) {</span>
<span class="nc" id="L459">                    LOG.error(&quot;Received invalid request {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
<span class="nc" id="L460">                    ctx.fireChannelRead(msg);</span>
<span class="nc" id="L461">                    return;</span>
                }
<span class="nc" id="L463">                ByteBuf buffer = (ByteBuf) msg;</span>
<span class="nc" id="L464">                buffer.markReaderIndex();</span>
                Object result;
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (usingV3Protocol) {</span>
                    try {
<span class="nc" id="L468">                        result = reqV3.decode(buffer);</span>
<span class="nc" id="L469">                    } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L470">                        usingV3Protocol = false;</span>
<span class="nc" id="L471">                        buffer.resetReaderIndex();</span>
<span class="nc" id="L472">                        result = reqPreV3.decode(buffer);</span>
<span class="nc" id="L473">                    }</span>
                } else {
<span class="nc" id="L475">                    result = reqPreV3.decode(buffer);</span>
                }
<span class="nc" id="L477">                ctx.fireChannelRead(result);</span>
            } finally {
<span class="nc" id="L479">                ReferenceCountUtil.release(msg);</span>
            }
<span class="nc" id="L481">        }</span>
    }

    /**
     * A response message encoder.
     */
    @Sharable
    public static class ResponseEncoder extends ChannelOutboundHandlerAdapter {
        final EnDecoder repPreV3;
        final EnDecoder repV3;

<span class="nc" id="L492">        ResponseEncoder(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L493">            repPreV3 = new ResponseEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L494">            repV3 = new ResponseEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L495">        }</span>

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L500">                LOG.trace(&quot;Encode response {} to channel {}.&quot;, msg, ctx.channel());</span>
            }

<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (msg instanceof ByteBuf) {</span>
<span class="nc" id="L504">                ctx.write(msg, promise);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">            } else if (msg instanceof BookkeeperProtocol.Response) {</span>
<span class="nc" id="L506">                ctx.write(repV3.encode(msg, ctx.alloc()), promise);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            } else if (msg instanceof BookieProtocol.Response) {</span>
<span class="nc" id="L508">                ctx.write(repPreV3.encode(msg, ctx.alloc()), promise);</span>
            } else {
<span class="nc" id="L510">                LOG.error(&quot;Invalid response to encode to {}: {}&quot;, ctx.channel(), msg.getClass().getName());</span>
<span class="nc" id="L511">                ctx.write(msg, promise);</span>
            }
<span class="nc" id="L513">        }</span>
    }

    /**
     * A response message decoder.
     */
    @Sharable
    public static class ResponseDecoder extends ChannelInboundHandlerAdapter {
        final EnDecoder repPreV3;
        final EnDecoder repV3;
        final boolean useV2Protocol;
        final boolean tlsEnabled;
        boolean usingV3Protocol;

        ResponseDecoder(ExtensionRegistry extensionRegistry,
                        boolean useV2Protocol,
<span class="nc" id="L529">                        boolean tlsEnabled) {</span>
<span class="nc" id="L530">            this.repPreV3 = new ResponseEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L531">            this.repV3 = new ResponseEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L532">            this.useV2Protocol = useV2Protocol;</span>
<span class="nc" id="L533">            this.tlsEnabled = tlsEnabled;</span>
<span class="nc" id="L534">            usingV3Protocol = true;</span>
<span class="nc" id="L535">        }</span>

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
<span class="nc bnc" id="L539" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L540">                LOG.trace(&quot;Received response {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
            }
            try {
<span class="nc bnc" id="L543" title="All 2 branches missed.">                if (!(msg instanceof ByteBuf)) {</span>
<span class="nc" id="L544">                    LOG.error(&quot;Received invalid response {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
<span class="nc" id="L545">                    ctx.fireChannelRead(msg);</span>
<span class="nc" id="L546">                    return;</span>
                }
<span class="nc" id="L548">                ByteBuf buffer = (ByteBuf) msg;</span>
<span class="nc" id="L549">                buffer.markReaderIndex();</span>

                Object result;
<span class="nc bnc" id="L552" title="All 2 branches missed.">                if (!useV2Protocol) { // always use v3 protocol</span>
<span class="nc" id="L553">                    result = repV3.decode(buffer);</span>
                } else { // use v2 protocol but
                    // if TLS enabled, the first message `startTLS` is a protobuf message
<span class="nc bnc" id="L556" title="All 4 branches missed.">                    if (tlsEnabled &amp;&amp; usingV3Protocol) {</span>
                        try {
<span class="nc" id="L558">                            result = repV3.decode(buffer);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                            if (result instanceof Response</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                                &amp;&amp; OperationType.START_TLS == ((Response) result).getHeader().getOperation()) {</span>
<span class="nc" id="L561">                                usingV3Protocol = false;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L563">                                    LOG.debug(&quot;Degrade bookkeeper to v2 after starting TLS.&quot;);</span>
                                }
                            }
<span class="nc" id="L566">                        } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L567">                            usingV3Protocol = false;</span>
<span class="nc" id="L568">                            buffer.resetReaderIndex();</span>
<span class="nc" id="L569">                            result = repPreV3.decode(buffer);</span>
<span class="nc" id="L570">                        }</span>
                    } else {
<span class="nc" id="L572">                        result = repPreV3.decode(buffer);</span>
                    }
                }
<span class="nc" id="L575">                ctx.fireChannelRead(result);</span>
            } finally {
<span class="nc" id="L577">                ReferenceCountUtil.release(msg);</span>
            }
<span class="nc" id="L579">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>