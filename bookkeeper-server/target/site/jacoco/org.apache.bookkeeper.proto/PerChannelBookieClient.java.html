<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PerChannelBookieClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.proto</a> &gt; <span class="el_source">PerChannelBookieClient.java</span></div><h1>PerChannelBookieClient.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information

 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.proto;

import static org.apache.bookkeeper.client.LedgerHandle.INVALID_ENTRY_ID;

import com.google.common.base.Joiner;
import com.google.common.collect.Sets;
import com.google.protobuf.ByteString;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.UnsafeByteOperations;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.WriteBufferWaterMark;
import io.netty.channel.epoll.EpollChannelOption;
import io.netty.channel.epoll.EpollEventLoopGroup;
import io.netty.channel.epoll.EpollSocketChannel;
import io.netty.channel.local.LocalAddress;
import io.netty.channel.local.LocalChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.channel.unix.Errors.NativeIoException;
import io.netty.handler.codec.CorruptedFrameException;
import io.netty.handler.codec.DecoderException;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.TooLongFrameException;
import io.netty.handler.flush.FlushConsolidationHandler;
import io.netty.handler.ssl.SslHandler;
import io.netty.incubator.channel.uring.IOUringChannelOption;
import io.netty.incubator.channel.uring.IOUringEventLoopGroup;
import io.netty.incubator.channel.uring.IOUringSocketChannel;
import io.netty.util.Recycler;
import io.netty.util.Recycler.Handle;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.ReferenceCounted;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.UnknownHostException;
import java.security.cert.Certificate;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.BiPredicate;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLPeerUnverifiedException;
import lombok.SneakyThrows;
import org.apache.bookkeeper.auth.BookKeeperPrincipal;
import org.apache.bookkeeper.auth.ClientAuthProvider;
import org.apache.bookkeeper.client.BKException;
import org.apache.bookkeeper.client.BookKeeperClientStats;
import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;
import org.apache.bookkeeper.client.api.WriteFlag;
import org.apache.bookkeeper.common.util.MdcUtils;
import org.apache.bookkeeper.common.util.OrderedExecutor;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ForceLedgerCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetListOfEntriesOfLedgerCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallbackCtx;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.StartTLSCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;
import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ForceLedgerRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ForceLedgerResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetListOfEntriesOfLedgerRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetListOfEntriesOfLedgerResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;
import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;
import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.bookkeeper.tls.SecurityException;
import org.apache.bookkeeper.tls.SecurityHandlerFactory;
import org.apache.bookkeeper.tls.SecurityHandlerFactory.NodeType;
import org.apache.bookkeeper.util.AvailabilityOfEntriesOfLedger;
import org.apache.bookkeeper.util.ByteBufList;
import org.apache.bookkeeper.util.MathUtils;
import org.apache.bookkeeper.util.StringUtils;
import org.apache.bookkeeper.util.collections.ConcurrentOpenHashMap;
import org.apache.bookkeeper.util.collections.SynchronizedHashMultiMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

/**
 * This class manages all details of connection to a particular bookie. It also
 * has reconnect logic if a connection to a bookie fails.
 */
@StatsDoc(
    name = BookKeeperClientStats.CHANNEL_SCOPE,
    help = &quot;Per channel bookie client stats&quot;
)
@Sharable
public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {

<span class="nc" id="L164">    static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);</span>

    // this set contains the bookie error return codes that we do not consider for a bookie to be &quot;faulty&quot;
<span class="nc" id="L167">    private static final Set&lt;Integer&gt; expectedBkOperationErrors = Collections.unmodifiableSet(Sets</span>
<span class="nc" id="L168">            .newHashSet(BKException.Code.BookieHandleNotAvailableException,</span>
<span class="nc" id="L169">                        BKException.Code.NoSuchEntryException,</span>
<span class="nc" id="L170">                        BKException.Code.NoSuchLedgerExistsException,</span>
<span class="nc" id="L171">                        BKException.Code.LedgerFencedException,</span>
<span class="nc" id="L172">                        BKException.Code.LedgerExistException,</span>
<span class="nc" id="L173">                        BKException.Code.DuplicateEntryIdException,</span>
<span class="nc" id="L174">                        BKException.Code.WriteOnReadOnlyBookieException));</span>
    private static final int DEFAULT_HIGH_PRIORITY_VALUE = 100; // We may add finer grained priority later.
<span class="nc" id="L176">    private static final AtomicLong txnIdGenerator = new AtomicLong(0);</span>

    final BookieId bookieId;
    final BookieAddressResolver bookieAddressResolver;
    final EventLoopGroup eventLoopGroup;
    final ByteBufAllocator allocator;
    final OrderedExecutor executor;
    final long addEntryTimeoutNanos;
    final long readEntryTimeoutNanos;
    final int maxFrameSize;
    final long getBookieInfoTimeoutNanos;
    final int startTLSTimeout;

<span class="nc" id="L189">    private final ConcurrentOpenHashMap&lt;CompletionKey, CompletionValue&gt; completionObjects =</span>
<span class="nc" id="L190">            ConcurrentOpenHashMap.&lt;CompletionKey, CompletionValue&gt;newBuilder().build();</span>

    // Map that hold duplicated read requests. The idea is to only use this map (synchronized) when there is a duplicate
    // read request for the same ledgerId/entryId
<span class="nc" id="L194">    private final SynchronizedHashMultiMap&lt;CompletionKey, CompletionValue&gt; completionObjectsV2Conflicts =</span>
        new SynchronizedHashMultiMap&lt;&gt;();

    private final StatsLogger statsLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_READ_OP,
        help = &quot;channel stats of read entries requests&quot;
    )
    private final OpStatsLogger readEntryOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_READ,
        help = &quot;timeout stats of read entries requests&quot;
    )
    private final OpStatsLogger readTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_ADD_OP,
        help = &quot;channel stats of add entries requests&quot;
    )
    private final OpStatsLogger addEntryOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_WRITE_LAC_OP,
        help = &quot;channel stats of write_lac requests&quot;
    )
    private final OpStatsLogger writeLacOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_FORCE_OP,
        help = &quot;channel stats of force requests&quot;
    )
    private final OpStatsLogger forceLedgerOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_READ_LAC_OP,
        help = &quot;channel stats of read_lac requests&quot;
    )
    private final OpStatsLogger readLacOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_ADD,
        help = &quot;timeout stats of add entries requests&quot;
    )
    private final OpStatsLogger addTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC,
        help = &quot;timeout stats of write_lac requests&quot;
    )
    private final OpStatsLogger writeLacTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_FORCE,
        help = &quot;timeout stats of force requests&quot;
    )
    private final OpStatsLogger forceLedgerTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC,
        help = &quot;timeout stats of read_lac requests&quot;
    )
    private final OpStatsLogger readLacTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.GET_BOOKIE_INFO_OP,
        help = &quot;channel stats of get_bookie_info requests&quot;
    )
    private final OpStatsLogger getBookieInfoOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO,
        help = &quot;timeout stats of get_bookie_info requests&quot;
    )
    private final OpStatsLogger getBookieInfoTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_START_TLS_OP,
        help = &quot;channel stats of start_tls requests&quot;
    )
    private final OpStatsLogger startTLSOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_START_TLS_OP,
        help = &quot;timeout stats of start_tls requests&quot;
    )
    private final OpStatsLogger startTLSTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CLIENT_CONNECT_TIMER,
        help = &quot;channel stats of connect requests&quot;
    )
    private final OpStatsLogger connectTimer;
    private final OpStatsLogger getListOfEntriesOfLedgerCompletionOpLogger;
    private final OpStatsLogger getListOfEntriesOfLedgerCompletionTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.NETTY_EXCEPTION_CNT,
        help = &quot;the number of exceptions received from this channel&quot;
    )
    private final Counter exceptionCounter;
    @StatsDoc(
        name = BookKeeperClientStats.ADD_OP_OUTSTANDING,
        help = &quot;the number of outstanding add_entry requests&quot;
    )
    private final Counter addEntryOutstanding;
    @StatsDoc(
        name = BookKeeperClientStats.READ_OP_OUTSTANDING,
        help = &quot;the number of outstanding add_entry requests&quot;
    )
    private final Counter readEntryOutstanding;
    /* collect stats on all Ops that flows through netty pipeline */
    @StatsDoc(
        name = BookKeeperClientStats.NETTY_OPS,
        help = &quot;channel stats for all operations flowing through netty pipeline&quot;
    )
    private final OpStatsLogger nettyOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.ACTIVE_NON_TLS_CHANNEL_COUNTER,
        help = &quot;the number of active non-tls channels&quot;
    )
    private final Counter activeNonTlsChannelCounter;
    @StatsDoc(
        name = BookKeeperClientStats.ACTIVE_TLS_CHANNEL_COUNTER,
        help = &quot;the number of active tls channels&quot;
    )
    private final Counter activeTlsChannelCounter;
    @StatsDoc(
        name = BookKeeperClientStats.FAILED_CONNECTION_COUNTER,
        help = &quot;the number of failed connections&quot;
    )
    private final Counter failedConnectionCounter;
    @StatsDoc(
        name = BookKeeperClientStats.FAILED_TLS_HANDSHAKE_COUNTER,
        help = &quot;the number of failed tls handshakes&quot;
    )
    private final Counter failedTlsHandshakeCounter;

    private final boolean useV2WireProtocol;
    private final boolean preserveMdcForTaskExecution;

    /**
     * The following member variables do not need to be concurrent, or volatile
     * because they are always updated under a lock.
     */
<span class="nc" id="L324">    private volatile Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; pendingOps =</span>
            new ArrayDeque&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt;();
<span class="nc" id="L326">    volatile Channel channel = null;</span>
    private final ClientConnectionPeer connectionPeer;
<span class="nc" id="L328">    private volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;</span>

<span class="nc" id="L330">    @SneakyThrows</span>
    private FailedChannelFutureImpl processBookieNotResolvedError(long startTime,
            BookieAddressResolver.BookieIdNotResolvedException err) {
<span class="nc" id="L333">        FailedChannelFutureImpl failedFuture = new FailedChannelFutureImpl(err);</span>
<span class="nc" id="L334">        contextPreservingListener(new ConnectionFutureListener(startTime)).operationComplete(failedFuture);</span>
<span class="nc" id="L335">        return failedFuture;</span>
    }

<span class="nc" id="L338">    enum ConnectionState {</span>
<span class="nc" id="L339">        DISCONNECTED, CONNECTING, CONNECTED, CLOSED, START_TLS</span>
    }

    volatile ConnectionState state;
<span class="nc" id="L343">    final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();</span>
    private final ClientConfiguration conf;

    private final PerChannelBookieClientPool pcbcPool;
    private final ClientAuthProvider.Factory authProviderFactory;
    private final ExtensionRegistry extRegistry;
    private final SecurityHandlerFactory shFactory;
<span class="nc" id="L350">    private volatile boolean isWritable = true;</span>
<span class="nc" id="L351">    private long lastBookieUnavailableLogTimestamp = 0;</span>

    public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup,
                                  BookieId addr, BookieAddressResolver bookieAddressResolver) throws SecurityException {
<span class="nc" id="L355">        this(new ClientConfiguration(), executor, eventLoopGroup, addr, NullStatsLogger.INSTANCE, null, null,</span>
                null, bookieAddressResolver);
<span class="nc" id="L357">    }</span>

    public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup,
                                  BookieId bookieId,
                                  ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry, BookieAddressResolver bookieAddressResolver)
            throws SecurityException {
<span class="nc" id="L364">        this(new ClientConfiguration(), executor, eventLoopGroup, bookieId,</span>
                NullStatsLogger.INSTANCE,
                authProviderFactory, extRegistry, null, bookieAddressResolver);
<span class="nc" id="L367">    }</span>

    public PerChannelBookieClient(ClientConfiguration conf, OrderedExecutor executor,
                                  EventLoopGroup eventLoopGroup, BookieId bookieId,
                                  StatsLogger parentStatsLogger, ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry,
                                  PerChannelBookieClientPool pcbcPool, BookieAddressResolver bookieAddressResolver)
            throws SecurityException {
<span class="nc" id="L375">        this(conf, executor, eventLoopGroup, UnpooledByteBufAllocator.DEFAULT, bookieId, NullStatsLogger.INSTANCE,</span>
                authProviderFactory, extRegistry, pcbcPool, null, bookieAddressResolver);
<span class="nc" id="L377">    }</span>

    public PerChannelBookieClient(ClientConfiguration conf, OrderedExecutor executor,
                                  EventLoopGroup eventLoopGroup,
                                  ByteBufAllocator allocator,
                                  BookieId bookieId,
                                  StatsLogger parentStatsLogger, ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry,
                                  PerChannelBookieClientPool pcbcPool,
                                  SecurityHandlerFactory shFactory,
<span class="nc" id="L387">                                  BookieAddressResolver bookieAddressResolver) throws SecurityException {</span>
<span class="nc" id="L388">        this.maxFrameSize = conf.getNettyMaxFrameSizeBytes();</span>
<span class="nc" id="L389">        this.conf = conf;</span>
<span class="nc" id="L390">        this.bookieId = bookieId;</span>
<span class="nc" id="L391">        this.bookieAddressResolver = bookieAddressResolver;</span>
<span class="nc" id="L392">        this.executor = executor;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (LocalBookiesRegistry.isLocalBookie(bookieId)) {</span>
<span class="nc" id="L394">            this.eventLoopGroup = new DefaultEventLoopGroup();</span>
        } else {
<span class="nc" id="L396">            this.eventLoopGroup = eventLoopGroup;</span>
        }
<span class="nc" id="L398">        this.allocator = allocator;</span>
<span class="nc" id="L399">        this.state = ConnectionState.DISCONNECTED;</span>
<span class="nc" id="L400">        this.addEntryTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getAddEntryTimeout());</span>
<span class="nc" id="L401">        this.readEntryTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getReadEntryTimeout());</span>
<span class="nc" id="L402">        this.getBookieInfoTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getBookieInfoTimeout());</span>
<span class="nc" id="L403">        this.startTLSTimeout = conf.getStartTLSTimeout();</span>
<span class="nc" id="L404">        this.useV2WireProtocol = conf.getUseV2WireProtocol();</span>
<span class="nc" id="L405">        this.preserveMdcForTaskExecution = conf.getPreserveMdcForTaskExecution();</span>

<span class="nc" id="L407">        this.authProviderFactory = authProviderFactory;</span>
<span class="nc" id="L408">        this.extRegistry = extRegistry;</span>
<span class="nc" id="L409">        this.shFactory = shFactory;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (shFactory != null) {</span>
<span class="nc" id="L411">            shFactory.init(NodeType.Client, conf, allocator);</span>
        }

<span class="nc" id="L414">        this.statsLogger = parentStatsLogger.scope(BookKeeperClientStats.CHANNEL_SCOPE)</span>
<span class="nc" id="L415">            .scopeLabel(BookKeeperClientStats.BOOKIE_LABEL, bookieId.toString());</span>

<span class="nc" id="L417">        readEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_OP);</span>
<span class="nc" id="L418">        addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);</span>
<span class="nc" id="L419">        writeLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE_LAC_OP);</span>
<span class="nc" id="L420">        forceLedgerOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_FORCE_OP);</span>
<span class="nc" id="L421">        readLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_LAC_OP);</span>
<span class="nc" id="L422">        getBookieInfoOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.GET_BOOKIE_INFO_OP);</span>
<span class="nc" id="L423">        getListOfEntriesOfLedgerCompletionOpLogger = statsLogger</span>
<span class="nc" id="L424">                .getOpStatsLogger(BookKeeperClientStats.GET_LIST_OF_ENTRIES_OF_LEDGER_OP);</span>
<span class="nc" id="L425">        readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);</span>
<span class="nc" id="L426">        addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);</span>
<span class="nc" id="L427">        writeLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC);</span>
<span class="nc" id="L428">        forceLedgerTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_FORCE);</span>
<span class="nc" id="L429">        readLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC);</span>
<span class="nc" id="L430">        getBookieInfoTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO);</span>
<span class="nc" id="L431">        startTLSOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_START_TLS_OP);</span>
<span class="nc" id="L432">        startTLSTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_START_TLS_OP);</span>
<span class="nc" id="L433">        getListOfEntriesOfLedgerCompletionTimeoutOpLogger = statsLogger</span>
<span class="nc" id="L434">                .getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_LIST_OF_ENTRIES_OF_LEDGER);</span>
<span class="nc" id="L435">        exceptionCounter = statsLogger.getCounter(BookKeeperClientStats.NETTY_EXCEPTION_CNT);</span>
<span class="nc" id="L436">        connectTimer = statsLogger.getOpStatsLogger(BookKeeperClientStats.CLIENT_CONNECT_TIMER);</span>
<span class="nc" id="L437">        addEntryOutstanding = statsLogger.getCounter(BookKeeperClientStats.ADD_OP_OUTSTANDING);</span>
<span class="nc" id="L438">        readEntryOutstanding = statsLogger.getCounter(BookKeeperClientStats.READ_OP_OUTSTANDING);</span>
<span class="nc" id="L439">        nettyOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.NETTY_OPS);</span>
<span class="nc" id="L440">        activeNonTlsChannelCounter = statsLogger.getCounter(BookKeeperClientStats.ACTIVE_NON_TLS_CHANNEL_COUNTER);</span>
<span class="nc" id="L441">        activeTlsChannelCounter = statsLogger.getCounter(BookKeeperClientStats.ACTIVE_TLS_CHANNEL_COUNTER);</span>
<span class="nc" id="L442">        failedConnectionCounter = statsLogger.getCounter(BookKeeperClientStats.FAILED_CONNECTION_COUNTER);</span>
<span class="nc" id="L443">        failedTlsHandshakeCounter = statsLogger.getCounter(BookKeeperClientStats.FAILED_TLS_HANDSHAKE_COUNTER);</span>

<span class="nc" id="L445">        this.pcbcPool = pcbcPool;</span>

<span class="nc" id="L447">        this.connectionPeer = new ClientConnectionPeer() {</span>

            @Override
            public SocketAddress getRemoteAddr() {
<span class="nc" id="L451">                Channel c = channel;</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc" id="L453">                    return c.remoteAddress();</span>
                } else {
<span class="nc" id="L455">                    return null;</span>
                }
            }

            @Override
            public Collection&lt;Object&gt; getProtocolPrincipals() {
<span class="nc" id="L461">                Channel c = channel;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                if (c == null) {</span>
<span class="nc" id="L463">                    return Collections.emptyList();</span>
                }
<span class="nc" id="L465">                SslHandler ssl = c.pipeline().get(SslHandler.class);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (ssl == null) {</span>
<span class="nc" id="L467">                    return Collections.emptyList();</span>
                }
                try {
<span class="nc" id="L470">                    Certificate[] certificates = ssl.engine().getSession().getPeerCertificates();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                    if (certificates == null) {</span>
<span class="nc" id="L472">                        return Collections.emptyList();</span>
                    }
<span class="nc" id="L474">                    List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L475">                    result.addAll(Arrays.asList(certificates));</span>
<span class="nc" id="L476">                    return result;</span>
<span class="nc" id="L477">                } catch (SSLPeerUnverifiedException err) {</span>
<span class="nc" id="L478">                     return Collections.emptyList();</span>
                }
            }

            @Override
            public void disconnect() {
<span class="nc" id="L484">                Channel c = channel;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc" id="L486">                    c.close().addListener(x -&gt; makeWritable());</span>
                }
<span class="nc" id="L488">                LOG.info(&quot;authplugin disconnected channel {}&quot;, channel);</span>
<span class="nc" id="L489">            }</span>

            @Override
            public void setAuthorizedId(BookKeeperPrincipal principal) {
<span class="nc" id="L493">                authorizedId = principal;</span>
<span class="nc" id="L494">                LOG.info(&quot;connection {} authenticated as {}&quot;, channel, principal);</span>
<span class="nc" id="L495">            }</span>

            @Override
            public BookKeeperPrincipal getAuthorizedId() {
<span class="nc" id="L499">                return authorizedId;</span>
            }

            @Override
            public boolean isSecure() {
<span class="nc" id="L504">               Channel c = channel;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">               if (c == null) {</span>
<span class="nc" id="L506">                    return false;</span>
               } else {
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    return c.pipeline().get(SslHandler.class) != null;</span>
               }
            }

        };
<span class="nc" id="L513">    }</span>

    private void completeOperation(GenericCallback&lt;PerChannelBookieClient&gt; op, int rc) {
<span class="nc" id="L516">        closeLock.readLock().lock();</span>
        try {
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (ConnectionState.CLOSED == state) {</span>
<span class="nc" id="L519">                op.operationComplete(BKException.Code.ClientClosedException, this);</span>
            } else {
<span class="nc" id="L521">                op.operationComplete(rc, this);</span>
            }
        } finally {
<span class="nc" id="L524">            closeLock.readLock().unlock();</span>
        }
<span class="nc" id="L526">    }</span>

    protected long getNumPendingCompletionRequests() {
<span class="nc" id="L529">        return completionObjects.size();</span>
    }

    protected ChannelFuture connect() {
<span class="nc" id="L533">        final long startTime = MathUtils.nowInNano();</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L535">            LOG.debug(&quot;Connecting to bookie: {}&quot;, bookieId);</span>
        }
        BookieSocketAddress addr;
        try {
<span class="nc" id="L539">            addr = bookieAddressResolver.resolve(bookieId);</span>
<span class="nc" id="L540">        } catch (BookieAddressResolver.BookieIdNotResolvedException err) {</span>
<span class="nc" id="L541">            LOG.error(&quot;Cannot connect to {} as endpoint resolution failed (probably bookie is down) err {}&quot;,</span>
<span class="nc" id="L542">                    bookieId, err.toString());</span>
<span class="nc" id="L543">            return processBookieNotResolvedError(startTime, err);</span>
<span class="nc" id="L544">        }</span>

        // Set up the ClientBootStrap so we can create a new Channel connection to the bookie.
<span class="nc" id="L547">        Bootstrap bootstrap = new Bootstrap();</span>
<span class="nc" id="L548">        bootstrap.group(eventLoopGroup);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        if (eventLoopGroup instanceof IOUringEventLoopGroup) {</span>
<span class="nc" id="L550">            bootstrap.channel(IOUringSocketChannel.class);</span>
            try {
<span class="nc" id="L552">                bootstrap.option(IOUringChannelOption.TCP_USER_TIMEOUT, conf.getTcpUserTimeoutMillis());</span>
<span class="nc" id="L553">            } catch (NoSuchElementException e) {</span>
                // Property not set, so keeping default value.
<span class="nc" id="L555">            }</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        } else if (eventLoopGroup instanceof EpollEventLoopGroup) {</span>
<span class="nc" id="L557">            bootstrap.channel(EpollSocketChannel.class);</span>
            try {
                // For Epoll channels, configure the TCP user timeout.
<span class="nc" id="L560">                bootstrap.option(EpollChannelOption.TCP_USER_TIMEOUT, conf.getTcpUserTimeoutMillis());</span>
<span class="nc" id="L561">            } catch (NoSuchElementException e) {</span>
                // Property not set, so keeping default value.
<span class="nc" id="L563">            }</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">        } else if (eventLoopGroup instanceof DefaultEventLoopGroup) {</span>
<span class="nc" id="L565">            bootstrap.channel(LocalChannel.class);</span>
        } else {
<span class="nc" id="L567">            bootstrap.channel(NioSocketChannel.class);</span>
        }

<span class="nc" id="L570">        bootstrap.option(ChannelOption.ALLOCATOR, this.allocator);</span>
<span class="nc" id="L571">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, conf.getClientConnectTimeoutMillis());</span>
<span class="nc" id="L572">        bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(</span>
<span class="nc" id="L573">                conf.getClientWriteBufferLowWaterMark(), conf.getClientWriteBufferHighWaterMark()));</span>

<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (!(eventLoopGroup instanceof DefaultEventLoopGroup)) {</span>
<span class="nc" id="L576">            bootstrap.option(ChannelOption.TCP_NODELAY, conf.getClientTcpNoDelay());</span>
<span class="nc" id="L577">            bootstrap.option(ChannelOption.SO_KEEPALIVE, conf.getClientSockKeepalive());</span>

            // if buffer sizes are 0, let OS auto-tune it
<span class="nc bnc" id="L580" title="All 2 branches missed.">            if (conf.getClientSendBufferSize() &gt; 0) {</span>
<span class="nc" id="L581">                bootstrap.option(ChannelOption.SO_SNDBUF, conf.getClientSendBufferSize());</span>
            }

<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (conf.getClientReceiveBufferSize() &gt; 0) {</span>
<span class="nc" id="L585">                bootstrap.option(ChannelOption.SO_RCVBUF, conf.getClientReceiveBufferSize());</span>
            }
        }

        // In the netty pipeline, we need to split packets based on length, so we
        // use the {@link LengthFieldBasedFramDecoder}. Other than that all actions
        // are carried out in this class, e.g., making sense of received messages,
        // prepending the length to outgoing packets etc.
<span class="nc" id="L593">        bootstrap.handler(new ChannelInitializer&lt;Channel&gt;() {</span>
            @Override
            protected void initChannel(Channel ch) throws Exception {
<span class="nc" id="L596">                ChannelPipeline pipeline = ch.pipeline();</span>
<span class="nc" id="L597">                pipeline.addLast(&quot;consolidation&quot;, new FlushConsolidationHandler(1024, true));</span>
<span class="nc" id="L598">                pipeline.addLast(&quot;bytebufList&quot;, ByteBufList.ENCODER);</span>
<span class="nc" id="L599">                pipeline.addLast(&quot;lengthbasedframedecoder&quot;,</span>
                        new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));
<span class="nc" id="L601">                pipeline.addLast(&quot;bookieProtoEncoder&quot;, new BookieProtoEncoding.RequestEncoder(extRegistry));</span>
<span class="nc" id="L602">                pipeline.addLast(</span>
                    &quot;bookieProtoDecoder&quot;,
<span class="nc bnc" id="L604" title="All 2 branches missed.">                    new BookieProtoEncoding.ResponseDecoder(extRegistry, useV2WireProtocol, shFactory != null));</span>
<span class="nc" id="L605">                pipeline.addLast(&quot;authHandler&quot;, new AuthHandler.ClientSideHandler(authProviderFactory, txnIdGenerator,</span>
<span class="nc" id="L606">                            connectionPeer, useV2WireProtocol));</span>
<span class="nc" id="L607">                pipeline.addLast(&quot;mainhandler&quot;, PerChannelBookieClient.this);</span>
<span class="nc" id="L608">            }</span>
        });

<span class="nc" id="L611">        SocketAddress bookieAddr = addr.getSocketAddress();</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (eventLoopGroup instanceof DefaultEventLoopGroup) {</span>
<span class="nc" id="L613">            bookieAddr = new LocalAddress(bookieId.toString());</span>
        }

<span class="nc" id="L616">        ChannelFuture future = bootstrap.connect(bookieAddr);</span>
<span class="nc" id="L617">        future.addListener(contextPreservingListener(new ConnectionFutureListener(startTime)));</span>
<span class="nc" id="L618">        future.addListener(x -&gt; makeWritable());</span>
<span class="nc" id="L619">        return future;</span>
    }

    void cleanDisconnectAndClose() {
<span class="nc" id="L623">        disconnect();</span>
<span class="nc" id="L624">        close();</span>
<span class="nc" id="L625">    }</span>

    /**
     *
     * @return boolean, true is PCBC is writable
     */
    public boolean isWritable() {
<span class="nc" id="L632">        return isWritable;</span>
    }

    public void setWritable(boolean val) {
<span class="nc" id="L636">        isWritable = val;</span>
<span class="nc" id="L637">    }</span>

    private void makeWritable() {
<span class="nc" id="L640">        setWritable(true);</span>
<span class="nc" id="L641">    }</span>

    void connectIfNeededAndDoOp(GenericCallback&lt;PerChannelBookieClient&gt; op) {
<span class="nc" id="L644">        boolean completeOpNow = false;</span>
<span class="nc" id="L645">        int opRc = BKException.Code.OK;</span>
        // common case without lock first
<span class="nc bnc" id="L647" title="All 4 branches missed.">        if (channel != null &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc" id="L648">            completeOpNow = true;</span>
        } else {

<span class="nc" id="L651">            synchronized (this) {</span>
                // check the channel status again under lock
<span class="nc bnc" id="L653" title="All 4 branches missed.">                if (channel != null &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc" id="L654">                    completeOpNow = true;</span>
<span class="nc" id="L655">                    opRc = BKException.Code.OK;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                } else if (state == ConnectionState.CLOSED) {</span>
<span class="nc" id="L657">                    completeOpNow = true;</span>
<span class="nc" id="L658">                    opRc = BKException.Code.BookieHandleNotAvailableException;</span>
                } else {
                    // channel is either null (first connection attempt), or the
                    // channel is disconnected. Connection attempt is still in
                    // progress, queue up this op. Op will be executed when
                    // connection attempt either fails or succeeds
<span class="nc" id="L664">                    pendingOps.add(op);</span>

<span class="nc bnc" id="L666" title="All 4 branches missed.">                    if (state == ConnectionState.CONNECTING</span>
                        || state == ConnectionState.START_TLS) {
                        // the connection request has already been sent and it is waiting for the response.
<span class="nc" id="L669">                        return;</span>
                    }
                    // switch state to connecting and do connection attempt
<span class="nc" id="L672">                    state = ConnectionState.CONNECTING;</span>
                }
<span class="nc" id="L674">            }</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">            if (!completeOpNow) {</span>
                // Start connection attempt to the input server host.
<span class="nc" id="L677">                connect();</span>
            }
        }

<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (completeOpNow) {</span>
<span class="nc" id="L682">            completeOperation(op, opRc);</span>
        }

<span class="nc" id="L685">    }</span>

    void writeLac(final long ledgerId, final byte[] masterKey, final long lac, ByteBufList toSend, WriteLacCallback cb,
            Object ctx) {
<span class="nc" id="L689">        final long txnId = getTxnId();</span>
<span class="nc" id="L690">        final CompletionKey completionKey = new V3CompletionKey(txnId,</span>
                                                                OperationType.WRITE_LAC);
        // writeLac is mostly like addEntry hence uses addEntryTimeout
<span class="nc" id="L693">        completionObjects.put(completionKey,</span>
                              new WriteLacCompletion(completionKey, cb,
                                                     ctx, ledgerId));

        // Build the request
<span class="nc" id="L698">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L699">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L700">                .setOperation(OperationType.WRITE_LAC)</span>
<span class="nc" id="L701">                .setTxnId(txnId);</span>
        ByteString body;
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (toSend.hasArray()) {</span>
<span class="nc" id="L704">            body = UnsafeByteOperations.unsafeWrap(toSend.array(), toSend.arrayOffset(), toSend.readableBytes());</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">        } else if (toSend.size() == 1) {</span>
<span class="nc" id="L706">            body = UnsafeByteOperations.unsafeWrap(toSend.getBuffer(0).nioBuffer());</span>
        } else {
<span class="nc" id="L708">            body = UnsafeByteOperations.unsafeWrap(toSend.toArray());</span>
        }
<span class="nc" id="L710">        WriteLacRequest.Builder writeLacBuilder = WriteLacRequest.newBuilder()</span>
<span class="nc" id="L711">                .setLedgerId(ledgerId)</span>
<span class="nc" id="L712">                .setLac(lac)</span>
<span class="nc" id="L713">                .setMasterKey(UnsafeByteOperations.unsafeWrap(masterKey))</span>
<span class="nc" id="L714">                .setBody(body);</span>

<span class="nc" id="L716">        final Request writeLacRequest = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L717">                .setHeader(headerBuilder)</span>
<span class="nc" id="L718">                .setWriteLacRequest(writeLacBuilder)</span>
<span class="nc" id="L719">                .build();</span>
<span class="nc" id="L720">        writeAndFlush(channel, completionKey, writeLacRequest);</span>
<span class="nc" id="L721">    }</span>

    void forceLedger(final long ledgerId, ForceLedgerCallback cb, Object ctx) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L725">                LOG.error(&quot;force is not allowed with v2 protocol&quot;);</span>
<span class="nc" id="L726">                executor.executeOrdered(ledgerId, () -&gt; {</span>
<span class="nc" id="L727">                    cb.forceLedgerComplete(BKException.Code.IllegalOpException, ledgerId, bookieId, ctx);</span>
<span class="nc" id="L728">                });</span>
<span class="nc" id="L729">                return;</span>
        }
<span class="nc" id="L731">        final long txnId = getTxnId();</span>
<span class="nc" id="L732">        final CompletionKey completionKey = new V3CompletionKey(txnId,</span>
                                                                OperationType.FORCE_LEDGER);
        // force is mostly like addEntry hence uses addEntryTimeout
<span class="nc" id="L735">        completionObjects.put(completionKey,</span>
                              new ForceLedgerCompletion(completionKey, cb,
                                                     ctx, ledgerId));

        // Build the request
<span class="nc" id="L740">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L741">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L742">                .setOperation(OperationType.FORCE_LEDGER)</span>
<span class="nc" id="L743">                .setTxnId(txnId);</span>
<span class="nc" id="L744">        ForceLedgerRequest.Builder writeLacBuilder = ForceLedgerRequest.newBuilder()</span>
<span class="nc" id="L745">                .setLedgerId(ledgerId);</span>

<span class="nc" id="L747">        final Request forceLedgerRequest = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L748">                .setHeader(headerBuilder)</span>
<span class="nc" id="L749">                .setForceLedgerRequest(writeLacBuilder)</span>
<span class="nc" id="L750">                .build();</span>
<span class="nc" id="L751">        writeAndFlush(channel, completionKey, forceLedgerRequest);</span>
<span class="nc" id="L752">    }</span>

    /**
     * This method should be called only after connection has been checked for
     * {@link #connectIfNeededAndDoOp(GenericCallback)}.
     *
     * @param ledgerId
     *          Ledger Id
     * @param masterKey
     *          Master Key
     * @param entryId
     *          Entry Id
     * @param toSend
     *          Buffer to send
     * @param cb
     *          Write callback
     * @param ctx
     *          Write callback context
     * @param allowFastFail
     *          allowFastFail flag
     * @param writeFlags
     *          WriteFlags
     */
    void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ReferenceCounted toSend, WriteCallback cb,
                  Object ctx, final int options, boolean allowFastFail, final EnumSet&lt;WriteFlag&gt; writeFlags) {
<span class="nc" id="L777">        Object request = null;</span>
<span class="nc" id="L778">        CompletionKey completionKey = null;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">            if (writeFlags.contains(WriteFlag.DEFERRED_SYNC)) {</span>
<span class="nc" id="L781">                LOG.error(&quot;invalid writeflags {} for v2 protocol&quot;, writeFlags);</span>
<span class="nc" id="L782">                cb.writeComplete(BKException.Code.IllegalOpException, ledgerId, entryId, bookieId, ctx);</span>
<span class="nc" id="L783">                return;</span>
            }
<span class="nc" id="L785">            completionKey = acquireV2Key(ledgerId, entryId, OperationType.ADD_ENTRY);</span>

<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (toSend instanceof ByteBuf) {</span>
<span class="nc" id="L788">                request = ((ByteBuf) toSend).retainedDuplicate();</span>
            } else {
<span class="nc" id="L790">                request = ByteBufList.clone((ByteBufList) toSend);</span>
            }
        } else {
<span class="nc" id="L793">            final long txnId = getTxnId();</span>
<span class="nc" id="L794">            completionKey = new V3CompletionKey(txnId, OperationType.ADD_ENTRY);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L797">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L798">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L799">                    .setOperation(OperationType.ADD_ENTRY)</span>
<span class="nc" id="L800">                    .setTxnId(txnId);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (((short) options &amp; BookieProtocol.FLAG_HIGH_PRIORITY) == BookieProtocol.FLAG_HIGH_PRIORITY) {</span>
<span class="nc" id="L802">                headerBuilder.setPriority(DEFAULT_HIGH_PRIORITY_VALUE);</span>
            }

<span class="nc" id="L805">            ByteString body = null;</span>
<span class="nc" id="L806">            ByteBufList bufToSend = (ByteBufList) toSend;</span>

<span class="nc bnc" id="L808" title="All 2 branches missed.">            if (bufToSend.hasArray()) {</span>
<span class="nc" id="L809">                body = UnsafeByteOperations.unsafeWrap(bufToSend.array(), bufToSend.arrayOffset(),</span>
<span class="nc" id="L810">                        bufToSend.readableBytes());</span>
            } else {
<span class="nc bnc" id="L812" title="All 2 branches missed.">                for (int i = 0; i &lt; bufToSend.size(); i++) {</span>
<span class="nc" id="L813">                    ByteString piece = UnsafeByteOperations.unsafeWrap(bufToSend.getBuffer(i).nioBuffer());</span>
                    // use ByteString.concat to avoid byte[] allocation when toSend has multiple ByteBufs
<span class="nc bnc" id="L815" title="All 2 branches missed.">                    body = (body == null) ? piece : body.concat(piece);</span>
                }
            }
<span class="nc" id="L818">            AddRequest.Builder addBuilder = AddRequest.newBuilder()</span>
<span class="nc" id="L819">                    .setLedgerId(ledgerId)</span>
<span class="nc" id="L820">                    .setEntryId(entryId)</span>
<span class="nc" id="L821">                    .setMasterKey(UnsafeByteOperations.unsafeWrap(masterKey))</span>
<span class="nc" id="L822">                    .setBody(body);</span>

<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (((short) options &amp; BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {</span>
<span class="nc" id="L825">                addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);</span>
            }

<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (!writeFlags.isEmpty()) {</span>
                // add flags only if needed, in order to be able to talk with old bookies
<span class="nc" id="L830">                addBuilder.setWriteFlags(WriteFlag.getWriteFlagsValue(writeFlags));</span>
            }

<span class="nc" id="L833">            request = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L834">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L835">                    .setAddRequest(addBuilder)</span>
<span class="nc" id="L836">                    .build();</span>
        }

<span class="nc" id="L839">        putCompletionKeyValue(completionKey,</span>
<span class="nc" id="L840">                              acquireAddCompletion(completionKey,</span>
                                                   cb, ctx, ledgerId, entryId));
<span class="nc" id="L842">        final Channel c = channel;</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">        if (c == null) {</span>
            // usually checked in writeAndFlush, but we have extra check
            // because we need to release toSend.
<span class="nc" id="L846">            errorOut(completionKey);</span>
<span class="nc" id="L847">            ReferenceCountUtil.release(toSend);</span>
<span class="nc" id="L848">            return;</span>
        } else {
            // addEntry times out on backpressure
<span class="nc" id="L851">            writeAndFlush(c, completionKey, request, allowFastFail);</span>
        }
<span class="nc" id="L853">    }</span>

    public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {
<span class="nc" id="L856">        Object request = null;</span>
<span class="nc" id="L857">        CompletionKey completionKey = null;</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L859">            request = BookieProtocol.ReadRequest.create(BookieProtocol.CURRENT_PROTOCOL_VERSION,</span>
                                                     ledgerId, 0, (short) 0, null);
<span class="nc" id="L861">            completionKey = acquireV2Key(ledgerId, 0, OperationType.READ_LAC);</span>
        } else {
<span class="nc" id="L863">            final long txnId = getTxnId();</span>
<span class="nc" id="L864">            completionKey = new V3CompletionKey(txnId, OperationType.READ_LAC);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L867">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L868">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L869">                    .setOperation(OperationType.READ_LAC)</span>
<span class="nc" id="L870">                    .setTxnId(txnId);</span>
<span class="nc" id="L871">            ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()</span>
<span class="nc" id="L872">                    .setLedgerId(ledgerId);</span>
<span class="nc" id="L873">            request = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L874">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L875">                    .setReadLacRequest(readLacBuilder)</span>
<span class="nc" id="L876">                    .build();</span>
        }
<span class="nc" id="L878">        putCompletionKeyValue(completionKey,</span>
                              new ReadLacCompletion(completionKey, cb,
                                                    ctx, ledgerId));
<span class="nc" id="L881">        writeAndFlush(channel, completionKey, request);</span>
<span class="nc" id="L882">    }</span>

    public void getListOfEntriesOfLedger(final long ledgerId, GetListOfEntriesOfLedgerCallback cb) {
<span class="nc" id="L885">        final long txnId = getTxnId();</span>
<span class="nc" id="L886">        final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.GET_LIST_OF_ENTRIES_OF_LEDGER);</span>
<span class="nc" id="L887">        completionObjects.put(completionKey, new GetListOfEntriesOfLedgerCompletion(completionKey, cb, ledgerId));</span>

        // Build the request.
<span class="nc" id="L890">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder().setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L891">                .setOperation(OperationType.GET_LIST_OF_ENTRIES_OF_LEDGER).setTxnId(txnId);</span>

        GetListOfEntriesOfLedgerRequest.Builder getListOfEntriesOfLedgerRequestBuilder =
<span class="nc" id="L894">                GetListOfEntriesOfLedgerRequest.newBuilder().setLedgerId(ledgerId);</span>

<span class="nc" id="L896">        final Request getListOfEntriesOfLedgerRequest = Request.newBuilder().setHeader(headerBuilder)</span>
<span class="nc" id="L897">                .setGetListOfEntriesOfLedgerRequest(getListOfEntriesOfLedgerRequestBuilder).build();</span>

<span class="nc" id="L899">        writeAndFlush(channel, completionKey, getListOfEntriesOfLedgerRequest);</span>
<span class="nc" id="L900">    }</span>

    /**
     * Long Poll Reads.
     */
    public void readEntryWaitForLACUpdate(final long ledgerId,
                                          final long entryId,
                                          final long previousLAC,
                                          final long timeOutInMillis,
                                          final boolean piggyBackEntry,
                                          ReadEntryCallback cb,
                                          Object ctx) {
<span class="nc" id="L912">        readEntryInternal(ledgerId, entryId, previousLAC, timeOutInMillis,</span>
                          piggyBackEntry, cb, ctx, (short) 0, null, false);
<span class="nc" id="L914">    }</span>

    /**
     * Normal Reads.
     */
    public void readEntry(final long ledgerId,
                          final long entryId,
                          ReadEntryCallback cb,
                          Object ctx,
                          int flags,
                          byte[] masterKey,
                          boolean allowFastFail) {
<span class="nc" id="L926">        readEntryInternal(ledgerId, entryId, null, null, false,</span>
                          cb, ctx, (short) flags, masterKey, allowFastFail);
<span class="nc" id="L928">    }</span>

    private void readEntryInternal(final long ledgerId,
                                   final long entryId,
                                   final Long previousLAC,
                                   final Long timeOutInMillis,
                                   final boolean piggyBackEntry,
                                   final ReadEntryCallback cb,
                                   final Object ctx,
                                   int flags,
                                   byte[] masterKey,
                                   boolean allowFastFail) {
<span class="nc" id="L940">        Object request = null;</span>
<span class="nc" id="L941">        CompletionKey completionKey = null;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L943">            request = BookieProtocol.ReadRequest.create(BookieProtocol.CURRENT_PROTOCOL_VERSION,</span>
                    ledgerId, entryId, (short) flags, masterKey);
<span class="nc" id="L945">            completionKey = acquireV2Key(ledgerId, entryId, OperationType.READ_ENTRY);</span>
        } else {
<span class="nc" id="L947">            final long txnId = getTxnId();</span>
<span class="nc" id="L948">            completionKey = new V3CompletionKey(txnId, OperationType.READ_ENTRY);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L951">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L952">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L953">                    .setOperation(OperationType.READ_ENTRY)</span>
<span class="nc" id="L954">                    .setTxnId(txnId);</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">            if (((short) flags &amp; BookieProtocol.FLAG_HIGH_PRIORITY) == BookieProtocol.FLAG_HIGH_PRIORITY) {</span>
<span class="nc" id="L956">                headerBuilder.setPriority(DEFAULT_HIGH_PRIORITY_VALUE);</span>
            }

<span class="nc" id="L959">            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()</span>
<span class="nc" id="L960">                    .setLedgerId(ledgerId)</span>
<span class="nc" id="L961">                    .setEntryId(entryId);</span>

<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (null != previousLAC) {</span>
<span class="nc" id="L964">                readBuilder = readBuilder.setPreviousLAC(previousLAC);</span>
            }

<span class="nc bnc" id="L967" title="All 2 branches missed.">            if (null != timeOutInMillis) {</span>
                // Long poll requires previousLAC
<span class="nc bnc" id="L969" title="All 2 branches missed.">                if (null == previousLAC) {</span>
<span class="nc" id="L970">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                        ledgerId, entryId, null, ctx);
<span class="nc" id="L972">                    return;</span>
                }
<span class="nc" id="L974">                readBuilder = readBuilder.setTimeOut(timeOutInMillis);</span>
            }

<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (piggyBackEntry) {</span>
                // Long poll requires previousLAC
<span class="nc bnc" id="L979" title="All 2 branches missed.">                if (null == previousLAC) {</span>
<span class="nc" id="L980">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                        ledgerId, entryId, null, ctx);
<span class="nc" id="L982">                    return;</span>
                }
<span class="nc" id="L984">                readBuilder = readBuilder.setFlag(ReadRequest.Flag.ENTRY_PIGGYBACK);</span>
            }

            // Only one flag can be set on the read requests
<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (((short) flags &amp; BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING) {</span>
<span class="nc" id="L989">                readBuilder.setFlag(ReadRequest.Flag.FENCE_LEDGER);</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                if (masterKey == null) {</span>
<span class="nc" id="L991">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                                         ledgerId, entryId, null, ctx);
<span class="nc" id="L993">                    return;</span>
                }
<span class="nc" id="L995">                readBuilder.setMasterKey(ByteString.copyFrom(masterKey));</span>
            }

<span class="nc" id="L998">            request = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L999">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L1000">                    .setReadRequest(readBuilder)</span>
<span class="nc" id="L1001">                    .build();</span>
        }

<span class="nc" id="L1004">        ReadCompletion readCompletion = new ReadCompletion(completionKey, cb, ctx, ledgerId, entryId);</span>
<span class="nc" id="L1005">        putCompletionKeyValue(completionKey, readCompletion);</span>

<span class="nc" id="L1007">        writeAndFlush(channel, completionKey, request, allowFastFail);</span>
<span class="nc" id="L1008">    }</span>

    public void getBookieInfo(final long requested, GetBookieInfoCallback cb, Object ctx) {
<span class="nc" id="L1011">        final long txnId = getTxnId();</span>
<span class="nc" id="L1012">        final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.GET_BOOKIE_INFO);</span>
<span class="nc" id="L1013">        completionObjects.put(completionKey,</span>
                              new GetBookieInfoCompletion(
                                      completionKey, cb, ctx));

        // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L1018">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L1019">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L1020">                .setOperation(OperationType.GET_BOOKIE_INFO)</span>
<span class="nc" id="L1021">                .setTxnId(txnId);</span>

<span class="nc" id="L1023">        GetBookieInfoRequest.Builder getBookieInfoBuilder = GetBookieInfoRequest.newBuilder()</span>
<span class="nc" id="L1024">                .setRequested(requested);</span>

<span class="nc" id="L1026">        final Request getBookieInfoRequest = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L1027">                .setHeader(headerBuilder)</span>
<span class="nc" id="L1028">                .setGetBookieInfoRequest(getBookieInfoBuilder)</span>
<span class="nc" id="L1029">                .build();</span>

<span class="nc" id="L1031">        writeAndFlush(channel, completionKey, getBookieInfoRequest);</span>
<span class="nc" id="L1032">    }</span>

<span class="nc" id="L1034">    private static final BiPredicate&lt;CompletionKey, CompletionValue&gt; timeoutCheck = (key, value) -&gt; {</span>
<span class="nc" id="L1035">        return value.maybeTimeout();</span>
    };

    public void checkTimeoutOnPendingOperations() {
<span class="nc" id="L1039">        int timedOutOperations = completionObjects.removeIf(timeoutCheck);</span>

<span class="nc" id="L1041">        timedOutOperations += completionObjectsV2Conflicts.removeIf(timeoutCheck);</span>

<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (timedOutOperations &gt; 0) {</span>
<span class="nc" id="L1044">            LOG.info(&quot;Timed-out {} operations to channel {} for {}&quot;,</span>
<span class="nc" id="L1045">                     timedOutOperations, channel, bookieId);</span>
        }
<span class="nc" id="L1047">    }</span>

    /**
     * Disconnects the bookie client. It can be reused.
     */
    public void disconnect() {
<span class="nc" id="L1053">        disconnect(true);</span>
<span class="nc" id="L1054">    }</span>

    public void disconnect(boolean wait) {
<span class="nc" id="L1057">        LOG.info(&quot;Disconnecting the per channel bookie client for {}&quot;, bookieId);</span>
<span class="nc" id="L1058">        closeInternal(false, wait);</span>
<span class="nc" id="L1059">    }</span>

    /**
     * Closes the bookie client permanently. It cannot be reused.
     */
    public void close() {
<span class="nc" id="L1065">        close(true);</span>
<span class="nc" id="L1066">    }</span>

    public void close(boolean wait) {
<span class="nc" id="L1069">        LOG.info(&quot;Closing the per channel bookie client for {}&quot;, bookieId);</span>
<span class="nc" id="L1070">        closeLock.writeLock().lock();</span>
        try {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if (ConnectionState.CLOSED == state) {</span>
<span class="nc" id="L1073">                return;</span>
            }
<span class="nc" id="L1075">            state = ConnectionState.CLOSED;</span>
<span class="nc" id="L1076">            errorOutOutstandingEntries(BKException.Code.ClientClosedException);</span>
        } finally {
<span class="nc" id="L1078">            closeLock.writeLock().unlock();</span>
        }

<span class="nc bnc" id="L1081" title="All 4 branches missed.">        if (channel != null &amp;&amp; channel.pipeline().get(SslHandler.class) != null) {</span>
<span class="nc" id="L1082">            activeTlsChannelCounter.dec();</span>
        } else {
<span class="nc" id="L1084">            activeNonTlsChannelCounter.dec();</span>
        }

<span class="nc" id="L1087">        closeInternal(true, wait);</span>
<span class="nc" id="L1088">    }</span>

    private void closeInternal(boolean permanent, boolean wait) {
<span class="nc" id="L1091">        Channel toClose = null;</span>
<span class="nc" id="L1092">        synchronized (this) {</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">            if (permanent) {</span>
<span class="nc" id="L1094">                state = ConnectionState.CLOSED;</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            } else if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1096">                state = ConnectionState.DISCONNECTED;</span>
            }
<span class="nc" id="L1098">            toClose = channel;</span>
<span class="nc" id="L1099">            channel = null;</span>
<span class="nc" id="L1100">            makeWritable();</span>
<span class="nc" id="L1101">        }</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (toClose != null) {</span>
<span class="nc" id="L1103">            ChannelFuture cf = closeChannel(toClose);</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            if (wait) {</span>
<span class="nc" id="L1105">                cf.awaitUninterruptibly();</span>
            }
        }
<span class="nc" id="L1108">    }</span>

    private ChannelFuture closeChannel(Channel c) {
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1112">            LOG.debug(&quot;Closing channel {}&quot;, c);</span>
        }
<span class="nc" id="L1114">        return c.close().addListener(x -&gt; makeWritable());</span>
    }

    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L1119">        final Channel c = channel;</span>
<span class="nc bnc" id="L1120" title="All 4 branches missed.">        if (c == null || c.isWritable()) {</span>
<span class="nc" id="L1121">            makeWritable();</span>
        }
<span class="nc" id="L1123">        super.channelWritabilityChanged(ctx);</span>
<span class="nc" id="L1124">    }</span>

    private void writeAndFlush(final Channel channel,
                               final CompletionKey key,
                               final Object request) {
<span class="nc" id="L1129">        writeAndFlush(channel, key, request, false);</span>
<span class="nc" id="L1130">    }</span>

    private void writeAndFlush(final Channel channel,
                           final CompletionKey key,
                           final Object request,
                           final boolean allowFastFail) {
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        if (channel == null) {</span>
<span class="nc" id="L1137">            LOG.warn(&quot;Operation {} failed: channel == null&quot;, StringUtils.requestToString(request));</span>
<span class="nc" id="L1138">            errorOut(key);</span>
<span class="nc" id="L1139">            return;</span>
        }

<span class="nc" id="L1142">        final boolean isChannelWritable = channel.isWritable();</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        if (isWritable != isChannelWritable) {</span>
            // isWritable is volatile so simple &quot;isWritable = channel.isWritable()&quot; would be slower
<span class="nc" id="L1145">            isWritable = isChannelWritable;</span>
        }

<span class="nc bnc" id="L1148" title="All 4 branches missed.">        if (allowFastFail &amp;&amp; !isWritable) {</span>
<span class="nc" id="L1149">            LOG.warn(&quot;Operation {} failed: TooManyRequestsException&quot;,</span>
<span class="nc" id="L1150">                    StringUtils.requestToString(request));</span>

<span class="nc" id="L1152">            errorOut(key, BKException.Code.TooManyRequestsException);</span>
<span class="nc" id="L1153">            return;</span>
        }

        try {
<span class="nc" id="L1157">            final long startTime = MathUtils.nowInNano();</span>

<span class="nc" id="L1159">            ChannelPromise promise = channel.newPromise().addListener(future -&gt; {</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                if (future.isSuccess()) {</span>
<span class="nc" id="L1161">                    nettyOpLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L1162">                    CompletionValue completion = completionObjects.get(key);</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                    if (completion != null) {</span>
<span class="nc" id="L1164">                        completion.setOutstanding();</span>
                    }
<span class="nc" id="L1166">                } else {</span>
<span class="nc" id="L1167">                    nettyOpLogger.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
                }
<span class="nc" id="L1169">            });</span>
<span class="nc" id="L1170">            channel.writeAndFlush(request, promise);</span>
<span class="nc" id="L1171">        } catch (Throwable e) {</span>
<span class="nc" id="L1172">            LOG.warn(&quot;Operation {} failed&quot;, StringUtils.requestToString(request), e);</span>
<span class="nc" id="L1173">            errorOut(key);</span>
<span class="nc" id="L1174">        }</span>
<span class="nc" id="L1175">    }</span>

    void errorOut(final CompletionKey key) {
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1179">            LOG.debug(&quot;Removing completion key: {}&quot;, key);</span>
        }
<span class="nc" id="L1181">        CompletionValue completion = completionObjects.remove(key);</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (completion != null) {</span>
<span class="nc" id="L1183">            completion.errorOut();</span>
        } else {
            // If there's no completion object here, try in the multimap
<span class="nc" id="L1186">            completionObjectsV2Conflicts.removeAny(key).ifPresent(c -&gt; c.errorOut());</span>
        }
<span class="nc" id="L1188">    }</span>

    void errorOut(final CompletionKey key, final int rc) {
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1192">            LOG.debug(&quot;Removing completion key: {}&quot;, key);</span>
        }
<span class="nc" id="L1194">        CompletionValue completion = completionObjects.remove(key);</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        if (completion != null) {</span>
<span class="nc" id="L1196">            completion.errorOut(rc);</span>
        } else {
            // If there's no completion object here, try in the multimap
<span class="nc" id="L1199">            completionObjectsV2Conflicts.removeAny(key).ifPresent(c -&gt; c.errorOut(rc));</span>
        }
<span class="nc" id="L1201">    }</span>

    /**
     * Errors out pending ops from per channel bookie client. As the channel
     * is being closed, all the operations waiting on the connection
     * will be sent to completion with error.
     */
    void errorOutPendingOps(int rc) {
        Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;
<span class="nc" id="L1210">        synchronized (this) {</span>
<span class="nc" id="L1211">            oldPendingOps = pendingOps;</span>
<span class="nc" id="L1212">            pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L1213">        }</span>

<span class="nc bnc" id="L1215" title="All 2 branches missed.">        for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L1216">            pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="nc" id="L1217">        }</span>
<span class="nc" id="L1218">    }</span>

    /**
     * Errors out pending entries. We call this method from one thread to avoid
     * concurrent executions to QuorumOpMonitor (implements callbacks). It seems
     * simpler to call it from BookieHandle instead of calling directly from
     * here.
     */

    void errorOutOutstandingEntries(int rc) {
<span class="nc" id="L1228">        Optional&lt;CompletionKey&gt; multikey = completionObjectsV2Conflicts.getAnyKey();</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        while (multikey.isPresent()) {</span>
<span class="nc" id="L1230">            multikey.ifPresent(k -&gt; errorOut(k, rc));</span>
<span class="nc" id="L1231">            multikey = completionObjectsV2Conflicts.getAnyKey();</span>
        }
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        for (CompletionKey key : completionObjects.keys()) {</span>
<span class="nc" id="L1234">            errorOut(key, rc);</span>
<span class="nc" id="L1235">        }</span>
<span class="nc" id="L1236">    }</span>

    void recordError() {
<span class="nc bnc" id="L1239" title="All 2 branches missed.">        if (pcbcPool != null) {</span>
<span class="nc" id="L1240">            pcbcPool.recordError();</span>
        }
<span class="nc" id="L1242">    }</span>

    /**
     * If our channel has disconnected, we just error out the pending entries.
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L1249">        LOG.info(&quot;Disconnected from bookie channel {}&quot;, ctx.channel());</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        if (ctx.channel() != null) {</span>
<span class="nc" id="L1251">            closeChannel(ctx.channel());</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">            if (ctx.channel().pipeline().get(SslHandler.class) != null) {</span>
<span class="nc" id="L1253">                activeTlsChannelCounter.dec();</span>
            } else {
<span class="nc" id="L1255">                activeNonTlsChannelCounter.dec();</span>
            }
        }

<span class="nc" id="L1259">        errorOutOutstandingEntries(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1260">        errorOutPendingOps(BKException.Code.BookieHandleNotAvailableException);</span>

<span class="nc" id="L1262">        synchronized (this) {</span>
<span class="nc bnc" id="L1263" title="All 4 branches missed.">            if (this.channel == ctx.channel()</span>
                &amp;&amp; state != ConnectionState.CLOSED) {
<span class="nc" id="L1265">                state = ConnectionState.DISCONNECTED;</span>
            }
<span class="nc" id="L1267">        }</span>

        // we don't want to reconnect right away. If someone sends a request to
        // this address, we will reconnect.
<span class="nc" id="L1271">    }</span>

    /**
     * Called by netty when an exception happens in one of the netty threads
     * (mostly due to what we do in the netty threads).
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
<span class="nc" id="L1279">        exceptionCounter.inc();</span>
<span class="nc bnc" id="L1280" title="All 4 branches missed.">        if (cause instanceof CorruptedFrameException || cause instanceof TooLongFrameException) {</span>
<span class="nc" id="L1281">            LOG.error(&quot;Corrupted frame received from bookie: {}&quot;, ctx.channel());</span>
<span class="nc" id="L1282">            ctx.close();</span>
<span class="nc" id="L1283">            return;</span>
        }

<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if (cause instanceof AuthHandler.AuthenticationException) {</span>
<span class="nc" id="L1287">            LOG.error(&quot;Error authenticating connection&quot;, cause);</span>
<span class="nc" id="L1288">            errorOutOutstandingEntries(BKException.Code.UnauthorizedAccessException);</span>
<span class="nc" id="L1289">            Channel c = ctx.channel();</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L1291">                closeChannel(c);</span>
            }
<span class="nc" id="L1293">            return;</span>
        }

        // TLSv1.3 doesn't throw SSLHandshakeException for certificate issues
        // see https://stackoverflow.com/a/62465859 for details about the reason
        // therefore catch SSLException to also cover TLSv1.3
<span class="nc bnc" id="L1299" title="All 4 branches missed.">        if (cause instanceof DecoderException &amp;&amp; cause.getCause() instanceof SSLException) {</span>
<span class="nc" id="L1300">            LOG.error(&quot;TLS handshake failed&quot;, cause);</span>
<span class="nc" id="L1301">            errorOutPendingOps(BKException.Code.SecurityException);</span>
<span class="nc" id="L1302">            Channel c = ctx.channel();</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L1304">                closeChannel(c);</span>
            }
<span class="nc" id="L1306">            return;</span>
        }

<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if (cause instanceof IOException) {</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">            if (cause instanceof NativeIoException) {</span>
                // Stack trace is not very interesting for native IO exceptio, the important part is in
                // the exception message
<span class="nc" id="L1313">                LOG.warn(&quot;Exception caught on:{} cause: {}&quot;, ctx.channel(), cause.getMessage());</span>
            } else {
<span class="nc" id="L1315">                LOG.warn(&quot;Exception caught on:{} cause:&quot;, ctx.channel(), cause);</span>
            }
<span class="nc" id="L1317">            ctx.close();</span>
<span class="nc" id="L1318">            return;</span>
        }

<span class="nc" id="L1321">        synchronized (this) {</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            if (state == ConnectionState.CLOSED) {</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1324">                    LOG.debug(&quot;Unexpected exception caught by bookie client channel handler, &quot;</span>
                            + &quot;but the client is closed, so it isn't important&quot;, cause);
                }
            } else {
<span class="nc" id="L1328">                LOG.error(&quot;Unexpected exception caught by bookie client channel handler&quot;, cause);</span>
            }
<span class="nc" id="L1330">        }</span>

        // Since we are a library, cant terminate App here, can we?
<span class="nc" id="L1333">        ctx.close();</span>
<span class="nc" id="L1334">    }</span>

    /**
     * Called by netty when a message is received on a channel.
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

<span class="nc bnc" id="L1342" title="All 2 branches missed.">        if (msg instanceof BookieProtocol.Response) {</span>
<span class="nc" id="L1343">            BookieProtocol.Response response = (BookieProtocol.Response) msg;</span>
<span class="nc" id="L1344">            readV2Response(response);</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">        } else if (msg instanceof Response) {</span>
<span class="nc" id="L1346">            Response response = (Response) msg;</span>
<span class="nc" id="L1347">            readV3Response(response);</span>
<span class="nc" id="L1348">        } else {</span>
<span class="nc" id="L1349">            ctx.fireChannelRead(msg);</span>
        }
<span class="nc" id="L1351">    }</span>

    private void readV2Response(final BookieProtocol.Response response) {
<span class="nc" id="L1354">        OperationType operationType = getOperationType(response.getOpCode());</span>
<span class="nc" id="L1355">        StatusCode status = getStatusCodeFromErrorCode(response.errorCode);</span>

<span class="nc" id="L1357">        CompletionKey key = acquireV2Key(response.ledgerId, response.entryId, operationType);</span>
<span class="nc" id="L1358">        CompletionValue completionValue = getCompletionValue(key);</span>
<span class="nc" id="L1359">        key.release();</span>

<span class="nc bnc" id="L1361" title="All 2 branches missed.">        if (null == completionValue) {</span>
            // Unexpected response, so log it. The txnId should have been present.
<span class="nc bnc" id="L1363" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1364">                LOG.debug(&quot;Unexpected response received from bookie : &quot; + bookieId + &quot; for type : &quot; + operationType</span>
                        + &quot; and ledger:entry : &quot; + response.ledgerId + &quot;:&quot; + response.entryId);
            }
<span class="nc" id="L1367">            response.release();</span>
        } else {
<span class="nc" id="L1369">            long orderingKey = completionValue.ledgerId;</span>
<span class="nc" id="L1370">            executor.executeOrdered(orderingKey,</span>
<span class="nc" id="L1371">                    ReadV2ResponseCallback.create(completionValue, response.ledgerId, response.entryId,</span>
                                                  status, response));
        }
<span class="nc" id="L1374">    }</span>

    private static class ReadV2ResponseCallback implements Runnable {
        CompletionValue completionValue;
        long ledgerId;
        long entryId;
        StatusCode status;
        BookieProtocol.Response response;

        static ReadV2ResponseCallback create(CompletionValue completionValue, long ledgerId, long entryId,
                                             StatusCode status, BookieProtocol.Response response) {
<span class="nc" id="L1385">            ReadV2ResponseCallback callback = RECYCLER.get();</span>
<span class="nc" id="L1386">            callback.completionValue = completionValue;</span>
<span class="nc" id="L1387">            callback.ledgerId = ledgerId;</span>
<span class="nc" id="L1388">            callback.entryId = entryId;</span>
<span class="nc" id="L1389">            callback.status = status;</span>
<span class="nc" id="L1390">            callback.response = response;</span>
<span class="nc" id="L1391">            return callback;</span>
        }

        @Override
        public void run() {
<span class="nc" id="L1396">            completionValue.handleV2Response(ledgerId, entryId, status, response);</span>
<span class="nc" id="L1397">            response.release();</span>
<span class="nc" id="L1398">            response.recycle();</span>
<span class="nc" id="L1399">            recycle();</span>
<span class="nc" id="L1400">        }</span>

        void recycle() {
<span class="nc" id="L1403">            completionValue = null;</span>
<span class="nc" id="L1404">            ledgerId = -1;</span>
<span class="nc" id="L1405">            entryId = -1;</span>
<span class="nc" id="L1406">            status = null;</span>
<span class="nc" id="L1407">            response = null;</span>
<span class="nc" id="L1408">            recyclerHandle.recycle(this);</span>
<span class="nc" id="L1409">        }</span>

        private final Handle&lt;ReadV2ResponseCallback&gt; recyclerHandle;

<span class="nc" id="L1413">        private ReadV2ResponseCallback(Handle&lt;ReadV2ResponseCallback&gt; recyclerHandle) {</span>
<span class="nc" id="L1414">            this.recyclerHandle = recyclerHandle;</span>
<span class="nc" id="L1415">        }</span>

<span class="nc" id="L1417">        private static final Recycler&lt;ReadV2ResponseCallback&gt; RECYCLER = new Recycler&lt;ReadV2ResponseCallback&gt;() {</span>
            @Override
            protected ReadV2ResponseCallback newObject(Handle&lt;ReadV2ResponseCallback&gt; handle) {
<span class="nc" id="L1420">                return new ReadV2ResponseCallback(handle);</span>
            }
        };
    }

    private static OperationType getOperationType(byte opCode) {
<span class="nc bnc" id="L1426" title="All 7 branches missed.">        switch (opCode) {</span>
            case BookieProtocol.ADDENTRY:
<span class="nc" id="L1428">                return  OperationType.ADD_ENTRY;</span>
            case BookieProtocol.READENTRY:
<span class="nc" id="L1430">                return OperationType.READ_ENTRY;</span>
            case BookieProtocol.AUTH:
<span class="nc" id="L1432">                return OperationType.AUTH;</span>
            case BookieProtocol.READ_LAC:
<span class="nc" id="L1434">                return OperationType.READ_LAC;</span>
            case BookieProtocol.WRITE_LAC:
<span class="nc" id="L1436">                return OperationType.WRITE_LAC;</span>
            case BookieProtocol.GET_BOOKIE_INFO:
<span class="nc" id="L1438">                return OperationType.GET_BOOKIE_INFO;</span>
            default:
<span class="nc" id="L1440">                throw new IllegalArgumentException(&quot;Invalid operation type &quot; + opCode);</span>
        }
    }

    private static StatusCode getStatusCodeFromErrorCode(int errorCode) {
<span class="nc bnc" id="L1445" title="All 11 branches missed.">        switch (errorCode) {</span>
            case BookieProtocol.EOK:
<span class="nc" id="L1447">                return StatusCode.EOK;</span>
            case BookieProtocol.ENOLEDGER:
<span class="nc" id="L1449">                return StatusCode.ENOLEDGER;</span>
            case BookieProtocol.ENOENTRY:
<span class="nc" id="L1451">                return StatusCode.ENOENTRY;</span>
            case BookieProtocol.EBADREQ:
<span class="nc" id="L1453">                return StatusCode.EBADREQ;</span>
            case BookieProtocol.EIO:
<span class="nc" id="L1455">                return StatusCode.EIO;</span>
            case BookieProtocol.EUA:
<span class="nc" id="L1457">                return StatusCode.EUA;</span>
            case BookieProtocol.EBADVERSION:
<span class="nc" id="L1459">                return StatusCode.EBADVERSION;</span>
            case BookieProtocol.EFENCED:
<span class="nc" id="L1461">                return StatusCode.EFENCED;</span>
            case BookieProtocol.EREADONLY:
<span class="nc" id="L1463">                return StatusCode.EREADONLY;</span>
            case BookieProtocol.ETOOMANYREQUESTS:
<span class="nc" id="L1465">                return StatusCode.ETOOMANYREQUESTS;</span>
            default:
<span class="nc" id="L1467">                throw new IllegalArgumentException(&quot;Invalid error code: &quot; + errorCode);</span>
        }
    }

    private void readV3Response(final Response response) {
<span class="nc" id="L1472">        final BKPacketHeader header = response.getHeader();</span>

<span class="nc" id="L1474">        final CompletionKey key = newCompletionKey(header.getTxnId(), header.getOperation());</span>
<span class="nc" id="L1475">        final CompletionValue completionValue = completionObjects.get(key);</span>

<span class="nc bnc" id="L1477" title="All 2 branches missed.">        if (null == completionValue) {</span>
            // Unexpected response, so log it. The txnId should have been present.
<span class="nc bnc" id="L1479" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1480">                LOG.debug(&quot;Unexpected response received from bookie : &quot; + bookieId + &quot; for type : &quot;</span>
<span class="nc" id="L1481">                        + header.getOperation() + &quot; and txnId : &quot; + header.getTxnId());</span>
            }
        } else {
<span class="nc" id="L1484">            long orderingKey = completionValue.ledgerId;</span>
<span class="nc" id="L1485">            executor.executeOrdered(orderingKey, new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L1488">                    completionValue.restoreMdcContext();</span>
<span class="nc" id="L1489">                    completionValue.handleV3Response(response);</span>
<span class="nc" id="L1490">                }</span>

                @Override
                public String toString() {
<span class="nc" id="L1494">                    return String.format(&quot;HandleResponse(Txn=%d, Type=%s, Entry=(%d, %d))&quot;,</span>
<span class="nc" id="L1495">                                         header.getTxnId(), header.getOperation(),</span>
<span class="nc" id="L1496">                                         completionValue.ledgerId, completionValue.entryId);</span>
                }
            });
        }

<span class="nc" id="L1501">        completionObjects.remove(key);</span>
<span class="nc" id="L1502">    }</span>

    void initTLSHandshake() {
        // create TLS handler
<span class="nc" id="L1506">        PerChannelBookieClient parentObj = PerChannelBookieClient.this;</span>
<span class="nc" id="L1507">        SocketAddress socketAddress = channel.remoteAddress();</span>
        InetSocketAddress address;
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        if (socketAddress instanceof LocalAddress) {</span>
            // if it is a local address, it looks like this: local:hostname:port
<span class="nc" id="L1511">            String[] addr = socketAddress.toString().split(&quot;:&quot;);</span>
<span class="nc" id="L1512">            String hostname = addr[1];</span>
<span class="nc" id="L1513">            int port = Integer.parseInt(addr[2]);</span>
<span class="nc" id="L1514">            address = new InetSocketAddress(hostname, port);</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">        } else if (socketAddress instanceof InetSocketAddress) {</span>
<span class="nc" id="L1516">            address = (InetSocketAddress) socketAddress;</span>
        } else {
<span class="nc" id="L1518">            throw new RuntimeException(&quot;Unexpected socket address type&quot;);</span>
        }
<span class="nc" id="L1520">        SslHandler handler = parentObj.shFactory.newTLSHandler(address.getHostName(), address.getPort());</span>
<span class="nc" id="L1521">        channel.pipeline().addFirst(parentObj.shFactory.getHandlerName(), handler);</span>
<span class="nc" id="L1522">        handler.handshakeFuture().addListener(new GenericFutureListener&lt;Future&lt;Channel&gt;&gt;() {</span>
                @Override
                public void operationComplete(Future&lt;Channel&gt; future) throws Exception {
                    int rc;
                    Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;

<span class="nc" id="L1528">                    synchronized (PerChannelBookieClient.this) {</span>
<span class="nc bnc" id="L1529" title="All 4 branches missed.">                        if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTING) {</span>
<span class="nc" id="L1530">                            LOG.error(&quot;Connection state changed before TLS handshake completed {}/{}&quot;, bookieId, state);</span>
<span class="nc" id="L1531">                            rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1532">                            closeChannel(channel);</span>
<span class="nc" id="L1533">                            channel = null;</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                            if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1535">                                state = ConnectionState.DISCONNECTED;</span>
                            }
<span class="nc bnc" id="L1537" title="All 4 branches missed.">                        } else if (future.isSuccess() &amp;&amp; state == ConnectionState.START_TLS) {</span>
<span class="nc" id="L1538">                            rc = BKException.Code.OK;</span>
<span class="nc" id="L1539">                            LOG.info(&quot;Successfully connected to bookie using TLS: &quot; + bookieId);</span>

<span class="nc" id="L1541">                            state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L1542">                            AuthHandler.ClientSideHandler authHandler = future.get().pipeline()</span>
<span class="nc" id="L1543">                                    .get(AuthHandler.ClientSideHandler.class);</span>
<span class="nc" id="L1544">                            authHandler.authProvider.onProtocolUpgrade();</span>
<span class="nc" id="L1545">                            activeTlsChannelCounter.inc();</span>
<span class="nc bnc" id="L1546" title="All 6 branches missed.">                        } else if (future.isSuccess()</span>
                                &amp;&amp; (state == ConnectionState.CLOSED || state == ConnectionState.DISCONNECTED)) {
<span class="nc" id="L1548">                            LOG.warn(&quot;Closed before TLS handshake completed, clean up: {}, current state {}&quot;,</span>
                                    channel, state);
<span class="nc" id="L1550">                            closeChannel(channel);</span>
<span class="nc" id="L1551">                            rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1552">                            channel = null;</span>
<span class="nc bnc" id="L1553" title="All 4 branches missed.">                        } else if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1555">                                LOG.debug(&quot;Already connected with another channel({}), &quot;</span>
                                                + &quot;so close the new channel({})&quot;,
                                        channel, channel);
                            }
<span class="nc" id="L1559">                            closeChannel(channel);</span>
<span class="nc" id="L1560">                            return; // pendingOps should have been completed when other channel connected</span>
                        } else {
<span class="nc" id="L1562">                            LOG.error(&quot;TLS handshake failed with bookie: {}/{}, current state {} : &quot;,</span>
<span class="nc" id="L1563">                                    channel, bookieId, state, future.cause());</span>
<span class="nc" id="L1564">                            rc = BKException.Code.SecurityException;</span>
<span class="nc" id="L1565">                            closeChannel(channel);</span>
<span class="nc" id="L1566">                            channel = null;</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                            if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1568">                                state = ConnectionState.DISCONNECTED;</span>
                            }
<span class="nc" id="L1570">                            failedTlsHandshakeCounter.inc();</span>
                        }

                        // trick to not do operations under the lock, take the list
                        // of pending ops and assign it to a new variable, while
                        // emptying the pending ops by just assigning it to a new
                        // list
<span class="nc" id="L1577">                        oldPendingOps = pendingOps;</span>
<span class="nc" id="L1578">                        pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L1579">                    }</span>

<span class="nc" id="L1581">                    makeWritable();</span>

<span class="nc bnc" id="L1583" title="All 2 branches missed.">                    for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L1584">                        pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="nc" id="L1585">                    }</span>
<span class="nc" id="L1586">                }</span>
            });
<span class="nc" id="L1588">    }</span>

    /**
     * Boiler-plate wrapper classes follow.
     *
     */

    // visible for testing
    abstract class CompletionValue {
        private final OpStatsLogger opLogger;
        private final OpStatsLogger timeoutOpLogger;
        private final String operationName;
        private final Map&lt;String, String&gt; mdcContextMap;
        protected Object ctx;
        protected long ledgerId;
        protected long entryId;
        protected long startTime;

        public CompletionValue(String operationName,
                               Object ctx,
                               long ledgerId, long entryId,
                               OpStatsLogger opLogger,
<span class="nc" id="L1610">                               OpStatsLogger timeoutOpLogger) {</span>
<span class="nc" id="L1611">            this.operationName = operationName;</span>
<span class="nc" id="L1612">            this.ctx = ctx;</span>
<span class="nc" id="L1613">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L1614">            this.entryId = entryId;</span>
<span class="nc" id="L1615">            this.startTime = MathUtils.nowInNano();</span>
<span class="nc" id="L1616">            this.opLogger = opLogger;</span>
<span class="nc" id="L1617">            this.timeoutOpLogger = timeoutOpLogger;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">            this.mdcContextMap = preserveMdcForTaskExecution ? MDC.getCopyOfContextMap() : null;</span>
<span class="nc" id="L1619">        }</span>

        private long latency() {
<span class="nc" id="L1622">            return MathUtils.elapsedNanos(startTime);</span>
        }

        void logOpResult(int rc) {
<span class="nc bnc" id="L1626" title="All 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L1627">                opLogger.registerFailedEvent(latency(), TimeUnit.NANOSECONDS);</span>
            } else {
<span class="nc" id="L1629">                opLogger.registerSuccessfulEvent(latency(), TimeUnit.NANOSECONDS);</span>
            }

<span class="nc bnc" id="L1632" title="All 2 branches missed.">            if (rc != BKException.Code.OK</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">                &amp;&amp; !expectedBkOperationErrors.contains(rc)) {</span>
<span class="nc" id="L1634">                recordError();</span>
            }
<span class="nc" id="L1636">        }</span>

        boolean maybeTimeout() {
<span class="nc bnc" id="L1639" title="All 2 branches missed.">            if (MathUtils.elapsedNanos(startTime) &gt;= readEntryTimeoutNanos) {</span>
<span class="nc" id="L1640">                timeout();</span>
<span class="nc" id="L1641">                return true;</span>
            } else {
<span class="nc" id="L1643">                return false;</span>
            }
        }

        void timeout() {
<span class="nc" id="L1648">            errorOut(BKException.Code.TimeoutException);</span>
<span class="nc" id="L1649">            timeoutOpLogger.registerSuccessfulEvent(latency(),</span>
                                                    TimeUnit.NANOSECONDS);
<span class="nc" id="L1651">        }</span>

        protected void logResponse(StatusCode status, Object... extraInfo) {
<span class="nc bnc" id="L1654" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1655">                LOG.debug(&quot;Got {} response from bookie:{} rc:{}, {}&quot;, operationName, bookieId, status,</span>
<span class="nc" id="L1656">                        Joiner.on(&quot;:&quot;).join(extraInfo));</span>
            }
<span class="nc" id="L1658">        }</span>

        protected int convertStatus(StatusCode status, int defaultStatus) {
            // convert to BKException code
<span class="nc" id="L1662">            int rcToRet = statusCodeToExceptionCode(status);</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">            if (rcToRet == BKException.Code.UNINITIALIZED) {</span>
<span class="nc" id="L1664">                LOG.error(&quot;{} for failed on bookie {} code {}&quot;,</span>
                          operationName, bookieId, status);
<span class="nc" id="L1666">                return defaultStatus;</span>
            } else {
<span class="nc" id="L1668">                return rcToRet;</span>
            }
        }

        public void restoreMdcContext() {
<span class="nc" id="L1673">            MdcUtils.restoreContext(mdcContextMap);</span>
<span class="nc" id="L1674">        }</span>

        public abstract void errorOut();
        public abstract void errorOut(int rc);
        public void setOutstanding() {
            // no-op
<span class="nc" id="L1680">        }</span>

        protected void errorOutAndRunCallback(final Runnable callback) {
<span class="nc" id="L1683">            executor.executeOrdered(ledgerId, () -&gt; {</span>
<span class="nc" id="L1684">                String bAddress = &quot;null&quot;;</span>
<span class="nc" id="L1685">                Channel c = channel;</span>
<span class="nc bnc" id="L1686" title="All 4 branches missed.">                if (c != null &amp;&amp; c.remoteAddress() != null) {</span>
<span class="nc" id="L1687">                    bAddress = c.remoteAddress().toString();</span>
                }
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1690">                    LOG.debug(&quot;Could not write {} request to bookie {} for ledger {}, entry {}&quot;,</span>
                            operationName, bAddress,
<span class="nc" id="L1692">                            ledgerId, entryId);</span>
                }
<span class="nc" id="L1694">                callback.run();</span>
<span class="nc" id="L1695">            });</span>
<span class="nc" id="L1696">        }</span>

        public void handleV2Response(
                long ledgerId, long entryId, StatusCode status,
                BookieProtocol.Response response) {
<span class="nc" id="L1701">            LOG.warn(&quot;Unhandled V2 response {}&quot;, response);</span>
<span class="nc" id="L1702">        }</span>

        public abstract void handleV3Response(
                BookkeeperProtocol.Response response);
    }

    // visible for testing
    class WriteLacCompletion extends CompletionValue {
        final WriteLacCallback cb;

        public WriteLacCompletion(final CompletionKey key,
                                  final WriteLacCallback originalCallback,
                                  final Object originalCtx,
<span class="nc" id="L1715">                                  final long ledgerId) {</span>
<span class="nc" id="L1716">            super(&quot;WriteLAC&quot;,</span>
                  originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,
<span class="nc" id="L1718">                  writeLacOpLogger, writeLacTimeoutOpLogger);</span>
<span class="nc" id="L1719">            this.cb = new WriteLacCallback() {</span>
                    @Override
                    public void writeLacComplete(int rc, long ledgerId,
                                                 BookieId addr,
                                                 Object ctx) {
<span class="nc" id="L1724">                        logOpResult(rc);</span>
<span class="nc" id="L1725">                        originalCallback.writeLacComplete(rc, ledgerId,</span>
                                                          addr, originalCtx);
<span class="nc" id="L1727">                        key.release();</span>
<span class="nc" id="L1728">                    }</span>
                };
<span class="nc" id="L1730">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1734">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1735">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1739">            errorOutAndRunCallback(</span>
<span class="nc" id="L1740">                    () -&gt; cb.writeLacComplete(rc, ledgerId, bookieId, ctx));</span>
<span class="nc" id="L1741">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1745">            WriteLacResponse writeLacResponse = response.getWriteLacResponse();</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1747">                ? writeLacResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L1748">            long ledgerId = writeLacResponse.getLedgerId();</span>

<span class="nc bnc" id="L1750" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1751">                logResponse(status, &quot;ledger&quot;, ledgerId);</span>
            }
<span class="nc" id="L1753">            int rc = convertStatus(status, BKException.Code.WriteException);</span>
<span class="nc" id="L1754">            cb.writeLacComplete(rc, ledgerId, bookieId, ctx);</span>
<span class="nc" id="L1755">        }</span>
    }

    class ForceLedgerCompletion extends CompletionValue {
        final ForceLedgerCallback cb;

        public ForceLedgerCompletion(final CompletionKey key,
                                  final ForceLedgerCallback originalCallback,
                                  final Object originalCtx,
<span class="nc" id="L1764">                                  final long ledgerId) {</span>
<span class="nc" id="L1765">            super(&quot;ForceLedger&quot;,</span>
                  originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,
<span class="nc" id="L1767">                  forceLedgerOpLogger, forceLedgerTimeoutOpLogger);</span>
<span class="nc" id="L1768">            this.cb = new ForceLedgerCallback() {</span>
                    @Override
                    public void forceLedgerComplete(int rc, long ledgerId,
                                                 BookieId addr,
                                                 Object ctx) {
<span class="nc" id="L1773">                        logOpResult(rc);</span>
<span class="nc" id="L1774">                        originalCallback.forceLedgerComplete(rc, ledgerId,</span>
                                                          addr, originalCtx);
<span class="nc" id="L1776">                        key.release();</span>
<span class="nc" id="L1777">                    }</span>
                };
<span class="nc" id="L1779">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1783">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1784">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1788">            errorOutAndRunCallback(</span>
<span class="nc" id="L1789">                    () -&gt; cb.forceLedgerComplete(rc, ledgerId, bookieId, ctx));</span>
<span class="nc" id="L1790">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1794">            ForceLedgerResponse forceLedgerResponse = response.getForceLedgerResponse();</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1796">                ? forceLedgerResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L1797">            long ledgerId = forceLedgerResponse.getLedgerId();</span>

<span class="nc bnc" id="L1799" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1800">                logResponse(status, &quot;ledger&quot;, ledgerId);</span>
            }
<span class="nc" id="L1802">            int rc = convertStatus(status, BKException.Code.WriteException);</span>
<span class="nc" id="L1803">            cb.forceLedgerComplete(rc, ledgerId, bookieId, ctx);</span>
<span class="nc" id="L1804">        }</span>
    }

    // visible for testing
    class ReadLacCompletion extends CompletionValue {
        final ReadLacCallback cb;

        public ReadLacCompletion(final CompletionKey key,
                                 ReadLacCallback originalCallback,
<span class="nc" id="L1813">                                 final Object ctx, final long ledgerId) {</span>
<span class="nc" id="L1814">            super(&quot;ReadLAC&quot;, ctx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,</span>
<span class="nc" id="L1815">                  readLacOpLogger, readLacTimeoutOpLogger);</span>
<span class="nc" id="L1816">            this.cb = new ReadLacCallback() {</span>
                    @Override
                    public void readLacComplete(int rc, long ledgerId,
                                                ByteBuf lacBuffer,
                                                ByteBuf lastEntryBuffer,
                                                Object ctx) {
<span class="nc" id="L1822">                        logOpResult(rc);</span>
<span class="nc" id="L1823">                        originalCallback.readLacComplete(</span>
                                rc, ledgerId, lacBuffer, lastEntryBuffer, ctx);
<span class="nc" id="L1825">                        key.release();</span>
<span class="nc" id="L1826">                    }</span>
                };
<span class="nc" id="L1828">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1832">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1833">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1837">            errorOutAndRunCallback(</span>
<span class="nc" id="L1838">                    () -&gt; cb.readLacComplete(rc, ledgerId, null, null, ctx));</span>
<span class="nc" id="L1839">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1843">            ReadLacResponse readLacResponse = response.getReadLacResponse();</span>
<span class="nc" id="L1844">            ByteBuf lacBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc" id="L1845">            ByteBuf lastEntryBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc bnc" id="L1846" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1847">                ? readLacResponse.getStatus() : response.getStatus();</span>

<span class="nc bnc" id="L1849" title="All 2 branches missed.">            if (readLacResponse.hasLacBody()) {</span>
<span class="nc" id="L1850">                lacBuffer = Unpooled.wrappedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());</span>
            }

<span class="nc bnc" id="L1853" title="All 2 branches missed.">            if (readLacResponse.hasLastEntryBody()) {</span>
<span class="nc" id="L1854">                lastEntryBuffer = Unpooled.wrappedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());</span>
            }

<span class="nc bnc" id="L1857" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1858">                logResponse(status, &quot;ledgerId&quot;, ledgerId);</span>
            }

<span class="nc" id="L1861">            int rc = convertStatus(status, BKException.Code.ReadException);</span>
<span class="nc" id="L1862">            cb.readLacComplete(rc, ledgerId, lacBuffer.slice(),</span>
<span class="nc" id="L1863">                               lastEntryBuffer.slice(), ctx);</span>
<span class="nc" id="L1864">        }</span>
    }

    // visible for testing
    class ReadCompletion extends CompletionValue {
        final ReadEntryCallback cb;

        public ReadCompletion(final CompletionKey key,
                              final ReadEntryCallback originalCallback,
                              final Object originalCtx,
<span class="nc" id="L1874">                              long ledgerId, final long entryId) {</span>
<span class="nc" id="L1875">            super(&quot;Read&quot;, originalCtx, ledgerId, entryId,</span>
<span class="nc" id="L1876">                  readEntryOpLogger, readTimeoutOpLogger);</span>

<span class="nc" id="L1878">            this.cb = new ReadEntryCallback() {</span>
                    @Override
                    public void readEntryComplete(int rc, long ledgerId,
                                                  long entryId, ByteBuf buffer,
                                                  Object ctx) {
<span class="nc" id="L1883">                        logOpResult(rc);</span>
<span class="nc" id="L1884">                        originalCallback.readEntryComplete(rc,</span>
                                                           ledgerId, entryId,
                                                           buffer, originalCtx);
<span class="nc" id="L1887">                        key.release();</span>
<span class="nc" id="L1888">                    }</span>
                };
<span class="nc" id="L1890">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1894">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1895">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1899">            errorOutAndRunCallback(</span>
<span class="nc" id="L1900">                    () -&gt; cb.readEntryComplete(rc, ledgerId,</span>
                                               entryId, null, ctx));
<span class="nc" id="L1902">        }</span>

        @Override
        public void setOutstanding() {
<span class="nc" id="L1906">            readEntryOutstanding.inc();</span>
<span class="nc" id="L1907">        }</span>

        @Override
        public void handleV2Response(long ledgerId, long entryId,
                                     StatusCode status,
                                     BookieProtocol.Response response) {
<span class="nc" id="L1913">            readEntryOutstanding.dec();</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">            if (!(response instanceof BookieProtocol.ReadResponse)) {</span>
<span class="nc" id="L1915">                return;</span>
            }
<span class="nc" id="L1917">            BookieProtocol.ReadResponse readResponse = (BookieProtocol.ReadResponse) response;</span>
<span class="nc" id="L1918">            handleReadResponse(ledgerId, entryId, status, readResponse.getData(),</span>
                               INVALID_ENTRY_ID, -1L);
<span class="nc" id="L1920">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1924">            readEntryOutstanding.dec();</span>
<span class="nc" id="L1925">            ReadResponse readResponse = response.getReadResponse();</span>
<span class="nc bnc" id="L1926" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1927">                ? readResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L1928">            ByteBuf buffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">            if (readResponse.hasBody()) {</span>
<span class="nc" id="L1930">                buffer = Unpooled.wrappedBuffer(readResponse.getBody().asReadOnlyByteBuffer());</span>
            }
<span class="nc" id="L1932">            long maxLAC = INVALID_ENTRY_ID;</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">            if (readResponse.hasMaxLAC()) {</span>
<span class="nc" id="L1934">                maxLAC = readResponse.getMaxLAC();</span>
            }
<span class="nc" id="L1936">            long lacUpdateTimestamp = -1L;</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">            if (readResponse.hasLacUpdateTimestamp()) {</span>
<span class="nc" id="L1938">                lacUpdateTimestamp = readResponse.getLacUpdateTimestamp();</span>
            }
<span class="nc" id="L1940">            handleReadResponse(readResponse.getLedgerId(),</span>
<span class="nc" id="L1941">                               readResponse.getEntryId(),</span>
                               status, buffer, maxLAC, lacUpdateTimestamp);
<span class="nc" id="L1943">            ReferenceCountUtil.release(</span>
                    buffer); // meaningless using unpooled, but client may expect to hold the last reference
<span class="nc" id="L1945">        }</span>

        private void handleReadResponse(long ledgerId,
                                        long entryId,
                                        StatusCode status,
                                        ByteBuf buffer,
                                        long maxLAC, // max known lac piggy-back from bookies
                                        long lacUpdateTimestamp) { // the timestamp when the lac is updated.
<span class="nc" id="L1953">            int readableBytes = buffer.readableBytes();</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1955">                logResponse(status, &quot;ledger&quot;, ledgerId, &quot;entry&quot;, entryId, &quot;entryLength&quot;, readableBytes);</span>
            }

<span class="nc" id="L1958">            int rc = convertStatus(status, BKException.Code.ReadException);</span>

<span class="nc bnc" id="L1960" title="All 4 branches missed.">            if (maxLAC &gt; INVALID_ENTRY_ID &amp;&amp; (ctx instanceof ReadEntryCallbackCtx)) {</span>
<span class="nc" id="L1961">                ((ReadEntryCallbackCtx) ctx).setLastAddConfirmed(maxLAC);</span>
            }
<span class="nc bnc" id="L1963" title="All 4 branches missed.">            if (lacUpdateTimestamp &gt; -1L &amp;&amp; (ctx instanceof ReadLastConfirmedAndEntryContext)) {</span>
<span class="nc" id="L1964">                ((ReadLastConfirmedAndEntryContext) ctx).setLacUpdateTimestamp(lacUpdateTimestamp);</span>
            }
<span class="nc" id="L1966">            cb.readEntryComplete(rc, ledgerId, entryId, buffer.slice(), ctx);</span>
<span class="nc" id="L1967">        }</span>
    }

    class StartTLSCompletion extends CompletionValue {
        final StartTLSCallback cb;

<span class="nc" id="L1973">        public StartTLSCompletion(final CompletionKey key) {</span>
<span class="nc" id="L1974">            super(&quot;StartTLS&quot;, null, -1, -1,</span>
<span class="nc" id="L1975">                  startTLSOpLogger, startTLSTimeoutOpLogger);</span>
<span class="nc" id="L1976">            this.cb = new StartTLSCallback() {</span>
                @Override
                public void startTLSComplete(int rc, Object ctx) {
<span class="nc" id="L1979">                    logOpResult(rc);</span>
<span class="nc" id="L1980">                    key.release();</span>
<span class="nc" id="L1981">                }</span>
            };
<span class="nc" id="L1983">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1987">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1988">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1992">            failTLS(rc);</span>
<span class="nc" id="L1993">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1997">            StatusCode status = response.getStatus();</span>

<span class="nc bnc" id="L1999" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2000">                logResponse(status);</span>
            }

<span class="nc" id="L2003">            int rc = convertStatus(status, BKException.Code.SecurityException);</span>

            // Cancel START_TLS request timeout
<span class="nc" id="L2006">            cb.startTLSComplete(rc, null);</span>

<span class="nc bnc" id="L2008" title="All 2 branches missed.">            if (state != ConnectionState.START_TLS) {</span>
<span class="nc" id="L2009">                LOG.error(&quot;Connection state changed before TLS response received&quot;);</span>
<span class="nc" id="L2010">                failTLS(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            } else if (status != StatusCode.EOK) {</span>
<span class="nc" id="L2012">                LOG.error(&quot;Client received error {} during TLS negotiation&quot;, status);</span>
<span class="nc" id="L2013">                failTLS(BKException.Code.SecurityException);</span>
            } else {
<span class="nc" id="L2015">                initTLSHandshake();</span>
            }
<span class="nc" id="L2017">        }</span>

    }

    // visible for testing
    class GetBookieInfoCompletion extends CompletionValue {
        final GetBookieInfoCallback cb;

        public GetBookieInfoCompletion(final CompletionKey key,
                                       final GetBookieInfoCallback origCallback,
<span class="nc" id="L2027">                                       final Object origCtx) {</span>
<span class="nc" id="L2028">            super(&quot;GetBookieInfo&quot;, origCtx, 0L, 0L,</span>
<span class="nc" id="L2029">                  getBookieInfoOpLogger, getBookieInfoTimeoutOpLogger);</span>
<span class="nc" id="L2030">            this.cb = new GetBookieInfoCallback() {</span>
                @Override
                public void getBookieInfoComplete(int rc, BookieInfo bInfo,
                                                  Object ctx) {
<span class="nc" id="L2034">                    logOpResult(rc);</span>
<span class="nc" id="L2035">                    origCallback.getBookieInfoComplete(rc, bInfo, origCtx);</span>
<span class="nc" id="L2036">                    key.release();</span>
<span class="nc" id="L2037">                }</span>
            };
<span class="nc" id="L2039">        }</span>

        @Override
        boolean maybeTimeout() {
<span class="nc bnc" id="L2043" title="All 2 branches missed.">            if (MathUtils.elapsedNanos(startTime) &gt;= getBookieInfoTimeoutNanos) {</span>
<span class="nc" id="L2044">                timeout();</span>
<span class="nc" id="L2045">                return true;</span>
            } else {
<span class="nc" id="L2047">                return false;</span>
            }
        }

        @Override
        public void errorOut() {
<span class="nc" id="L2053">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2054">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2058">            errorOutAndRunCallback(</span>
<span class="nc" id="L2059">                    () -&gt; cb.getBookieInfoComplete(rc, new BookieInfo(), ctx));</span>
<span class="nc" id="L2060">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L2064">            GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L2066">                ? getBookieInfoResponse.getStatus() : response.getStatus();</span>

<span class="nc" id="L2068">            long freeDiskSpace = getBookieInfoResponse.getFreeDiskSpace();</span>
<span class="nc" id="L2069">            long totalDiskSpace = getBookieInfoResponse.getTotalDiskCapacity();</span>

<span class="nc bnc" id="L2071" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2072">                logResponse(status, &quot;freeDisk&quot;, freeDiskSpace, &quot;totalDisk&quot;, totalDiskSpace);</span>
            }

<span class="nc" id="L2075">            int rc = convertStatus(status, BKException.Code.ReadException);</span>
<span class="nc" id="L2076">            cb.getBookieInfoComplete(rc,</span>
                                     new BookieInfo(totalDiskSpace,
                                                    freeDiskSpace), ctx);
<span class="nc" id="L2079">        }</span>
    }

    class GetListOfEntriesOfLedgerCompletion extends CompletionValue {
        final GetListOfEntriesOfLedgerCallback cb;

        public GetListOfEntriesOfLedgerCompletion(final CompletionKey key,
<span class="nc" id="L2086">                final GetListOfEntriesOfLedgerCallback origCallback, final long ledgerId) {</span>
<span class="nc" id="L2087">            super(&quot;GetListOfEntriesOfLedger&quot;, null, ledgerId, 0L, getListOfEntriesOfLedgerCompletionOpLogger,</span>
<span class="nc" id="L2088">                    getListOfEntriesOfLedgerCompletionTimeoutOpLogger);</span>
<span class="nc" id="L2089">            this.cb = new GetListOfEntriesOfLedgerCallback() {</span>
                @Override
                public void getListOfEntriesOfLedgerComplete(int rc, long ledgerId,
                        AvailabilityOfEntriesOfLedger availabilityOfEntriesOfLedger) {
<span class="nc" id="L2093">                    logOpResult(rc);</span>
<span class="nc" id="L2094">                    origCallback.getListOfEntriesOfLedgerComplete(rc, ledgerId, availabilityOfEntriesOfLedger);</span>
<span class="nc" id="L2095">                    key.release();</span>
<span class="nc" id="L2096">                }</span>
            };
<span class="nc" id="L2098">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L2102">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2103">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2107">            errorOutAndRunCallback(() -&gt; cb.getListOfEntriesOfLedgerComplete(rc, ledgerId, null));</span>
<span class="nc" id="L2108">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L2112">            GetListOfEntriesOfLedgerResponse getListOfEntriesOfLedgerResponse = response</span>
<span class="nc" id="L2113">                    .getGetListOfEntriesOfLedgerResponse();</span>
<span class="nc" id="L2114">            ByteBuf availabilityOfEntriesOfLedgerBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK ? getListOfEntriesOfLedgerResponse.getStatus()</span>
<span class="nc" id="L2116">                    : response.getStatus();</span>

<span class="nc bnc" id="L2118" title="All 2 branches missed.">            if (getListOfEntriesOfLedgerResponse.hasAvailabilityOfEntriesOfLedger()) {</span>
<span class="nc" id="L2119">                availabilityOfEntriesOfLedgerBuffer = Unpooled.wrappedBuffer(</span>
<span class="nc" id="L2120">                        getListOfEntriesOfLedgerResponse.getAvailabilityOfEntriesOfLedger().asReadOnlyByteBuffer());</span>
            }

<span class="nc bnc" id="L2123" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2124">                logResponse(status, &quot;ledgerId&quot;, ledgerId);</span>
            }

<span class="nc" id="L2127">            int rc = convertStatus(status, BKException.Code.ReadException);</span>
<span class="nc" id="L2128">            AvailabilityOfEntriesOfLedger availabilityOfEntriesOfLedger = null;</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">            if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L2130">                availabilityOfEntriesOfLedger = new AvailabilityOfEntriesOfLedger(</span>
<span class="nc" id="L2131">                        availabilityOfEntriesOfLedgerBuffer.slice());</span>
            }
<span class="nc" id="L2133">            cb.getListOfEntriesOfLedgerComplete(rc, ledgerId, availabilityOfEntriesOfLedger);</span>
<span class="nc" id="L2134">        }</span>
    }

<span class="nc" id="L2137">    private final Recycler&lt;AddCompletion&gt; addCompletionRecycler = new Recycler&lt;AddCompletion&gt;() {</span>
            @Override
            protected AddCompletion newObject(Recycler.Handle&lt;AddCompletion&gt; handle) {
<span class="nc" id="L2140">                return new AddCompletion(handle);</span>
            }
        };

    AddCompletion acquireAddCompletion(final CompletionKey key,
                                       final WriteCallback originalCallback,
                                       final Object originalCtx,
                                       final long ledgerId, final long entryId) {
<span class="nc" id="L2148">        AddCompletion completion = addCompletionRecycler.get();</span>
<span class="nc" id="L2149">        completion.reset(key, originalCallback, originalCtx, ledgerId, entryId);</span>
<span class="nc" id="L2150">        return completion;</span>
    }

    // visible for testing
    class AddCompletion extends CompletionValue implements WriteCallback {
        final Recycler.Handle&lt;AddCompletion&gt; handle;

<span class="nc" id="L2157">        CompletionKey key = null;</span>
<span class="nc" id="L2158">        WriteCallback originalCallback = null;</span>

<span class="nc" id="L2160">        AddCompletion(Recycler.Handle&lt;AddCompletion&gt; handle) {</span>
<span class="nc" id="L2161">            super(&quot;Add&quot;, null, -1, -1, addEntryOpLogger, addTimeoutOpLogger);</span>
<span class="nc" id="L2162">            this.handle = handle;</span>
<span class="nc" id="L2163">        }</span>

        void reset(final CompletionKey key,
                   final WriteCallback originalCallback,
                   final Object originalCtx,
                   final long ledgerId, final long entryId) {
<span class="nc" id="L2169">            this.key = key;</span>
<span class="nc" id="L2170">            this.originalCallback = originalCallback;</span>
<span class="nc" id="L2171">            this.ctx = originalCtx;</span>
<span class="nc" id="L2172">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L2173">            this.entryId = entryId;</span>
<span class="nc" id="L2174">            this.startTime = MathUtils.nowInNano();</span>
<span class="nc" id="L2175">        }</span>

        @Override
        public void writeComplete(int rc, long ledgerId, long entryId,
                                  BookieId addr,
                                  Object ctx) {
<span class="nc" id="L2181">            logOpResult(rc);</span>
<span class="nc" id="L2182">            originalCallback.writeComplete(rc, ledgerId, entryId, addr, ctx);</span>
<span class="nc" id="L2183">            key.release();</span>
<span class="nc" id="L2184">            handle.recycle(this);</span>
<span class="nc" id="L2185">        }</span>

        @Override
        boolean maybeTimeout() {
<span class="nc bnc" id="L2189" title="All 2 branches missed.">            if (MathUtils.elapsedNanos(startTime) &gt;= addEntryTimeoutNanos) {</span>
<span class="nc" id="L2190">                timeout();</span>
<span class="nc" id="L2191">                return true;</span>
            } else {
<span class="nc" id="L2193">                return false;</span>
            }
        }

        @Override
        public void errorOut() {
<span class="nc" id="L2199">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2200">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2204">            errorOutAndRunCallback(</span>
<span class="nc" id="L2205">                    () -&gt; writeComplete(rc, ledgerId, entryId, bookieId, ctx));</span>
<span class="nc" id="L2206">        }</span>

        @Override
        public void setOutstanding() {
<span class="nc" id="L2210">            addEntryOutstanding.inc();</span>
<span class="nc" id="L2211">        }</span>

        @Override
        public void handleV2Response(
                long ledgerId, long entryId, StatusCode status,
                BookieProtocol.Response response) {
<span class="nc" id="L2217">            addEntryOutstanding.dec();</span>
<span class="nc" id="L2218">            handleResponse(ledgerId, entryId, status);</span>
<span class="nc" id="L2219">        }</span>

        @Override
        public void handleV3Response(
                BookkeeperProtocol.Response response) {
<span class="nc" id="L2224">            addEntryOutstanding.dec();</span>
<span class="nc" id="L2225">            AddResponse addResponse = response.getAddResponse();</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L2227">                ? addResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L2228">            handleResponse(addResponse.getLedgerId(), addResponse.getEntryId(),</span>
                           status);
<span class="nc" id="L2230">        }</span>

        private void handleResponse(long ledgerId, long entryId,
                                    StatusCode status) {
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2235">                logResponse(status, &quot;ledger&quot;, ledgerId, &quot;entry&quot;, entryId);</span>
            }

<span class="nc" id="L2238">            int rc = convertStatus(status, BKException.Code.WriteException);</span>
<span class="nc" id="L2239">            writeComplete(rc, ledgerId, entryId, bookieId, ctx);</span>
<span class="nc" id="L2240">        }</span>
    }

    // visable for testing
    CompletionKey newCompletionKey(long txnId, OperationType operationType) {
<span class="nc" id="L2245">        return new V3CompletionKey(txnId, operationType);</span>
    }

    class V3CompletionKey extends CompletionKey {

<span class="nc" id="L2250">        public V3CompletionKey(long txnId, OperationType operationType) {</span>
<span class="nc" id="L2251">            super(txnId, operationType);</span>
<span class="nc" id="L2252">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L2256" title="All 2 branches missed.">            if (!(obj instanceof V3CompletionKey)) {</span>
<span class="nc" id="L2257">                return false;</span>
            }
<span class="nc" id="L2259">            V3CompletionKey that = (V3CompletionKey) obj;</span>
<span class="nc bnc" id="L2260" title="All 4 branches missed.">            return this.txnId == that.txnId &amp;&amp; this.operationType == that.operationType;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L2265">            return ((int) txnId);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L2270">            return String.format(&quot;TxnId(%d), OperationType(%s)&quot;, txnId, operationType);</span>
        }

    }

    abstract class CompletionKey {
        final long txnId;
        OperationType operationType;

        CompletionKey(long txnId,
<span class="nc" id="L2280">                      OperationType operationType) {</span>
<span class="nc" id="L2281">            this.txnId = txnId;</span>
<span class="nc" id="L2282">            this.operationType = operationType;</span>
<span class="nc" id="L2283">        }</span>

<span class="nc" id="L2285">        public void release() {}</span>
    }

    /**
     * Note : Helper functions follow
     */

    /**
     * @param status
     * @return {@link BKException.Code.UNINITIALIZED} if the statuscode is unknown.
     */
    private int statusCodeToExceptionCode(StatusCode status) {
<span class="nc bnc" id="L2297" title="All 10 branches missed.">        switch (status) {</span>
            case EOK:
<span class="nc" id="L2299">                return BKException.Code.OK;</span>
            case ENOENTRY:
<span class="nc" id="L2301">                return BKException.Code.NoSuchEntryException;</span>
            case ENOLEDGER:
<span class="nc" id="L2303">                return BKException.Code.NoSuchLedgerExistsException;</span>
            case EBADVERSION:
<span class="nc" id="L2305">                return BKException.Code.ProtocolVersionException;</span>
            case EUA:
<span class="nc" id="L2307">                return BKException.Code.UnauthorizedAccessException;</span>
            case EFENCED:
<span class="nc" id="L2309">                return BKException.Code.LedgerFencedException;</span>
            case EREADONLY:
<span class="nc" id="L2311">                return BKException.Code.WriteOnReadOnlyBookieException;</span>
            case ETOOMANYREQUESTS:
<span class="nc" id="L2313">                return BKException.Code.TooManyRequestsException;</span>
            case EUNKNOWNLEDGERSTATE:
<span class="nc" id="L2315">                return BKException.Code.DataUnknownException;</span>
            default:
<span class="nc" id="L2317">                return BKException.Code.UNINITIALIZED;</span>
        }
    }

    private void putCompletionKeyValue(CompletionKey key, CompletionValue value) {
<span class="nc" id="L2322">        CompletionValue existingValue = completionObjects.putIfAbsent(key, value);</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">        if (existingValue != null) { // will only happen for V2 keys, as V3 have unique txnid</span>
            // There's a pending read request on same ledger/entry. Use the multimap to track all of them
<span class="nc" id="L2325">            completionObjectsV2Conflicts.put(key, value);</span>
        }
<span class="nc" id="L2327">    }</span>

    private CompletionValue getCompletionValue(CompletionKey key) {
<span class="nc" id="L2330">        CompletionValue completionValue = completionObjects.remove(key);</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">        if (completionValue == null) {</span>
            // If there's no completion object here, try in the multimap
<span class="nc" id="L2333">            completionValue = completionObjectsV2Conflicts.removeAny(key).orElse(null);</span>
        }
<span class="nc" id="L2335">        return completionValue;</span>
    }

    private long getTxnId() {
<span class="nc" id="L2339">        return txnIdGenerator.incrementAndGet();</span>
    }

<span class="nc" id="L2342">    private final Recycler&lt;V2CompletionKey&gt; v2KeyRecycler = new Recycler&lt;V2CompletionKey&gt;() {</span>
            @Override
            protected V2CompletionKey newObject(
                    Recycler.Handle&lt;V2CompletionKey&gt; handle) {
<span class="nc" id="L2346">                return new V2CompletionKey(handle);</span>
            }
        };

    V2CompletionKey acquireV2Key(long ledgerId, long entryId,
                             OperationType operationType) {
<span class="nc" id="L2352">        V2CompletionKey key = v2KeyRecycler.get();</span>
<span class="nc" id="L2353">        key.reset(ledgerId, entryId, operationType);</span>
<span class="nc" id="L2354">        return key;</span>
    }

    private class V2CompletionKey extends CompletionKey {
        private final Handle&lt;V2CompletionKey&gt; recyclerHandle;
        long ledgerId;
        long entryId;

<span class="nc" id="L2362">        private V2CompletionKey(Handle&lt;V2CompletionKey&gt; handle) {</span>
<span class="nc" id="L2363">            super(-1, null);</span>
<span class="nc" id="L2364">            this.recyclerHandle = handle;</span>
<span class="nc" id="L2365">        }</span>

        void reset(long ledgerId, long entryId, OperationType operationType) {
<span class="nc" id="L2368">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L2369">            this.entryId = entryId;</span>
<span class="nc" id="L2370">            this.operationType = operationType;</span>
<span class="nc" id="L2371">        }</span>

        @Override
        public boolean equals(Object object) {
<span class="nc bnc" id="L2375" title="All 2 branches missed.">            if (!(object instanceof V2CompletionKey)) {</span>
<span class="nc" id="L2376">                return  false;</span>
            }
<span class="nc" id="L2378">            V2CompletionKey that = (V2CompletionKey) object;</span>
<span class="nc bnc" id="L2379" title="All 6 branches missed.">            return this.entryId == that.entryId</span>
                &amp;&amp; this.ledgerId == that.ledgerId
                &amp;&amp; this.operationType == that.operationType;
        }

        @Override
        public int hashCode() {
<span class="nc" id="L2386">            return Long.hashCode(ledgerId) * 31 + Long.hashCode(entryId);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L2391">            return String.format(&quot;%d:%d %s&quot;, ledgerId, entryId, operationType);</span>
        }

        @Override
        public void release() {
<span class="nc" id="L2396">            recyclerHandle.recycle(this);</span>
<span class="nc" id="L2397">        }</span>
    }

    Request.Builder withRequestContext(Request.Builder builder) {
<span class="nc bnc" id="L2401" title="All 2 branches missed.">        if (preserveMdcForTaskExecution) {</span>
<span class="nc" id="L2402">            return appendRequestContext(builder);</span>
        }
<span class="nc" id="L2404">        return builder;</span>
    }

    static Request.Builder appendRequestContext(Request.Builder builder) {
<span class="nc" id="L2408">        final Map&lt;String, String&gt; mdcContextMap = MDC.getCopyOfContextMap();</span>
<span class="nc bnc" id="L2409" title="All 4 branches missed.">        if (mdcContextMap == null || mdcContextMap.isEmpty()) {</span>
<span class="nc" id="L2410">            return builder;</span>
        }
<span class="nc bnc" id="L2412" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; kv : mdcContextMap.entrySet()) {</span>
<span class="nc" id="L2413">            final BookkeeperProtocol.ContextPair context = BookkeeperProtocol.ContextPair.newBuilder()</span>
<span class="nc" id="L2414">                    .setKey(kv.getKey())</span>
<span class="nc" id="L2415">                    .setValue(kv.getValue())</span>
<span class="nc" id="L2416">                    .build();</span>
<span class="nc" id="L2417">            builder.addRequestContext(context);</span>
<span class="nc" id="L2418">        }</span>
<span class="nc" id="L2419">        return builder;</span>
    }

    ChannelFutureListener contextPreservingListener(ChannelFutureListener listener) {
<span class="nc bnc" id="L2423" title="All 2 branches missed.">        return preserveMdcForTaskExecution ? new ContextPreservingFutureListener(listener) : listener;</span>
    }

    /**
     * Decorator to preserve MDC for connection listener.
     */
    static class ContextPreservingFutureListener implements ChannelFutureListener {
        private final ChannelFutureListener listener;
        private final Map&lt;String, String&gt; mdcContextMap;

<span class="nc" id="L2433">        ContextPreservingFutureListener(ChannelFutureListener listener) {</span>
<span class="nc" id="L2434">            this.listener = listener;</span>
<span class="nc" id="L2435">            this.mdcContextMap = MDC.getCopyOfContextMap();</span>
<span class="nc" id="L2436">        }</span>

        @Override
        public void operationComplete(ChannelFuture future) throws Exception {
<span class="nc" id="L2440">            MdcUtils.restoreContext(mdcContextMap);</span>
            try {
<span class="nc" id="L2442">                listener.operationComplete(future);</span>
            } finally {
<span class="nc" id="L2444">                MDC.clear();</span>
            }
<span class="nc" id="L2446">        }</span>
    }

    /**
     * Connection listener.
     */
    class ConnectionFutureListener implements ChannelFutureListener {
        private final long startTime;

<span class="nc" id="L2455">        ConnectionFutureListener(long startTime) {</span>
<span class="nc" id="L2456">            this.startTime = startTime;</span>
<span class="nc" id="L2457">        }</span>

        @Override
        public void operationComplete(ChannelFuture future) {
<span class="nc bnc" id="L2461" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2462">                LOG.debug(&quot;Channel connected ({}) {}&quot;, future.isSuccess(), future.channel());</span>
            }
            int rc;
            Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;

            /* We fill in the timer based on whether the connect operation itself succeeded regardless of
             * whether there was a race */
<span class="nc bnc" id="L2469" title="All 2 branches missed.">            if (future.isSuccess()) {</span>
<span class="nc" id="L2470">                PerChannelBookieClient.this</span>
<span class="nc" id="L2471">                .connectTimer.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
            } else {
<span class="nc" id="L2473">                PerChannelBookieClient.this</span>
<span class="nc" id="L2474">                .connectTimer.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
            }

<span class="nc" id="L2477">            synchronized (PerChannelBookieClient.this) {</span>
<span class="nc bnc" id="L2478" title="All 6 branches missed.">                if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTING &amp;&amp; future.channel().isActive()) {</span>
<span class="nc" id="L2479">                    rc = BKException.Code.OK;</span>
<span class="nc" id="L2480">                    channel = future.channel();</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">                    if (shFactory != null) {</span>
<span class="nc" id="L2482">                        LOG.info(&quot;Successfully connected to bookie: {} {} initiate TLS&quot;, bookieId, future.channel());</span>
<span class="nc" id="L2483">                        makeWritable();</span>
<span class="nc" id="L2484">                        initiateTLS();</span>
<span class="nc" id="L2485">                        return;</span>
                    } else {
<span class="nc" id="L2487">                        LOG.info(&quot;Successfully connected to bookie: {} {}&quot;, bookieId, future.channel());</span>
<span class="nc" id="L2488">                        state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L2489">                        activeNonTlsChannelCounter.inc();</span>
                    }
<span class="nc bnc" id="L2491" title="All 4 branches missed.">                } else if (future.isSuccess() &amp;&amp; state == ConnectionState.START_TLS) {</span>
<span class="nc" id="L2492">                    rc = BKException.Code.OK;</span>
<span class="nc" id="L2493">                    LOG.info(&quot;Successfully connected to bookie using TLS: &quot; + bookieId);</span>

<span class="nc" id="L2495">                    state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L2496">                    AuthHandler.ClientSideHandler authHandler = future.channel().pipeline()</span>
<span class="nc" id="L2497">                            .get(AuthHandler.ClientSideHandler.class);</span>
<span class="nc" id="L2498">                    authHandler.authProvider.onProtocolUpgrade();</span>
<span class="nc" id="L2499">                    activeTlsChannelCounter.inc();</span>
<span class="nc bnc" id="L2500" title="All 6 branches missed.">                } else if (future.isSuccess() &amp;&amp; (state == ConnectionState.CLOSED</span>
                    || state == ConnectionState.DISCONNECTED)) {
<span class="nc" id="L2502">                    LOG.warn(&quot;Closed before connection completed, clean up: {}, current state {}&quot;,</span>
<span class="nc" id="L2503">                            future.channel(), state);</span>
<span class="nc" id="L2504">                    closeChannel(future.channel());</span>
<span class="nc" id="L2505">                    rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L2506">                    channel = null;</span>
<span class="nc bnc" id="L2507" title="All 4 branches missed.">                } else if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc bnc" id="L2508" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2509">                        LOG.debug(&quot;Already connected with another channel({}), so close the new channel({})&quot;, channel,</span>
<span class="nc" id="L2510">                                future.channel());</span>
                    }
<span class="nc" id="L2512">                    closeChannel(future.channel());</span>
<span class="nc" id="L2513">                    return; // pendingOps should have been completed when other channel connected</span>
                } else {
<span class="nc" id="L2515">                    Throwable cause = future.cause();</span>
<span class="nc bnc" id="L2516" title="All 4 branches missed.">                    if (cause instanceof UnknownHostException || cause instanceof NativeIoException) {</span>
                        // Don't log stack trace for common errors
<span class="nc" id="L2518">                        logBookieUnavailable(() -&gt; LOG.warn(&quot;Could not connect to bookie: {}/{}, current state {} : {}&quot;,</span>
<span class="nc" id="L2519">                                future.channel(), bookieId, state, future.cause().getMessage()));</span>
                    } else {
                        // Regular exceptions, include stack trace
<span class="nc" id="L2522">                        logBookieUnavailable(() -&gt; LOG.error(&quot;Could not connect to bookie: {}/{}, current state {} : &quot;,</span>
<span class="nc" id="L2523">                                future.channel(), bookieId, state, future.cause()));</span>
                    }

<span class="nc" id="L2526">                    rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L2527">                    Channel failedChannel = future.channel();</span>
<span class="nc bnc" id="L2528" title="All 2 branches missed.">                    if (failedChannel != null) { // can be null in case of dummy failed ChannelFuture</span>
<span class="nc" id="L2529">                        closeChannel(failedChannel);</span>
                    }
<span class="nc" id="L2531">                    channel = null;</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">                    if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L2533">                        state = ConnectionState.DISCONNECTED;</span>
                    }
<span class="nc" id="L2535">                    failedConnectionCounter.inc();</span>
                }

                // trick to not do operations under the lock, take the list
                // of pending ops and assign it to a new variable, while
                // emptying the pending ops by just assigning it to a new
                // list
<span class="nc" id="L2542">                oldPendingOps = pendingOps;</span>
<span class="nc" id="L2543">                pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L2544">            }</span>

<span class="nc bnc" id="L2546" title="All 2 branches missed.">            for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L2547">                pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="nc" id="L2548">            }</span>

<span class="nc" id="L2550">            makeWritable();</span>
<span class="nc" id="L2551">        }</span>

        private void logBookieUnavailable(Runnable logger) {
<span class="nc" id="L2554">            final long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">            if ((now - lastBookieUnavailableLogTimestamp) &gt; conf.getClientConnectBookieUnavailableLogThrottlingMs()) {</span>
<span class="nc" id="L2556">                logger.run();</span>
<span class="nc" id="L2557">                lastBookieUnavailableLogTimestamp = now;</span>
            }
<span class="nc" id="L2559">        }</span>
    }

    private void initiateTLS() {
<span class="nc" id="L2563">        LOG.info(&quot;Initializing TLS to {}&quot;, channel);</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">        assert state == ConnectionState.CONNECTING;</span>
<span class="nc" id="L2565">        final long txnId = getTxnId();</span>
<span class="nc" id="L2566">        final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.START_TLS);</span>
<span class="nc" id="L2567">        completionObjects.put(completionKey,</span>
                              new StartTLSCompletion(completionKey));
<span class="nc" id="L2569">        BookkeeperProtocol.Request.Builder h = withRequestContext(BookkeeperProtocol.Request.newBuilder());</span>
<span class="nc" id="L2570">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L2571">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L2572">                .setOperation(OperationType.START_TLS)</span>
<span class="nc" id="L2573">                .setTxnId(txnId);</span>
<span class="nc" id="L2574">        h.setHeader(headerBuilder.build());</span>
<span class="nc" id="L2575">        h.setStartTLSRequest(BookkeeperProtocol.StartTLSRequest.newBuilder().build());</span>
<span class="nc" id="L2576">        state = ConnectionState.START_TLS;</span>
<span class="nc" id="L2577">        writeAndFlush(channel, completionKey, h.build());</span>
<span class="nc" id="L2578">    }</span>

    private void failTLS(int rc) {
<span class="nc" id="L2581">        LOG.error(&quot;TLS failure on: {}, rc: {}&quot;, channel, rc);</span>
        Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;
<span class="nc" id="L2583">        synchronized (this) {</span>
<span class="nc" id="L2584">            disconnect();</span>
<span class="nc" id="L2585">            oldPendingOps = pendingOps;</span>
<span class="nc" id="L2586">            pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L2587">        }</span>
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L2589">            pendingOp.operationComplete(rc, null);</span>
<span class="nc" id="L2590">        }</span>
<span class="nc" id="L2591">        failedTlsHandshakeCounter.inc();</span>
<span class="nc" id="L2592">    }</span>

    private static class FailedChannelFutureImpl implements ChannelFuture {

        private final Throwable failureCause;
<span class="nc" id="L2597">        public FailedChannelFutureImpl(Throwable failureCause) {</span>
<span class="nc" id="L2598">            this.failureCause = failureCause;</span>
<span class="nc" id="L2599">        }</span>

        @Override
        public Channel channel() {
            // used only for log
<span class="nc" id="L2604">            return null;</span>
        }

        @Override
        public ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener) {
<span class="nc" id="L2609">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        @SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})
        public ChannelFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners) {
<span class="nc" id="L2615">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener) {
<span class="nc" id="L2620">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        @SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})
        public ChannelFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners) {
<span class="nc" id="L2626">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture sync() throws InterruptedException {
<span class="nc" id="L2631">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture syncUninterruptibly() {
<span class="nc" id="L2636">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture await() throws InterruptedException {
<span class="nc" id="L2641">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture awaitUninterruptibly() {
<span class="nc" id="L2646">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public boolean isVoid() {
<span class="nc" id="L2651">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public boolean isSuccess() {
<span class="nc" id="L2656">            return false;</span>
        }

        @Override
        public boolean isCancellable() {
<span class="nc" id="L2661">            return false;</span>
        }

        @Override
        public Throwable cause() {
<span class="nc" id="L2666">            return failureCause;</span>
        }

        @Override
        public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
<span class="nc" id="L2671">            return true;</span>
        }

        @Override
        public boolean await(long timeoutMillis) throws InterruptedException {
<span class="nc" id="L2676">            return true;</span>
        }

        @Override
        public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {
<span class="nc" id="L2681">            return true;</span>
        }

        @Override
        public boolean awaitUninterruptibly(long timeoutMillis) {
<span class="nc" id="L2686">            return true;</span>
        }

        @Override
        public Void getNow() {
<span class="nc" id="L2691">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
<span class="nc" id="L2696">            return false;</span>
        }

        @Override
        public boolean isCancelled() {
<span class="nc" id="L2701">            return false;</span>
        }

        @Override
        public boolean isDone() {
<span class="nc" id="L2706">            return true;</span>
        }

        @Override
        public Void get() throws InterruptedException, ExecutionException {
<span class="nc" id="L2711">            throw new ExecutionException(failureCause);</span>
        }

        @Override
        public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc" id="L2716">            throw new ExecutionException(failureCause);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>