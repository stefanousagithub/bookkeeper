<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LongZkLedgerIdGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.meta</a> &gt; <span class="el_source">LongZkLedgerIdGenerator.java</span></div><h1>LongZkLedgerIdGenerator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.meta;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import org.apache.bookkeeper.client.BKException;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.util.ZkUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.zookeeper.AsyncCallback.StringCallback;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.ACL;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ZooKeeper based ledger id generator class, which using EPHEMERAL_SEQUENTIAL
 * with &lt;i&gt;(ledgerIdGenPath)/HOB-[high-32-bits]/ID-&lt;/i&gt; prefix to generate ledger id. Note
 * zookeeper sequential counter has a format of %10d -- that is 10 digits with 0
 * (zero) padding, i.e. &quot;&amp;lt;path&amp;gt;0000000001&quot;, so ledger id space would be
 * fundamentally limited to 9 billion. In practice, the id generated by zookeeper
 * is only 31 bits (signed 32-bit integer), so the limit is much lower than 9 billion.
 *
 * &lt;p&gt;In order to support the full range of the long ledgerId, once ledgerIds reach Integer.MAX_INT,
 * a new system is employed. The 32 most significant bits of the ledger ID are taken and turned into
 * a directory prefixed with &lt;i&gt;HOB-&lt;/i&gt; under &lt;i&gt;(ledgerIdGenPath)&lt;/i&gt;
 *
 * &lt;p&gt;Under this &lt;i&gt;HOB-&lt;/i&gt; directory, zookeeper is used to continue generating EPHEMERAL_SEQUENTIAL ids
 * which constitute the lower 32-bits of the ledgerId (sign bit is always 0). Once the &lt;i&gt;HOB-&lt;/i&gt; directory runs out
 * of available ids, the process is repeated. The higher bits are incremented, a new &lt;i&gt;HOB-&lt;/i&gt; directory is created,
 * and zookeeper generates sequential ids underneath it.
 *
 * &lt;p&gt;The reason for treating ids which are less than Integer.MAX_INT differently is to maintain backwards
 * compatibility. This is a drop-in replacement for ZkLedgerIdGenerator.
 */
public class LongZkLedgerIdGenerator implements LedgerIdGenerator {
<span class="nc" id="L58">    private static final Logger LOG = LoggerFactory.getLogger(LongZkLedgerIdGenerator.class);</span>
    private ZooKeeper zk;
    private String ledgerIdGenPath;
    private ZkLedgerIdGenerator shortIdGen;
    private List&lt;String&gt; highOrderDirectories;
    private HighOrderLedgerIdGenPathStatus ledgerIdGenPathStatus;
    private final List&lt;ACL&gt; zkAcls;

<span class="nc" id="L66">    private enum HighOrderLedgerIdGenPathStatus {</span>
<span class="nc" id="L67">        UNKNOWN,</span>
<span class="nc" id="L68">        PRESENT,</span>
<span class="nc" id="L69">        NOT_PRESENT</span>
    }

    public LongZkLedgerIdGenerator(ZooKeeper zk, String ledgersPath, String idGenZnodeName,
<span class="nc" id="L73">            ZkLedgerIdGenerator shortIdGen, List&lt;ACL&gt; zkAcls) {</span>
<span class="nc" id="L74">        this.zk = zk;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        if (StringUtils.isBlank(idGenZnodeName)) {</span>
<span class="nc" id="L76">            this.ledgerIdGenPath = ledgersPath;</span>
        } else {
<span class="nc" id="L78">            this.ledgerIdGenPath = ledgersPath + &quot;/&quot; + idGenZnodeName;</span>
        }
<span class="nc" id="L80">        this.shortIdGen = shortIdGen;</span>
<span class="nc" id="L81">        highOrderDirectories = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L82">        ledgerIdGenPathStatus = HighOrderLedgerIdGenPathStatus.UNKNOWN;</span>
<span class="nc" id="L83">        this.zkAcls = zkAcls;</span>
<span class="nc" id="L84">    }</span>

    private void generateLongLedgerIdLowBits(final String ledgerPrefix, long highBits, final GenericCallback&lt;Long&gt; cb)
            throws KeeperException, InterruptedException, IOException {
<span class="nc" id="L88">        String highPath = ledgerPrefix + formatHalfId((int) highBits);</span>
<span class="nc" id="L89">        ZkLedgerIdGenerator.generateLedgerIdImpl(new GenericCallback&lt;Long&gt;(){</span>
            @Override
            public void operationComplete(int rc, Long result) {
<span class="nc bnc" id="L92" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                    assert((highBits &amp; 0xFFFFFFFF00000000L) == 0);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">                    assert((result &amp; 0xFFFFFFFF00000000L) == 0);</span>
<span class="nc" id="L95">                    cb.operationComplete(rc, (highBits &lt;&lt; 32) | result);</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                } else if (rc == BKException.Code.LedgerIdOverflowException) {</span>
                    // Lower bits are full. Need to expand and create another HOB node.
                    try {
<span class="nc" id="L99">                        Long newHighBits = highBits + 1;</span>
<span class="nc" id="L100">                        createHOBPathAndGenerateId(ledgerPrefix, newHighBits.intValue(), cb);</span>
<span class="nc" id="L101">                    } catch (KeeperException e) {</span>
<span class="nc" id="L102">                        LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L103">                        cb.operationComplete(BKException.Code.ZKException, null);</span>
<span class="nc" id="L104">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L105">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L106">                        LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L107">                        cb.operationComplete(BKException.Code.InterruptedException, null);</span>
<span class="nc" id="L108">                    } catch (IOException e) {</span>
<span class="nc" id="L109">                        LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L110">                        cb.operationComplete(BKException.Code.IllegalOpException, null);</span>
<span class="nc" id="L111">                    }</span>

                } else {
<span class="nc" id="L114">                    LOG.error(&quot;Failed to create long ledger ID path&quot;,</span>
<span class="nc" id="L115">                            KeeperException.create(KeeperException.Code.get(rc)));</span>
<span class="nc" id="L116">                    cb.operationComplete(BKException.Code.ZKException, null);</span>
                }
<span class="nc" id="L118">            }</span>

<span class="nc" id="L120">        }, zk, ZkLedgerIdGenerator.createLedgerPrefix(highPath, null), zkAcls);</span>
<span class="nc" id="L121">    }</span>

    /**
     * Formats half an ID as 10-character 0-padded string.
     * @param i - 32 bits of the ID to format
     * @return a 10-character 0-padded string.
     */
    private String formatHalfId(int i) {
<span class="nc" id="L129">        return String.format(&quot;%010d&quot;, i);</span>
    }

    private void createHOBPathAndGenerateId(String ledgerPrefix, int hob, final GenericCallback&lt;Long&gt; cb)
            throws KeeperException, InterruptedException, IOException {
        try {
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L136">                LOG.debug(&quot;Creating HOB path: {}&quot;, ledgerPrefix + formatHalfId(hob));</span>
            }
<span class="nc" id="L138">            zk.create(ledgerPrefix + formatHalfId(hob), new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span>
<span class="nc" id="L139">        } catch (KeeperException.NodeExistsException e) {</span>
            // It's fine if we lost a race to create the node (NodeExistsException).
            // All other exceptions should continue unwinding.
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L143">                LOG.debug(&quot;Tried to create High-order-bits node, but it already existed!&quot;, e);</span>
            }
<span class="nc" id="L145">        }</span>
        // We just created a new HOB directory. Invalidate the directory cache
<span class="nc" id="L147">        invalidateDirectoryCache();</span>
<span class="nc" id="L148">        generateLongLedgerId(cb); // Try again.</span>
<span class="nc" id="L149">    }</span>

    private void invalidateDirectoryCache() {
<span class="nc" id="L152">        highOrderDirectories = null;</span>
<span class="nc" id="L153">    }</span>

    private void generateLongLedgerId(final GenericCallback&lt;Long&gt; cb) throws KeeperException, InterruptedException,
            IOException {
<span class="nc" id="L157">        final String hobPrefix = &quot;HOB-&quot;;</span>
<span class="nc" id="L158">        final String ledgerPrefix = this.ledgerIdGenPath + &quot;/&quot; + hobPrefix;</span>

        // Only pull the directories from zk if we don't have any cached.
<span class="nc" id="L161">        boolean refreshedDirectories = false;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (highOrderDirectories == null) {</span>
<span class="nc" id="L163">            refreshedDirectories = true;</span>
<span class="nc" id="L164">            highOrderDirectories = zk.getChildren(ledgerIdGenPath, false);</span>
        }

<span class="nc" id="L167">        Optional&lt;Long&gt; largest = highOrderDirectories.stream()</span>
<span class="nc" id="L168">            .map((t) -&gt; {</span>
                    try {
<span class="nc" id="L170">                        return Long.parseLong(t.replace(hobPrefix, &quot;&quot;));</span>
<span class="nc" id="L171">                    } catch (NumberFormatException e) {</span>
<span class="nc" id="L172">                        return null;</span>
                    }
                })
<span class="nc bnc" id="L175" title="All 2 branches missed.">            .filter((t) -&gt; t != null)</span>
<span class="nc" id="L176">            .reduce(Math::max);</span>

        // If we didn't get any valid IDs from the directory...
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (!largest.isPresent()) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (!refreshedDirectories) {</span>
                // Our cache might be bad. Invalidate it and retry.
<span class="nc" id="L182">                invalidateDirectoryCache();</span>
<span class="nc" id="L183">                generateLongLedgerId(cb); // Try again</span>
            } else {
                // else, Start at HOB-0000000001;
<span class="nc" id="L186">                createHOBPathAndGenerateId(ledgerPrefix, 1, cb);</span>
            }
<span class="nc" id="L188">            return;</span>
        }

        // Found the largest.
        // Get the low-order bits.
<span class="nc" id="L193">        final Long highBits = largest.get();</span>
<span class="nc" id="L194">        generateLongLedgerIdLowBits(ledgerPrefix, highBits, cb);</span>

        // Perform garbage collection on HOB- directories.
        // Keeping 3 should be plenty to prevent races
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (highOrderDirectories.size() &gt; 3) {</span>
<span class="nc" id="L199">            Object[] highOrderDirs = highOrderDirectories.stream()</span>
<span class="nc" id="L200">                    .map((t) -&gt; {</span>
                            try {
<span class="nc" id="L202">                                return Long.parseLong(t.replace(hobPrefix, &quot;&quot;));</span>
<span class="nc" id="L203">                            } catch (NumberFormatException e) {</span>
<span class="nc" id="L204">                                return null;</span>
                            }
                        })
<span class="nc bnc" id="L207" title="All 2 branches missed.">                    .filter((t) -&gt; t != null)</span>
<span class="nc" id="L208">                    .sorted()</span>
<span class="nc" id="L209">                    .toArray();</span>

            // Go ahead and invalidate. We want to reload cache even if we fail.
<span class="nc" id="L212">            invalidateDirectoryCache();</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">            for (int i = 0; i &lt; highOrderDirs.length - 3; i++) {</span>
<span class="nc" id="L215">                String path = ledgerPrefix + formatHalfId(((Long) highOrderDirs[i]).intValue());</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L217">                    LOG.debug(&quot;DELETING HIGH ORDER DIR: {}&quot;, path);</span>
                }
                try {
<span class="nc" id="L220">                    zk.delete(path, 0);</span>
<span class="nc" id="L221">                } catch (KeeperException e) {</span>
                    // We don't care if we fail. Just warn about it.
<span class="nc bnc" id="L223" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L224">                        LOG.debug(&quot;Failed to delete {}&quot;, path);</span>
                    }
<span class="nc" id="L226">                }</span>
            }
        }
<span class="nc" id="L229">    }</span>

    private void createLongLedgerIdPathAndGenerateLongLedgerId(final GenericCallback&lt;Long&gt; cb, String createPath) {
<span class="nc" id="L232">        ZkUtils.asyncCreateFullPathOptimistic(zk, ledgerIdGenPath, new byte[0], Ids.OPEN_ACL_UNSAFE,</span>
<span class="nc" id="L233">                CreateMode.PERSISTENT, new StringCallback() {</span>
                    @Override
                    public void processResult(int rc, String path, Object ctx, String name) {
                        try {
<span class="nc" id="L237">                            setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.PRESENT);</span>
<span class="nc" id="L238">                            generateLongLedgerId(cb);</span>
<span class="nc" id="L239">                        } catch (KeeperException e) {</span>
<span class="nc" id="L240">                            LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L241">                            setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);</span>
<span class="nc" id="L242">                            cb.operationComplete(BKException.Code.ZKException, null);</span>
<span class="nc" id="L243">                        } catch (InterruptedException e) {</span>
<span class="nc" id="L244">                            Thread.currentThread().interrupt();</span>
<span class="nc" id="L245">                            LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L246">                            setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);</span>
<span class="nc" id="L247">                            cb.operationComplete(BKException.Code.InterruptedException, null);</span>
<span class="nc" id="L248">                        } catch (IOException e) {</span>
<span class="nc" id="L249">                            LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L250">                            setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);</span>
<span class="nc" id="L251">                            cb.operationComplete(BKException.Code.IllegalOpException, null);</span>
<span class="nc" id="L252">                        }</span>
<span class="nc" id="L253">                    }</span>
                }, null);
<span class="nc" id="L255">    }</span>

    public void invalidateLedgerIdGenPathStatus() {
<span class="nc" id="L258">        setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);</span>
<span class="nc" id="L259">    }</span>

    private synchronized void setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus status) {
<span class="nc" id="L262">        ledgerIdGenPathStatus = status;</span>
<span class="nc" id="L263">    }</span>

    /**
     * Checks the existence of the long ledger id gen path. Existence indicates we have switched from the legacy
     * algorithm to the new method of generating 63-bit ids. If the existence is UNKNOWN, it looks in zk to
     * find out. If it previously checked in zk, it returns that value. This value changes when we run out
     * of ids &lt; Integer.MAX_VALUE, and try to create the long ledger id gen path.
     * @see createLongLedgerIdPathAndGenerateLongLedgerId
     * @param zk
     * @return Does the long ledger id gen path exist?
     * @throws KeeperException
     * @throws InterruptedException
     */
    public synchronized boolean ledgerIdGenPathPresent(ZooKeeper zk) throws KeeperException, InterruptedException {
<span class="nc bnc" id="L277" title="All 4 branches missed.">        switch(ledgerIdGenPathStatus) {</span>
        case UNKNOWN:
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (zk.exists(ledgerIdGenPath, false) != null) {</span>
<span class="nc" id="L280">                ledgerIdGenPathStatus = HighOrderLedgerIdGenPathStatus.PRESENT;</span>
<span class="nc" id="L281">                return true;</span>
            } else {
<span class="nc" id="L283">                ledgerIdGenPathStatus = HighOrderLedgerIdGenPathStatus.NOT_PRESENT;</span>
<span class="nc" id="L284">                return false;</span>
            }
        case PRESENT:
<span class="nc" id="L287">            return true;</span>
        case NOT_PRESENT:
<span class="nc" id="L289">            return false;</span>
        default:
<span class="nc" id="L291">            return false;</span>
        }
    }

    @Override
    public void generateLedgerId(final GenericCallback&lt;Long&gt; cb) {
        try {
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (!ledgerIdGenPathPresent(zk)) {</span>
                // We've not moved onto 63-bit ledgers yet.
<span class="nc" id="L300">                shortIdGen.generateLedgerId(new GenericCallback&lt;Long&gt;(){</span>
                        @Override
                        public void operationComplete(int rc, Long result) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">                            if (rc == BKException.Code.LedgerIdOverflowException) {</span>
                                // 31-bit IDs overflowed. Start using 63-bit ids.
<span class="nc" id="L305">                                createLongLedgerIdPathAndGenerateLongLedgerId(cb, ledgerIdGenPath);</span>
                            } else {
                                // 31-bit Generation worked OK, or had some other
                                // error that we will pass on.
<span class="nc" id="L309">                                cb.operationComplete(rc, result);</span>
                            }
<span class="nc" id="L311">                        }</span>
                    });
            } else {
                // We've already started generating 63-bit ledger IDs.
                // Keep doing that.
<span class="nc" id="L316">                generateLongLedgerId(cb);</span>
            }
<span class="nc" id="L318">        } catch (KeeperException e) {</span>
<span class="nc" id="L319">            LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L320">            cb.operationComplete(BKException.Code.ZKException, null);</span>
<span class="nc" id="L321">        } catch (InterruptedException e) {</span>
<span class="nc" id="L322">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L323">            LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L324">            cb.operationComplete(BKException.Code.InterruptedException, null);</span>
<span class="nc" id="L325">        } catch (IOException e) {</span>
<span class="nc" id="L326">            LOG.error(&quot;Failed to create long ledger ID path&quot;, e);</span>
<span class="nc" id="L327">            cb.operationComplete(BKException.Code.IllegalOpException, null);</span>
<span class="nc" id="L328">        }</span>
<span class="nc" id="L329">    }</span>

    @Override
    public void close() throws IOException {
<span class="nc" id="L333">        shortIdGen.close();</span>
<span class="nc" id="L334">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>