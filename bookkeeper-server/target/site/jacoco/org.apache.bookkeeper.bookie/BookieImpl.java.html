<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BookieImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">BookieImpl.java</span></div><h1>BookieImpl.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.bookkeeper.bookie;

import static org.apache.bookkeeper.bookie.BookKeeperServerStats.JOURNAL_SCOPE;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_INDEX_SCOPE;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_LEDGER_SCOPE;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.util.ReferenceCountUtil;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.file.FileStore;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.PrimitiveIterator.OfLong;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.apache.bookkeeper.bookie.BookieException.DiskPartitionDuplicationException;
import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;
import org.apache.bookkeeper.bookie.Journal.JournalScanner;
import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;
import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;
import org.apache.bookkeeper.bookie.stats.BookieStats;
import org.apache.bookkeeper.bookie.storage.ldb.DbLedgerStorage;
import org.apache.bookkeeper.common.util.Watcher;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.discover.BookieServiceInfo;
import org.apache.bookkeeper.discover.RegistrationManager;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.net.DNS;
import org.apache.bookkeeper.proto.BookieRequestHandler;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.ThreadRegistry;
import org.apache.bookkeeper.util.BookKeeperConstants;
import org.apache.bookkeeper.util.DiskChecker;
import org.apache.bookkeeper.util.IOUtils;
import org.apache.bookkeeper.util.MathUtils;
import org.apache.bookkeeper.util.collections.ConcurrentLongHashMap;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.mutable.MutableBoolean;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Implements a bookie.
 */
public class BookieImpl extends BookieCriticalThread implements Bookie {

<span class="nc" id="L92">    private static final Logger LOG = LoggerFactory.getLogger(Bookie.class);</span>

    final List&lt;File&gt; journalDirectories;
    final ServerConfiguration conf;

    final SyncThread syncThread;
    final LedgerStorage ledgerStorage;
    final RegistrationManager registrationManager;
    final List&lt;Journal&gt; journals;

    final HandleFactory handles;
    final boolean entryLogPerLedgerEnabled;

    public static final long METAENTRY_ID_LEDGER_KEY = -0x1000;
    public static final long METAENTRY_ID_FENCE_KEY  = -0x2000;
    public static final long METAENTRY_ID_FORCE_LEDGER  = -0x4000;
    static final long METAENTRY_ID_LEDGER_EXPLICITLAC  = -0x8000;

    private final LedgerDirsManager ledgerDirsManager;
    protected final Supplier&lt;BookieServiceInfo&gt; bookieServiceInfoProvider;
    private final LedgerDirsManager indexDirsManager;
    LedgerDirsMonitor dirsMonitor;

<span class="nc" id="L115">    private int exitCode = ExitCode.OK;</span>

<span class="nc" id="L117">    private final ConcurrentLongHashMap&lt;byte[]&gt; masterKeyCache =</span>
<span class="nc" id="L118">            ConcurrentLongHashMap.&lt;byte[]&gt;newBuilder().autoShrink(true).build();</span>

    protected StateManager stateManager;

    // Expose Stats
    final StatsLogger statsLogger;
    private final BookieStats bookieStats;

    private final ByteBufAllocator allocator;

    private final boolean writeDataToJournal;

    // Write Callback do nothing
<span class="nc" id="L131">    static class NopWriteCallback implements WriteCallback {</span>
        @Override
        public void writeComplete(int rc, long ledgerId, long entryId,
                                  BookieId addr, Object ctx) {
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L136">                LOG.debug(&quot;Finished writing entry {} @ ledger {} for {} : {}&quot;,</span>
<span class="nc" id="L137">                        entryId, ledgerId, addr, rc);</span>
            }
<span class="nc" id="L139">        }</span>
    }

    public static void checkDirectoryStructure(File dir) throws IOException {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (!dir.exists()) {</span>
<span class="nc" id="L144">            File parent = dir.getParentFile();</span>
<span class="nc" id="L145">            File preV3versionFile = new File(dir.getParent(),</span>
                    BookKeeperConstants.VERSION_FILENAME);

<span class="nc" id="L148">            final AtomicBoolean oldDataExists = new AtomicBoolean(false);</span>
<span class="nc" id="L149">            parent.list(new FilenameFilter() {</span>
                    @Override
                    public boolean accept(File dir, String name) {
<span class="nc bnc" id="L152" title="All 6 branches missed.">                        if (name.endsWith(&quot;.txn&quot;) || name.endsWith(&quot;.idx&quot;) || name.endsWith(&quot;.log&quot;)) {</span>
<span class="nc" id="L153">                            oldDataExists.set(true);</span>
                        }
<span class="nc" id="L155">                        return true;</span>
                    }
                });
<span class="nc bnc" id="L158" title="All 4 branches missed.">            if (preV3versionFile.exists() || oldDataExists.get()) {</span>
<span class="nc" id="L159">                String err = &quot;Directory layout version is less than 3, upgrade needed&quot;;</span>
<span class="nc" id="L160">                LOG.error(err);</span>
<span class="nc" id="L161">                throw new IOException(err);</span>
            }
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (!dir.mkdirs()) {</span>
<span class="nc" id="L164">                String err = &quot;Unable to create directory &quot; + dir;</span>
<span class="nc" id="L165">                LOG.error(err);</span>
<span class="nc" id="L166">                throw new IOException(err);</span>
            }
        }
<span class="nc" id="L169">    }</span>

    /**
     * Check that the environment for the bookie is correct.
     * This means that the configuration has stayed the same as the
     * first run and the filesystem structure is up to date.
     */
    private void checkEnvironment()
            throws BookieException, IOException, InterruptedException {
<span class="nc" id="L178">        List&lt;File&gt; allLedgerDirs = new ArrayList&lt;File&gt;(ledgerDirsManager.getAllLedgerDirs().size()</span>
<span class="nc" id="L179">                + indexDirsManager.getAllLedgerDirs().size());</span>
<span class="nc" id="L180">        allLedgerDirs.addAll(ledgerDirsManager.getAllLedgerDirs());</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (indexDirsManager != ledgerDirsManager) {</span>
<span class="nc" id="L182">            allLedgerDirs.addAll(indexDirsManager.getAllLedgerDirs());</span>
        }

<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (File journalDirectory : journalDirectories) {</span>
<span class="nc" id="L186">            checkDirectoryStructure(journalDirectory);</span>
<span class="nc" id="L187">        }</span>

<span class="nc bnc" id="L189" title="All 2 branches missed.">        for (File dir : allLedgerDirs) {</span>
<span class="nc" id="L190">            checkDirectoryStructure(dir);</span>
<span class="nc" id="L191">        }</span>

<span class="nc" id="L193">        checkIfDirsOnSameDiskPartition(allLedgerDirs);</span>
<span class="nc" id="L194">        checkIfDirsOnSameDiskPartition(journalDirectories);</span>
<span class="nc" id="L195">    }</span>

    /**
     * Checks if multiple directories are in same diskpartition/filesystem/device.
     * If ALLOW_MULTIPLEDIRS_UNDER_SAME_DISKPARTITION config parameter is not enabled, and
     * if it is found that there are multiple directories in the same DiskPartition then
     * it will throw DiskPartitionDuplicationException.
     *
     * @param dirs dirs to validate
     *
     * @throws IOException
     */
    private void checkIfDirsOnSameDiskPartition(List&lt;File&gt; dirs) throws DiskPartitionDuplicationException {
<span class="nc" id="L208">        boolean allowDiskPartitionDuplication = conf.isAllowMultipleDirsUnderSameDiskPartition();</span>
<span class="nc" id="L209">        final MutableBoolean isDuplicationFoundAndNotAllowed = new MutableBoolean(false);</span>
<span class="nc" id="L210">        Map&lt;FileStore, List&lt;File&gt;&gt; fileStoreDirsMap = new HashMap&lt;FileStore, List&lt;File&gt;&gt;();</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (File dir : dirs) {</span>
            FileStore fileStore;
            try {
<span class="nc" id="L214">                fileStore = Files.getFileStore(dir.toPath());</span>
<span class="nc" id="L215">            } catch (IOException e) {</span>
<span class="nc" id="L216">                LOG.error(&quot;Got IOException while trying to FileStore of {}&quot;, dir);</span>
<span class="nc" id="L217">                throw new BookieException.DiskPartitionDuplicationException(e);</span>
<span class="nc" id="L218">            }</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (fileStoreDirsMap.containsKey(fileStore)) {</span>
<span class="nc" id="L220">                fileStoreDirsMap.get(fileStore).add(dir);</span>
            } else {
<span class="nc" id="L222">                List&lt;File&gt; dirsList = new ArrayList&lt;File&gt;();</span>
<span class="nc" id="L223">                dirsList.add(dir);</span>
<span class="nc" id="L224">                fileStoreDirsMap.put(fileStore, dirsList);</span>
            }
<span class="nc" id="L226">        }</span>

<span class="nc" id="L228">        fileStoreDirsMap.forEach((fileStore, dirsList) -&gt; {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (dirsList.size() &gt; 1) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                if (allowDiskPartitionDuplication) {</span>
<span class="nc" id="L231">                    LOG.warn(&quot;Dirs: {} are in same DiskPartition/FileSystem: {}&quot;, dirsList, fileStore);</span>
                } else {
<span class="nc" id="L233">                    LOG.error(&quot;Dirs: {} are in same DiskPartition/FileSystem: {}&quot;, dirsList, fileStore);</span>
<span class="nc" id="L234">                    isDuplicationFoundAndNotAllowed.setValue(true);</span>
                }
            }
<span class="nc" id="L237">        });</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (isDuplicationFoundAndNotAllowed.getValue()) {</span>
<span class="nc" id="L239">            throw new BookieException.DiskPartitionDuplicationException();</span>
        }
<span class="nc" id="L241">    }</span>

    public static BookieId getBookieId(ServerConfiguration conf) throws UnknownHostException {
<span class="nc" id="L244">        String customBookieId = conf.getBookieId();</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (customBookieId != null) {</span>
<span class="nc" id="L246">            return BookieId.parse(customBookieId);</span>
        }
<span class="nc" id="L248">        return getBookieAddress(conf).toBookieId();</span>
    }

    /**
     * Return the configured address of the bookie.
     */
    public static BookieSocketAddress getBookieAddress(ServerConfiguration conf)
            throws UnknownHostException {
        // Advertised address takes precedence over the listening interface and the
        // useHostNameAsBookieID settings
<span class="nc bnc" id="L258" title="All 4 branches missed.">        if (conf.getAdvertisedAddress() != null &amp;&amp; conf.getAdvertisedAddress().trim().length() &gt; 0) {</span>
<span class="nc" id="L259">            String hostAddress = conf.getAdvertisedAddress().trim();</span>
<span class="nc" id="L260">            return new BookieSocketAddress(hostAddress, conf.getBookiePort());</span>
        }

<span class="nc" id="L263">        String iface = conf.getListeningInterface();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (iface == null) {</span>
<span class="nc" id="L265">            iface = &quot;default&quot;;</span>
        }

<span class="nc" id="L268">        String hostName = DNS.getDefaultHost(iface);</span>
<span class="nc" id="L269">        InetSocketAddress inetAddr = new InetSocketAddress(hostName, conf.getBookiePort());</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (inetAddr.isUnresolved()) {</span>
<span class="nc" id="L271">            throw new UnknownHostException(&quot;Unable to resolve default hostname: &quot;</span>
                    + hostName + &quot; for interface: &quot; + iface);
        }
<span class="nc" id="L274">        String hostAddress = null;</span>
<span class="nc" id="L275">        InetAddress iAddress = inetAddr.getAddress();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (conf.getUseHostNameAsBookieID()) {</span>
<span class="nc" id="L277">            hostAddress = iAddress.getCanonicalHostName();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (conf.getUseShortHostName()) {</span>
                /*
                 * if short hostname is used, then FQDN is not used. Short
                 * hostname is the hostname cut at the first dot.
                 */
<span class="nc" id="L283">                hostAddress = hostAddress.split(&quot;\\.&quot;, 2)[0];</span>
            }
        } else {
<span class="nc" id="L286">            hostAddress = iAddress.getHostAddress();</span>
        }

<span class="nc" id="L289">        BookieSocketAddress addr =</span>
<span class="nc" id="L290">                new BookieSocketAddress(hostAddress, conf.getBookiePort());</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (addr.getSocketAddress().getAddress().isLoopbackAddress()</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            &amp;&amp; !conf.getAllowLoopback()) {</span>
<span class="nc" id="L293">            throw new UnknownHostException(&quot;Trying to listen on loopback address, &quot;</span>
                    + addr + &quot; but this is forbidden by default &quot;
                    + &quot;(see ServerConfiguration#getAllowLoopback()).\n&quot;
                    + &quot;If this happen, you can consider specifying the network interface&quot;
                    + &quot; to listen on (e.g. listeningInterface=eth0) or specifying the&quot;
                    + &quot; advertised address (e.g. advertisedAddress=172.x.y.z)&quot;);
        }
<span class="nc" id="L300">        return addr;</span>
    }

    public LedgerDirsManager getLedgerDirsManager() {
<span class="nc" id="L304">        return ledgerDirsManager;</span>
    }

    LedgerDirsManager getIndexDirsManager() {
<span class="nc" id="L308">        return indexDirsManager;</span>
    }

    public long getTotalDiskSpace() throws IOException {
<span class="nc" id="L312">        return getLedgerDirsManager().getTotalDiskSpace(ledgerDirsManager.getAllLedgerDirs());</span>
    }

    public long getTotalFreeSpace() throws IOException {
<span class="nc" id="L316">        return getLedgerDirsManager().getTotalFreeSpace(ledgerDirsManager.getAllLedgerDirs());</span>
    }

    public static File getCurrentDirectory(File dir) {
<span class="nc" id="L320">        return new File(dir, BookKeeperConstants.CURRENT_DIR);</span>
    }

    public static File[] getCurrentDirectories(File[] dirs) {
<span class="nc" id="L324">        File[] currentDirs = new File[dirs.length];</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        for (int i = 0; i &lt; dirs.length; i++) {</span>
<span class="nc" id="L326">            currentDirs[i] = getCurrentDirectory(dirs[i]);</span>
        }
<span class="nc" id="L328">        return currentDirs;</span>
    }

    /**
     * Initialize LedgerStorage instance without checkpointing for use within the shell
     * and other RO users.  ledgerStorage must not have already been initialized.
     *
     * &lt;p&gt;The caller is responsible for disposing of the ledgerStorage object.
     *
     * @param conf Bookie config.
     * @param ledgerStorage Instance to initialize.
     * @return Passed ledgerStorage instance
     * @throws IOException
     */
    public static LedgerStorage mountLedgerStorageOffline(ServerConfiguration conf, LedgerStorage ledgerStorage)
            throws IOException {
<span class="nc" id="L344">        StatsLogger statsLogger = NullStatsLogger.INSTANCE;</span>
<span class="nc" id="L345">        DiskChecker diskChecker = new DiskChecker(conf.getDiskUsageThreshold(), conf.getDiskUsageWarnThreshold());</span>

<span class="nc" id="L347">        LedgerDirsManager ledgerDirsManager = BookieResources.createLedgerDirsManager(</span>
<span class="nc" id="L348">                conf, diskChecker, statsLogger.scope(LD_LEDGER_SCOPE));</span>
<span class="nc" id="L349">        LedgerDirsManager indexDirsManager = BookieResources.createIndexDirsManager(</span>
<span class="nc" id="L350">                conf, diskChecker, statsLogger.scope(LD_INDEX_SCOPE), ledgerDirsManager);</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (null == ledgerStorage) {</span>
<span class="nc" id="L353">            ledgerStorage = BookieResources.createLedgerStorage(conf, null,</span>
                                                                ledgerDirsManager,
                                                                indexDirsManager,
                                                                statsLogger,
                                                                UnpooledByteBufAllocator.DEFAULT);
        } else {
<span class="nc" id="L359">            ledgerStorage.initialize(</span>
                conf,
                null,
                ledgerDirsManager,
                indexDirsManager,
                statsLogger,
                UnpooledByteBufAllocator.DEFAULT);
        }

<span class="nc" id="L368">        ledgerStorage.setCheckpointSource(new CheckpointSource() {</span>
                @Override
                public Checkpoint newCheckpoint() {
<span class="nc" id="L371">                    return Checkpoint.MIN;</span>
                }

                @Override
                public void checkpointComplete(Checkpoint checkpoint, boolean compact)
                        throws IOException {
<span class="nc" id="L377">                }</span>
            });
<span class="nc" id="L379">        ledgerStorage.setCheckpointer(Checkpointer.NULL);</span>
<span class="nc" id="L380">        return ledgerStorage;</span>
    }

    public BookieImpl(ServerConfiguration conf,
                      RegistrationManager registrationManager,
                      LedgerStorage storage,
                      DiskChecker diskChecker,
                      LedgerDirsManager ledgerDirsManager,
                      LedgerDirsManager indexDirsManager,
                      StatsLogger statsLogger,
                      ByteBufAllocator allocator,
                      Supplier&lt;BookieServiceInfo&gt; bookieServiceInfoProvider)
            throws IOException, InterruptedException, BookieException {
<span class="nc" id="L393">        super(&quot;Bookie-&quot; + conf.getBookiePort());</span>
<span class="nc" id="L394">        this.bookieServiceInfoProvider = bookieServiceInfoProvider;</span>
<span class="nc" id="L395">        this.statsLogger = statsLogger;</span>
<span class="nc" id="L396">        this.conf = conf;</span>
<span class="nc" id="L397">        this.journalDirectories = Lists.newArrayList();</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        for (File journalDirectory : conf.getJournalDirs()) {</span>
<span class="nc" id="L399">            this.journalDirectories.add(getCurrentDirectory(journalDirectory));</span>
        }
<span class="nc" id="L401">        this.ledgerDirsManager = ledgerDirsManager;</span>
<span class="nc" id="L402">        this.indexDirsManager = indexDirsManager;</span>
<span class="nc" id="L403">        this.writeDataToJournal = conf.getJournalWriteData();</span>
<span class="nc" id="L404">        this.allocator = allocator;</span>
<span class="nc" id="L405">        this.registrationManager = registrationManager;</span>
<span class="nc" id="L406">        stateManager = initializeStateManager();</span>
<span class="nc" id="L407">        checkEnvironment();</span>

        // register shutdown handler using trigger mode
<span class="nc" id="L410">        stateManager.setShutdownHandler(exitCode -&gt; triggerBookieShutdown(exitCode));</span>
        // Initialise dirsMonitor. This would look through all the
        // configured directories. When disk errors or all the ledger
        // directories are full, would throws exception and fail bookie startup.
<span class="nc" id="L414">        List&lt;LedgerDirsManager&gt; dirsManagers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L415">        dirsManagers.add(ledgerDirsManager);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (indexDirsManager != ledgerDirsManager) {</span>
<span class="nc" id="L417">            dirsManagers.add(indexDirsManager);</span>
        }
<span class="nc" id="L419">        this.dirsMonitor = new LedgerDirsMonitor(conf, diskChecker, dirsManagers);</span>
        try {
<span class="nc" id="L421">            this.dirsMonitor.init();</span>
<span class="nc" id="L422">        } catch (NoWritableLedgerDirException nle) {</span>
            // start in read-only mode if no writable dirs and read-only allowed
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (!conf.isReadOnlyModeEnabled()) {</span>
<span class="nc" id="L425">                throw nle;</span>
            } else {
<span class="nc" id="L427">                this.stateManager.transitionToReadOnlyMode();</span>
            }
<span class="nc" id="L429">        }</span>

<span class="nc" id="L431">        JournalAliveListener journalAliveListener =</span>
<span class="nc" id="L432">                () -&gt; BookieImpl.this.triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);</span>
        // instantiate the journals
<span class="nc" id="L434">        journals = Lists.newArrayList();</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">        for (int i = 0; i &lt; journalDirectories.size(); i++) {</span>
<span class="nc" id="L436">            journals.add(new Journal(i, journalDirectories.get(i),</span>
<span class="nc" id="L437">                    conf, ledgerDirsManager, statsLogger.scope(JOURNAL_SCOPE), allocator, journalAliveListener));</span>
        }

<span class="nc" id="L440">        this.entryLogPerLedgerEnabled = conf.isEntryLogPerLedgerEnabled();</span>
<span class="nc" id="L441">        CheckpointSource checkpointSource = new CheckpointSourceList(journals);</span>

<span class="nc" id="L443">        this.ledgerStorage = storage;</span>
<span class="nc" id="L444">        boolean isDbLedgerStorage = ledgerStorage instanceof DbLedgerStorage;</span>

        /*
         * with this change https://github.com/apache/bookkeeper/pull/677,
         * LedgerStorage drives the checkpoint logic.
         *
         * &lt;p&gt;There are two exceptions:
         *
         * 1) with multiple entry logs, checkpoint logic based on a entry log is
         *    not possible, hence it needs to be timebased recurring thing and
         *    it is driven by SyncThread. SyncThread.start does that and it is
         *    started in Bookie.start method.
         *
         * 2) DbLedgerStorage
         */
<span class="nc bnc" id="L459" title="All 4 branches missed.">        if (entryLogPerLedgerEnabled || isDbLedgerStorage) {</span>
<span class="nc" id="L460">            syncThread = new SyncThread(conf, getLedgerDirsListener(), ledgerStorage, checkpointSource, statsLogger) {</span>
                @Override
                public void startCheckpoint(Checkpoint checkpoint) {
                    /*
                     * in the case of entryLogPerLedgerEnabled, LedgerStorage
                     * dont drive checkpoint logic, but instead it is done
                     * periodically by SyncThread. So startCheckpoint which
                     * will be called by LedgerStorage will be no-op.
                     */
<span class="nc" id="L469">                }</span>

                @Override
                public void start() {
<span class="nc" id="L473">                    executor.scheduleAtFixedRate(() -&gt; {</span>
<span class="nc" id="L474">                        doCheckpoint(checkpointSource.newCheckpoint());</span>
<span class="nc" id="L475">                    }, conf.getFlushInterval(), conf.getFlushInterval(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L476">                }</span>
            };
        } else {
<span class="nc" id="L479">            syncThread = new SyncThread(conf, getLedgerDirsListener(), ledgerStorage, checkpointSource, statsLogger);</span>
        }

<span class="nc" id="L482">        LedgerStorage.LedgerDeletionListener ledgerDeletionListener = new LedgerStorage.LedgerDeletionListener() {</span>
            @Override
            public void ledgerDeleted(long ledgerId) {
<span class="nc" id="L485">                masterKeyCache.remove(ledgerId);</span>
<span class="nc" id="L486">            }</span>
        };

<span class="nc" id="L489">        ledgerStorage.setStateManager(stateManager);</span>
<span class="nc" id="L490">        ledgerStorage.setCheckpointSource(checkpointSource);</span>
<span class="nc" id="L491">        ledgerStorage.setCheckpointer(syncThread);</span>
<span class="nc" id="L492">        ledgerStorage.registerLedgerDeletionListener(ledgerDeletionListener);</span>
<span class="nc" id="L493">        handles = new HandleFactoryImpl(ledgerStorage);</span>

        // Expose Stats
<span class="nc" id="L496">        this.bookieStats = new BookieStats(statsLogger, journalDirectories.size(), conf.getJournalQueueSize());</span>
<span class="nc" id="L497">    }</span>

    StateManager initializeStateManager() throws IOException {
<span class="nc" id="L500">        return new BookieStateManager(conf, statsLogger, registrationManager,</span>
                ledgerDirsManager, bookieServiceInfoProvider);
    }

    void readJournal() throws IOException, BookieException {
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (!conf.getJournalWriteData()) {</span>
<span class="nc" id="L506">            LOG.warn(&quot;Journal disabled for add entry requests. Running BookKeeper this way can &quot;</span>
                    + &quot;lead to data loss. It is recommended to use data integrity checking when &quot;
                    + &quot;running without the journal to minimize data loss risk&quot;);
        }

<span class="nc" id="L511">        long startTs = System.currentTimeMillis();</span>
<span class="nc" id="L512">        JournalScanner scanner = new JournalScanner() {</span>
            @Override
            public void process(int journalVersion, long offset, ByteBuffer recBuff) throws IOException {
<span class="nc" id="L515">                long ledgerId = recBuff.getLong();</span>
<span class="nc" id="L516">                long entryId = recBuff.getLong();</span>
                try {
<span class="nc bnc" id="L518" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L519">                        LOG.debug(&quot;Replay journal - ledger id : {}, entry id : {}.&quot;, ledgerId, entryId);</span>
                    }
<span class="nc bnc" id="L521" title="All 2 branches missed.">                    if (entryId == METAENTRY_ID_LEDGER_KEY) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                        if (journalVersion &gt;= JournalChannel.V3) {</span>
<span class="nc" id="L523">                            int masterKeyLen = recBuff.getInt();</span>
<span class="nc" id="L524">                            byte[] masterKey = new byte[masterKeyLen];</span>

<span class="nc" id="L526">                            recBuff.get(masterKey);</span>
<span class="nc" id="L527">                            masterKeyCache.put(ledgerId, masterKey);</span>

                            // Force to re-insert the master key in ledger storage
<span class="nc" id="L530">                            handles.getHandle(ledgerId, masterKey);</span>
<span class="nc" id="L531">                        } else {</span>
<span class="nc" id="L532">                            throw new IOException(&quot;Invalid journal. Contains journalKey &quot;</span>
                                    + &quot; but layout version (&quot; + journalVersion
                                    + &quot;) is too old to hold this&quot;);
                        }
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    } else if (entryId == METAENTRY_ID_FENCE_KEY) {</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                        if (journalVersion &gt;= JournalChannel.V4) {</span>
<span class="nc" id="L538">                            byte[] key = masterKeyCache.get(ledgerId);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                            if (key == null) {</span>
<span class="nc" id="L540">                                key = ledgerStorage.readMasterKey(ledgerId);</span>
                            }
<span class="nc" id="L542">                            LedgerDescriptor handle = handles.getHandle(ledgerId, key);</span>
<span class="nc" id="L543">                            handle.setFenced();</span>
<span class="nc" id="L544">                        } else {</span>
<span class="nc" id="L545">                            throw new IOException(&quot;Invalid journal. Contains fenceKey &quot;</span>
                                    + &quot; but layout version (&quot; + journalVersion
                                    + &quot;) is too old to hold this&quot;);
                        }
<span class="nc bnc" id="L549" title="All 2 branches missed.">                    } else if (entryId == METAENTRY_ID_LEDGER_EXPLICITLAC) {</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                        if (journalVersion &gt;= JournalChannel.V6) {</span>
<span class="nc" id="L551">                            int explicitLacBufLength = recBuff.getInt();</span>
<span class="nc" id="L552">                            ByteBuf explicitLacBuf = Unpooled.buffer(explicitLacBufLength);</span>
<span class="nc" id="L553">                            byte[] explicitLacBufArray = new byte[explicitLacBufLength];</span>
<span class="nc" id="L554">                            recBuff.get(explicitLacBufArray);</span>
<span class="nc" id="L555">                            explicitLacBuf.writeBytes(explicitLacBufArray);</span>
<span class="nc" id="L556">                            byte[] key = masterKeyCache.get(ledgerId);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                            if (key == null) {</span>
<span class="nc" id="L558">                                key = ledgerStorage.readMasterKey(ledgerId);</span>
                            }
<span class="nc" id="L560">                            LedgerDescriptor handle = handles.getHandle(ledgerId, key);</span>
<span class="nc" id="L561">                            handle.setExplicitLac(explicitLacBuf);</span>
<span class="nc" id="L562">                        } else {</span>
<span class="nc" id="L563">                            throw new IOException(&quot;Invalid journal. Contains explicitLAC &quot; + &quot; but layout version (&quot;</span>
                                    + journalVersion + &quot;) is too old to hold this&quot;);
                        }
<span class="nc bnc" id="L566" title="All 2 branches missed.">                    } else if (entryId &lt; 0) {</span>
                        /*
                         * this is possible if bookie code binary is rolledback
                         * to older version but when it is trying to read
                         * Journal which was created previously using newer
                         * code/journalversion, which introduced new special
                         * entry. So in anycase, if we see unrecognizable
                         * special entry while replaying journal we should skip
                         * (ignore) it.
                         */
<span class="nc" id="L576">                        LOG.warn(&quot;Read unrecognizable entryId: {} for ledger: {} while replaying Journal. Skipping it&quot;,</span>
<span class="nc" id="L577">                                entryId, ledgerId);</span>
                    } else {
<span class="nc" id="L579">                        byte[] key = masterKeyCache.get(ledgerId);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                        if (key == null) {</span>
<span class="nc" id="L581">                            key = ledgerStorage.readMasterKey(ledgerId);</span>
                        }
<span class="nc" id="L583">                        LedgerDescriptor handle = handles.getHandle(ledgerId, key);</span>

<span class="nc" id="L585">                        recBuff.rewind();</span>
<span class="nc" id="L586">                        handle.addEntry(Unpooled.wrappedBuffer(recBuff));</span>
                    }
<span class="nc" id="L588">                } catch (NoLedgerException nsle) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L590">                        LOG.debug(&quot;Skip replaying entries of ledger {} since it was deleted.&quot;, ledgerId);</span>
                    }
<span class="nc" id="L592">                } catch (BookieException be) {</span>
<span class="nc" id="L593">                    throw new IOException(be);</span>
<span class="nc" id="L594">                }</span>
<span class="nc" id="L595">            }</span>
        };

<span class="nc bnc" id="L598" title="All 2 branches missed.">        for (Journal journal : journals) {</span>
<span class="nc" id="L599">            replay(journal, scanner);</span>
<span class="nc" id="L600">        }</span>
<span class="nc" id="L601">        long elapsedTs = System.currentTimeMillis() - startTs;</span>
<span class="nc" id="L602">        LOG.info(&quot;Finished replaying journal in {} ms.&quot;, elapsedTs);</span>
<span class="nc" id="L603">    }</span>

    /**
     * Replay journal files and updates journal's in-memory lastLogMark object.
     *
     * @param journal Journal object corresponding to a journalDir
     * @param scanner Scanner to process replayed entries.
     * @throws IOException
     */
    private void replay(Journal journal, JournalScanner scanner) throws IOException {
<span class="nc" id="L613">        final LogMark markedLog = journal.getLastLogMark().getCurMark();</span>
<span class="nc" id="L614">        List&lt;Long&gt; logs = Journal.listJournalIds(journal.getJournalDirectory(), journalId -&gt;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            journalId &gt;= markedLog.getLogFileId());</span>
        // last log mark may be missed due to no sync up before
        // validate filtered log ids only when we have markedLogId
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (markedLog.getLogFileId() &gt; 0) {</span>
<span class="nc bnc" id="L619" title="All 4 branches missed.">            if (logs.size() == 0 || logs.get(0) != markedLog.getLogFileId()) {</span>
<span class="nc" id="L620">                String path = journal.getJournalDirectory().getAbsolutePath();</span>
<span class="nc" id="L621">                throw new IOException(&quot;Recovery log &quot; + markedLog.getLogFileId() + &quot; is missing at &quot; + path);</span>
            }
        }

        // TODO: When reading in the journal logs that need to be synced, we
        // should use BufferedChannels instead to minimize the amount of
        // system calls done.
<span class="nc bnc" id="L628" title="All 2 branches missed.">        for (Long id : logs) {</span>
<span class="nc" id="L629">            long logPosition = 0L;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">            if (id == markedLog.getLogFileId()) {</span>
<span class="nc" id="L631">                logPosition = markedLog.getLogFileOffset();</span>
            }
<span class="nc" id="L633">            LOG.info(&quot;Replaying journal {} from position {}&quot;, id, logPosition);</span>
<span class="nc" id="L634">            long scanOffset = journal.scanJournal(id, logPosition, scanner);</span>
            // Update LastLogMark after completely replaying journal
            // scanOffset will point to EOF position
            // After LedgerStorage flush, SyncThread should persist this to disk
<span class="nc" id="L638">            journal.setLastLogMark(id, scanOffset);</span>
<span class="nc" id="L639">        }</span>
<span class="nc" id="L640">    }</span>

    @Override
    public synchronized void start() {
<span class="nc" id="L644">        setDaemon(true);</span>
<span class="nc" id="L645">        ThreadRegistry.register(&quot;BookieThread&quot;, 0);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L647">            LOG.debug(&quot;I'm starting a bookie with journal directories {}&quot;,</span>
<span class="nc" id="L648">                    journalDirectories.stream().map(File::getName).collect(Collectors.joining(&quot;, &quot;)));</span>
        }
        //Start DiskChecker thread
<span class="nc" id="L651">        dirsMonitor.start();</span>

        // replay journals
        try {
<span class="nc" id="L655">            readJournal();</span>
<span class="nc" id="L656">        } catch (IOException | BookieException ioe) {</span>
<span class="nc" id="L657">            LOG.error(&quot;Exception while replaying journals, shutting down&quot;, ioe);</span>
<span class="nc" id="L658">            shutdown(ExitCode.BOOKIE_EXCEPTION);</span>
<span class="nc" id="L659">            return;</span>
<span class="nc" id="L660">        }</span>

        // Do a fully flush after journal replay
        try {
<span class="nc" id="L664">            syncThread.requestFlush().get();</span>
<span class="nc" id="L665">        } catch (InterruptedException e) {</span>
<span class="nc" id="L666">            LOG.warn(&quot;Interrupting the fully flush after replaying journals : &quot;, e);</span>
<span class="nc" id="L667">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L668">        } catch (ExecutionException e) {</span>
<span class="nc" id="L669">            LOG.error(&quot;Error on executing a fully flush after replaying journals.&quot;);</span>
<span class="nc" id="L670">            shutdown(ExitCode.BOOKIE_EXCEPTION);</span>
<span class="nc" id="L671">            return;</span>
<span class="nc" id="L672">        }</span>

<span class="nc bnc" id="L674" title="All 2 branches missed.">        if (conf.isLocalConsistencyCheckOnStartup()) {</span>
<span class="nc" id="L675">            LOG.info(&quot;Running local consistency check on startup prior to accepting IO.&quot;);</span>
<span class="nc" id="L676">            List&lt;LedgerStorage.DetectedInconsistency&gt; errors = null;</span>
            try {
<span class="nc" id="L678">                errors = ledgerStorage.localConsistencyCheck(Optional.empty());</span>
<span class="nc" id="L679">            } catch (IOException e) {</span>
<span class="nc" id="L680">                LOG.error(&quot;Got a fatal exception while checking store&quot;, e);</span>
<span class="nc" id="L681">                shutdown(ExitCode.BOOKIE_EXCEPTION);</span>
<span class="nc" id="L682">                return;</span>
<span class="nc" id="L683">            }</span>
<span class="nc bnc" id="L684" title="All 4 branches missed.">            if (errors != null &amp;&amp; errors.size() &gt; 0) {</span>
<span class="nc" id="L685">                LOG.error(&quot;Bookie failed local consistency check:&quot;);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                for (LedgerStorage.DetectedInconsistency error : errors) {</span>
<span class="nc" id="L687">                    LOG.error(&quot;Ledger {}, entry {}: &quot;, error.getLedgerId(), error.getEntryId(), error.getException());</span>
<span class="nc" id="L688">                }</span>
<span class="nc" id="L689">                shutdown(ExitCode.BOOKIE_EXCEPTION);</span>
<span class="nc" id="L690">                return;</span>
            }
        }

<span class="nc" id="L694">        LOG.info(&quot;Finished reading journal, starting bookie&quot;);</span>


        /*
         * start sync thread first, so during replaying journals, we could do
         * checkpoint which reduce the chance that we need to replay journals
         * again if bookie restarted again before finished journal replays.
         */
<span class="nc" id="L702">        syncThread.start();</span>

        // start bookie thread
<span class="nc" id="L705">        super.start();</span>

        // After successful bookie startup, register listener for disk
        // error/full notifications.
<span class="nc" id="L709">        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (indexDirsManager != ledgerDirsManager) {</span>
<span class="nc" id="L711">            indexDirsManager.addLedgerDirsListener(getLedgerDirsListener());</span>
        }

<span class="nc" id="L714">        ledgerStorage.start();</span>

        // check the bookie status to start with, and set running.
        // since bookie server use running as a flag to tell bookie server whether it is alive
        // if setting it in bookie thread, the watcher might run before bookie thread.
<span class="nc" id="L719">        stateManager.initState();</span>

        try {
<span class="nc" id="L722">            stateManager.registerBookie(true).get();</span>
<span class="nc" id="L723">        } catch (Exception e) {</span>
<span class="nc" id="L724">            LOG.error(&quot;Couldn't register bookie with zookeeper, shutting down : &quot;, e);</span>
<span class="nc" id="L725">            shutdown(ExitCode.ZK_REG_FAIL);</span>
<span class="nc" id="L726">        }</span>
<span class="nc" id="L727">    }</span>

    /*
     * Get the DiskFailure listener for the bookie
     */
    private LedgerDirsListener getLedgerDirsListener() {

<span class="nc" id="L734">        return new LedgerDirsListener() {</span>

            @Override
            public void diskFailed(File disk) {
                // Shutdown the bookie on disk failure.
<span class="nc" id="L739">                triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);</span>
<span class="nc" id="L740">            }</span>

            @Override
            public void allDisksFull(boolean highPriorityWritesAllowed) {
                // Transition to readOnly mode on all disks full
<span class="nc" id="L745">                stateManager.setHighPriorityWritesAvailability(highPriorityWritesAllowed);</span>
<span class="nc" id="L746">                stateManager.transitionToReadOnlyMode();</span>
<span class="nc" id="L747">            }</span>

            @Override
            public void fatalError() {
<span class="nc" id="L751">                LOG.error(&quot;Fatal error reported by ledgerDirsManager&quot;);</span>
<span class="nc" id="L752">                triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);</span>
<span class="nc" id="L753">            }</span>

            @Override
            public void diskWritable(File disk) {
<span class="nc bnc" id="L757" title="All 2 branches missed.">                if (conf.isReadOnlyModeOnAnyDiskFullEnabled()) {</span>
<span class="nc" id="L758">                    return;</span>
                }
                // Transition to writable mode when a disk becomes writable again.
<span class="nc" id="L761">                stateManager.setHighPriorityWritesAvailability(true);</span>
<span class="nc" id="L762">                stateManager.transitionToWritableMode();</span>
<span class="nc" id="L763">            }</span>

            @Override
            public void diskJustWritable(File disk) {
<span class="nc bnc" id="L767" title="All 2 branches missed.">                if (conf.isReadOnlyModeOnAnyDiskFullEnabled()) {</span>
<span class="nc" id="L768">                    return;</span>
                }
                // Transition to writable mode when a disk becomes writable again.
<span class="nc" id="L771">                stateManager.setHighPriorityWritesAvailability(true);</span>
<span class="nc" id="L772">                stateManager.transitionToWritableMode();</span>
<span class="nc" id="L773">            }</span>

            @Override
            public void anyDiskFull(boolean highPriorityWritesAllowed) {
<span class="nc bnc" id="L777" title="All 2 branches missed.">                if (conf.isReadOnlyModeOnAnyDiskFullEnabled()) {</span>
<span class="nc" id="L778">                    stateManager.setHighPriorityWritesAvailability(highPriorityWritesAllowed);</span>
<span class="nc" id="L779">                    stateManager.transitionToReadOnlyMode();</span>
                }
<span class="nc" id="L781">            }</span>

            @Override
            public void allDisksWritable() {
                // Transition to writable mode when a disk becomes writable again.
<span class="nc" id="L786">                stateManager.setHighPriorityWritesAvailability(true);</span>
<span class="nc" id="L787">                stateManager.transitionToWritableMode();</span>
<span class="nc" id="L788">            }</span>
        };
    }

    /*
     * Check whether Bookie is writable.
     */
    public boolean isReadOnly() {
<span class="nc" id="L796">        return stateManager.isReadOnly();</span>
    }

    /**
     * Check whether Bookie is available for high priority writes.
     *
     * @return true if the bookie is able to take high priority writes.
     */
    public boolean isAvailableForHighPriorityWrites() {
<span class="nc" id="L805">        return stateManager.isAvailableForHighPriorityWrites();</span>
    }

    public boolean isRunning() {
<span class="nc" id="L809">        return stateManager.isRunning();</span>
    }

    @Override
    public void run() {
        // start journals
<span class="nc bnc" id="L815" title="All 2 branches missed.">        for (Journal journal: journals) {</span>
<span class="nc" id="L816">            journal.start();</span>
<span class="nc" id="L817">        }</span>
<span class="nc" id="L818">    }</span>

    // Triggering the Bookie shutdown in its own thread,
    // because shutdown can be called from sync thread which would be
    // interrupted by shutdown call.
<span class="nc" id="L823">    AtomicBoolean shutdownTriggered = new AtomicBoolean(false);</span>
    void triggerBookieShutdown(final int exitCode) {
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (!shutdownTriggered.compareAndSet(false, true)) {</span>
<span class="nc" id="L826">            return;</span>
        }
<span class="nc" id="L828">        LOG.info(&quot;Triggering shutdown of Bookie-{} with exitCode {}&quot;,</span>
<span class="nc" id="L829">                 conf.getBookiePort(), exitCode);</span>
<span class="nc" id="L830">        BookieThread th = new BookieThread(&quot;BookieShutdownTrigger&quot;) {</span>
            @Override
            public void run() {
<span class="nc" id="L833">                BookieImpl.this.shutdown(exitCode);</span>
<span class="nc" id="L834">            }</span>
        };
<span class="nc" id="L836">        th.start();</span>
<span class="nc" id="L837">    }</span>

    // provided a public shutdown method for other caller
    // to shut down bookie gracefully
    public int shutdown() {
<span class="nc" id="L842">        return shutdown(ExitCode.OK);</span>
    }
    // internal shutdown method to let shutdown bookie gracefully
    // when encountering exception
<span class="nc" id="L846">    ReentrantLock lock = new ReentrantLock(true);</span>
    int shutdown(int exitCode) {
<span class="nc" id="L848">        lock.lock();</span>
        try {
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (isRunning()) {</span>
                // the exitCode only set when first shutdown usually due to exception found
<span class="nc" id="L852">                LOG.info(&quot;Shutting down Bookie-{} with exitCode {}&quot;,</span>
<span class="nc" id="L853">                         conf.getBookiePort(), exitCode);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                if (this.exitCode == ExitCode.OK) {</span>
<span class="nc" id="L855">                    this.exitCode = exitCode;</span>
                }

<span class="nc" id="L858">                stateManager.forceToShuttingDown();</span>

                // turn bookie to read only during shutting down process
<span class="nc" id="L861">                LOG.info(&quot;Turning bookie to read only during shut down&quot;);</span>
<span class="nc" id="L862">                stateManager.forceToReadOnly();</span>

                // Shutdown Sync thread
<span class="nc" id="L865">                syncThread.shutdown();</span>

                // Shutdown journals
<span class="nc bnc" id="L868" title="All 2 branches missed.">                for (Journal journal : journals) {</span>
<span class="nc" id="L869">                    journal.shutdown();</span>
<span class="nc" id="L870">                }</span>

                // Shutdown the EntryLogger which has the GarbageCollector Thread running
<span class="nc" id="L873">                ledgerStorage.shutdown();</span>

                //Shutdown disk checker
<span class="nc" id="L876">                dirsMonitor.shutdown();</span>
            }
<span class="nc" id="L878">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L879">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L880">            LOG.error(&quot;Interrupted during shutting down bookie : &quot;, ie);</span>
<span class="nc" id="L881">        } catch (Exception e) {</span>
<span class="nc" id="L882">            LOG.error(&quot;Got Exception while trying to shutdown Bookie&quot;, e);</span>
<span class="nc" id="L883">            throw e;</span>
        } finally {
<span class="nc" id="L885">            lock.unlock();</span>
            // setting running to false here, so watch thread
            // in bookie server know it only after bookie shut down
<span class="nc" id="L888">            stateManager.close();</span>
        }
<span class="nc" id="L890">        return this.exitCode;</span>
    }

    /**
     * Retrieve the ledger descriptor for the ledger which entry should be added to.
     * The LedgerDescriptor returned from this method should be eventually freed with
     * #putHandle().
     *
     * @throws BookieException if masterKey does not match the master key of the ledger
     */
    @VisibleForTesting
    LedgerDescriptor getLedgerForEntry(ByteBuf entry, final byte[] masterKey)
            throws IOException, BookieException {
<span class="nc" id="L903">        final long ledgerId = entry.getLong(entry.readerIndex());</span>

<span class="nc" id="L905">        return handles.getHandle(ledgerId, masterKey);</span>
    }

    private Journal getJournal(long ledgerId) {
<span class="nc" id="L909">        return journals.get(MathUtils.signSafeMod(ledgerId, journals.size()));</span>
    }

    @VisibleForTesting
    public ByteBuf createMasterKeyEntry(long ledgerId, byte[] masterKey) {
        // new handle, we should add the key to journal ensure we can rebuild
<span class="nc" id="L915">        ByteBuf bb = allocator.directBuffer(8 + 8 + 4 + masterKey.length);</span>
<span class="nc" id="L916">        bb.writeLong(ledgerId);</span>
<span class="nc" id="L917">        bb.writeLong(METAENTRY_ID_LEDGER_KEY);</span>
<span class="nc" id="L918">        bb.writeInt(masterKey.length);</span>
<span class="nc" id="L919">        bb.writeBytes(masterKey);</span>
<span class="nc" id="L920">        return bb;</span>
    }

    /**
     * Add an entry to a ledger as specified by handle.
     */
    private void addEntryInternal(LedgerDescriptor handle, ByteBuf entry,
                                  boolean ackBeforeSync, WriteCallback cb, Object ctx, byte[] masterKey)
            throws IOException, BookieException, InterruptedException {
<span class="nc" id="L929">        long ledgerId = handle.getLedgerId();</span>
<span class="nc" id="L930">        long entryId = handle.addEntry(entry);</span>

<span class="nc" id="L932">        bookieStats.getWriteBytes().addCount(entry.readableBytes());</span>

        // journal `addEntry` should happen after the entry is added to ledger storage.
        // otherwise the journal entry can potentially be rolled before the ledger is created in ledger storage.
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (masterKeyCache.get(ledgerId) == null) {</span>
            // Force the load into masterKey cache
<span class="nc" id="L938">            byte[] oldValue = masterKeyCache.putIfAbsent(ledgerId, masterKey);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if (oldValue == null) {</span>
<span class="nc" id="L940">                ByteBuf masterKeyEntry = createMasterKeyEntry(ledgerId, masterKey);</span>
                try {
<span class="nc" id="L942">                    getJournal(ledgerId).logAddEntry(</span>
                            masterKeyEntry, false /* ackBeforeSync */, new NopWriteCallback(), null);
                } finally {
<span class="nc" id="L945">                    ReferenceCountUtil.release(masterKeyEntry);</span>
                }
            }
        }

<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (!writeDataToJournal) {</span>
<span class="nc" id="L951">            cb.writeComplete(0, ledgerId, entryId, null, ctx);</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">            if (ctx instanceof BookieRequestHandler) {</span>
<span class="nc" id="L953">                ((BookieRequestHandler) ctx).flushPendingResponse();</span>
            }
<span class="nc" id="L955">            return;</span>
        }

<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L959">            LOG.trace(&quot;Adding {}@{}&quot;, entryId, ledgerId);</span>
        }
<span class="nc" id="L961">        getJournal(ledgerId).logAddEntry(entry, ackBeforeSync, cb, ctx);</span>
<span class="nc" id="L962">    }</span>

    /**
     * Add entry to a ledger, even if the ledger has previous been fenced. This should only
     * happen in bookie recovery or ledger recovery cases, where entries are being replicates
     * so that they exist on a quorum of bookies. The corresponding client side call for this
     * is not exposed to users.
     */
    public void recoveryAddEntry(ByteBuf entry, WriteCallback cb, Object ctx, byte[] masterKey)
            throws IOException, BookieException, InterruptedException {
<span class="nc" id="L972">        long requestNanos = MathUtils.nowInNano();</span>
<span class="nc" id="L973">        boolean success = false;</span>
<span class="nc" id="L974">        int entrySize = 0;</span>
        try {
<span class="nc" id="L976">            LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);</span>
<span class="nc" id="L977">            synchronized (handle) {</span>
<span class="nc" id="L978">                entrySize = entry.readableBytes();</span>
<span class="nc" id="L979">                addEntryInternal(handle, entry, false /* ackBeforeSync */, cb, ctx, masterKey);</span>
<span class="nc" id="L980">            }</span>
<span class="nc" id="L981">            success = true;</span>
<span class="nc" id="L982">        } catch (NoWritableLedgerDirException e) {</span>
<span class="nc" id="L983">            stateManager.transitionToReadOnlyMode();</span>
<span class="nc" id="L984">            throw new IOException(e);</span>
        } finally {
<span class="nc" id="L986">            long elapsedNanos = MathUtils.elapsedNanos(requestNanos);</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">            if (success) {</span>
<span class="nc" id="L988">                bookieStats.getRecoveryAddEntryStats().registerSuccessfulEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L989">                bookieStats.getAddBytesStats().registerSuccessfulValue(entrySize);</span>
            } else {
<span class="nc" id="L991">                bookieStats.getRecoveryAddEntryStats().registerFailedEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L992">                bookieStats.getAddBytesStats().registerFailedValue(entrySize);</span>
            }

<span class="nc" id="L995">            ReferenceCountUtil.release(entry);</span>
        }
<span class="nc" id="L997">    }</span>

    @VisibleForTesting
    public ByteBuf createExplicitLACEntry(long ledgerId, ByteBuf explicitLac) {
<span class="nc" id="L1001">        ByteBuf bb = allocator.directBuffer(8 + 8 + 4 + explicitLac.capacity());</span>
<span class="nc" id="L1002">        bb.writeLong(ledgerId);</span>
<span class="nc" id="L1003">        bb.writeLong(METAENTRY_ID_LEDGER_EXPLICITLAC);</span>
<span class="nc" id="L1004">        bb.writeInt(explicitLac.capacity());</span>
<span class="nc" id="L1005">        bb.writeBytes(explicitLac);</span>
<span class="nc" id="L1006">        return bb;</span>
    }

    public void setExplicitLac(ByteBuf entry, WriteCallback writeCallback, Object ctx, byte[] masterKey)
            throws IOException, InterruptedException, BookieException {
<span class="nc" id="L1011">        ByteBuf explicitLACEntry = null;</span>
        try {
<span class="nc" id="L1013">            long ledgerId = entry.getLong(entry.readerIndex());</span>
<span class="nc" id="L1014">            LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);</span>
<span class="nc" id="L1015">            synchronized (handle) {</span>
<span class="nc" id="L1016">                entry.markReaderIndex();</span>
<span class="nc" id="L1017">                handle.setExplicitLac(entry);</span>
<span class="nc" id="L1018">                entry.resetReaderIndex();</span>
<span class="nc" id="L1019">                explicitLACEntry = createExplicitLACEntry(ledgerId, entry);</span>
<span class="nc" id="L1020">                getJournal(ledgerId).logAddEntry(explicitLACEntry, false /* ackBeforeSync */, writeCallback, ctx);</span>
<span class="nc" id="L1021">            }</span>
<span class="nc" id="L1022">        } catch (NoWritableLedgerDirException e) {</span>
<span class="nc" id="L1023">            stateManager.transitionToReadOnlyMode();</span>
<span class="nc" id="L1024">            throw new IOException(e);</span>
        } finally {
<span class="nc" id="L1026">            ReferenceCountUtil.release(entry);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            if (explicitLACEntry != null) {</span>
<span class="nc" id="L1028">                ReferenceCountUtil.release(explicitLACEntry);</span>
            }
        }
<span class="nc" id="L1031">    }</span>

    public ByteBuf getExplicitLac(long ledgerId) throws IOException, Bookie.NoLedgerException, BookieException {
        ByteBuf lac;
<span class="nc" id="L1035">        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);</span>
<span class="nc" id="L1036">        synchronized (handle) {</span>
<span class="nc" id="L1037">            lac = handle.getExplicitLac();</span>
<span class="nc" id="L1038">        }</span>
<span class="nc" id="L1039">        return lac;</span>
    }

    /**
     * Force sync given 'ledgerId' entries on the journal to the disk.
     * It works like a regular addEntry with ackBeforeSync=false.
     * This is useful for ledgers with DEFERRED_SYNC write flag.
     */
    public void forceLedger(long ledgerId, WriteCallback cb,
                            Object ctx) {
<span class="nc bnc" id="L1049" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1050">            LOG.trace(&quot;Forcing ledger {}&quot;, ledgerId);</span>
        }
<span class="nc" id="L1052">        Journal journal = getJournal(ledgerId);</span>
<span class="nc" id="L1053">        journal.forceLedger(ledgerId, cb, ctx);</span>
<span class="nc" id="L1054">        bookieStats.getForceLedgerOps().inc();</span>
<span class="nc" id="L1055">    }</span>

    /**
     * Add entry to a ledger.
     */
    public void addEntry(ByteBuf entry, boolean ackBeforeSync, WriteCallback cb, Object ctx, byte[] masterKey)
            throws IOException, BookieException, InterruptedException {
<span class="nc" id="L1062">        long requestNanos = MathUtils.nowInNano();</span>
<span class="nc" id="L1063">        boolean success = false;</span>
<span class="nc" id="L1064">        int entrySize = 0;</span>
        try {
<span class="nc" id="L1066">            LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);</span>
<span class="nc" id="L1067">            synchronized (handle) {</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                if (handle.isFenced()) {</span>
<span class="nc" id="L1069">                    throw BookieException</span>
<span class="nc" id="L1070">                            .create(BookieException.Code.LedgerFencedException);</span>
                }
<span class="nc" id="L1072">                entrySize = entry.readableBytes();</span>
<span class="nc" id="L1073">                addEntryInternal(handle, entry, ackBeforeSync, cb, ctx, masterKey);</span>
<span class="nc" id="L1074">            }</span>
<span class="nc" id="L1075">            success = true;</span>
<span class="nc" id="L1076">        } catch (NoWritableLedgerDirException e) {</span>
<span class="nc" id="L1077">            stateManager.transitionToReadOnlyMode();</span>
<span class="nc" id="L1078">            throw new IOException(e);</span>
        } finally {
<span class="nc" id="L1080">            long elapsedNanos = MathUtils.elapsedNanos(requestNanos);</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">            if (success) {</span>
<span class="nc" id="L1082">                bookieStats.getAddEntryStats().registerSuccessfulEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L1083">                bookieStats.getAddBytesStats().registerSuccessfulValue(entrySize);</span>
            } else {
<span class="nc" id="L1085">                bookieStats.getAddEntryStats().registerFailedEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L1086">                bookieStats.getAddBytesStats().registerFailedValue(entrySize);</span>
            }

<span class="nc" id="L1089">            ReferenceCountUtil.release(entry);</span>
        }
<span class="nc" id="L1091">    }</span>

    /**
     * Fences a ledger. From this point on, clients will be unable to
     * write to this ledger. Only recoveryAddEntry will be
     * able to add entries to the ledger.
     * This method is idempotent. Once a ledger is fenced, it can
     * never be unfenced. Fencing a fenced ledger has no effect.
     * @return
     */
    public CompletableFuture&lt;Boolean&gt; fenceLedger(long ledgerId, byte[] masterKey)
            throws IOException, BookieException {
<span class="nc" id="L1103">        LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);</span>
<span class="nc" id="L1104">        return handle.fenceAndLogInJournal(getJournal(ledgerId));</span>
    }

    public ByteBuf readEntry(long ledgerId, long entryId)
            throws IOException, NoLedgerException, BookieException {
<span class="nc" id="L1109">        long requestNanos = MathUtils.nowInNano();</span>
<span class="nc" id="L1110">        boolean success = false;</span>
<span class="nc" id="L1111">        int entrySize = 0;</span>
        try {
<span class="nc" id="L1113">            LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1115">                LOG.trace(&quot;Reading {}@{}&quot;, entryId, ledgerId);</span>
            }
<span class="nc" id="L1117">            ByteBuf entry = handle.readEntry(entryId);</span>
<span class="nc" id="L1118">            entrySize = entry.readableBytes();</span>
<span class="nc" id="L1119">            bookieStats.getReadBytes().addCount(entrySize);</span>
<span class="nc" id="L1120">            success = true;</span>
<span class="nc" id="L1121">            return entry;</span>
        } finally {
<span class="nc" id="L1123">            long elapsedNanos = MathUtils.elapsedNanos(requestNanos);</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">            if (success) {</span>
<span class="nc" id="L1125">                bookieStats.getReadEntryStats().registerSuccessfulEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L1126">                bookieStats.getReadBytesStats().registerSuccessfulValue(entrySize);</span>
            } else {
<span class="nc" id="L1128">                bookieStats.getReadEntryStats().registerFailedEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L1129">                bookieStats.getReadBytesStats().registerFailedValue(entrySize);</span>
            }
        }
    }

    public long readLastAddConfirmed(long ledgerId) throws IOException, BookieException {
<span class="nc" id="L1135">        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);</span>
<span class="nc" id="L1136">        return handle.getLastAddConfirmed();</span>
    }

    public boolean waitForLastAddConfirmedUpdate(long ledgerId,
                                                 long previousLAC,
                                                 Watcher&lt;LastAddConfirmedUpdateNotification&gt; watcher)
            throws IOException {
<span class="nc" id="L1143">        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);</span>
<span class="nc" id="L1144">        return handle.waitForLastAddConfirmedUpdate(previousLAC, watcher);</span>
    }

    public void cancelWaitForLastAddConfirmedUpdate(long ledgerId,
                                                    Watcher&lt;LastAddConfirmedUpdateNotification&gt; watcher)
            throws IOException {
<span class="nc" id="L1150">        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);</span>
<span class="nc" id="L1151">        handle.cancelWaitForLastAddConfirmedUpdate(watcher);</span>
<span class="nc" id="L1152">    }</span>

    @VisibleForTesting
    public LedgerStorage getLedgerStorage() {
<span class="nc" id="L1156">        return ledgerStorage;</span>
    }

    @VisibleForTesting
    public BookieStateManager getStateManager() {
<span class="nc" id="L1161">        return (BookieStateManager) this.stateManager;</span>
    }

    public ByteBufAllocator getAllocator() {
<span class="nc" id="L1165">        return allocator;</span>
    }

    /**
     * Format the bookie server data.
     *
     * @param conf ServerConfiguration
     * @param isInteractive Whether format should ask prompt for confirmation if old data exists or not.
     * @param force If non interactive and force is true, then old data will be removed without confirm prompt.
     * @return Returns true if the format is success else returns false
     */
    public static boolean format(ServerConfiguration conf,
            boolean isInteractive, boolean force) {
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        for (File journalDir : conf.getJournalDirs()) {</span>
            String[] journalDirFiles =
<span class="nc bnc" id="L1180" title="All 4 branches missed.">                    journalDir.exists() &amp;&amp; journalDir.isDirectory() ? journalDir.list() : null;</span>
<span class="nc bnc" id="L1181" title="All 4 branches missed.">            if (journalDirFiles != null &amp;&amp; journalDirFiles.length != 0) {</span>
                try {
<span class="nc" id="L1183">                    boolean confirm = false;</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                    if (!isInteractive) {</span>
                        // If non interactive and force is set, then delete old
                        // data.
<span class="nc" id="L1187">                        confirm = force;</span>
                    } else {
<span class="nc" id="L1189">                        confirm = IOUtils</span>
<span class="nc" id="L1190">                                .confirmPrompt(&quot;Are you sure to format Bookie data..?&quot;);</span>
                    }

<span class="nc bnc" id="L1193" title="All 2 branches missed.">                    if (!confirm) {</span>
<span class="nc" id="L1194">                        LOG.error(&quot;Bookie format aborted!!&quot;);</span>
<span class="nc" id="L1195">                        return false;</span>
                    }
<span class="nc" id="L1197">                } catch (IOException e) {</span>
<span class="nc" id="L1198">                    LOG.error(&quot;Error during bookie format&quot;, e);</span>
<span class="nc" id="L1199">                    return false;</span>
<span class="nc" id="L1200">                }</span>
            }
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if (!cleanDir(journalDir)) {</span>
<span class="nc" id="L1203">                LOG.error(&quot;Formatting journal directory failed&quot;);</span>
<span class="nc" id="L1204">                return false;</span>
            }
        }

<span class="nc" id="L1208">        File[] ledgerDirs = conf.getLedgerDirs();</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        for (File dir : ledgerDirs) {</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            if (!cleanDir(dir)) {</span>
<span class="nc" id="L1211">                LOG.error(&quot;Formatting ledger directory &quot; + dir + &quot; failed&quot;);</span>
<span class="nc" id="L1212">                return false;</span>
            }
        }

        // Clean up index directories if they are separate from the ledger dirs
<span class="nc" id="L1217">        File[] indexDirs = conf.getIndexDirs();</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (null != indexDirs) {</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">            for (File dir : indexDirs) {</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">                if (!cleanDir(dir)) {</span>
<span class="nc" id="L1221">                    LOG.error(&quot;Formatting index directory &quot; + dir + &quot; failed&quot;);</span>
<span class="nc" id="L1222">                    return false;</span>
                }
            }
        }

        // Clean up metadata directories if they are separate from the
        // ledger dirs
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (!Strings.isNullOrEmpty(conf.getGcEntryLogMetadataCachePath())) {</span>
<span class="nc" id="L1230">            File metadataDir = new File(conf.getGcEntryLogMetadataCachePath());</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (!cleanDir(metadataDir)) {</span>
<span class="nc" id="L1232">                LOG.error(&quot;Formatting ledger metadata directory {} failed&quot;, metadataDir);</span>
<span class="nc" id="L1233">                return false;</span>
            }
        }
<span class="nc" id="L1236">        LOG.info(&quot;Bookie format completed successfully&quot;);</span>
<span class="nc" id="L1237">        return true;</span>
    }

    private static boolean cleanDir(File dir) {
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        if (dir.exists()) {</span>
<span class="nc" id="L1242">            File[] files = dir.listFiles();</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">            if (files != null) {</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">                for (File child : files) {</span>
<span class="nc" id="L1245">                    boolean delete = FileUtils.deleteQuietly(child);</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">                    if (!delete) {</span>
<span class="nc" id="L1247">                        LOG.error(&quot;Not able to delete &quot; + child);</span>
<span class="nc" id="L1248">                        return false;</span>
                    }
                }
            }
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        } else if (!dir.mkdirs()) {</span>
<span class="nc" id="L1253">            LOG.error(&quot;Not able to create the directory &quot; + dir);</span>
<span class="nc" id="L1254">            return false;</span>
        }
<span class="nc" id="L1256">        return true;</span>
    }

    /**
     * Returns exit code - cause of failure.
     *
     * @return {@link ExitCode}
     */
    public int getExitCode() {
<span class="nc" id="L1265">        return exitCode;</span>
    }

    public OfLong getListOfEntriesOfLedger(long ledgerId) throws IOException, NoLedgerException {
<span class="nc" id="L1269">        long requestNanos = MathUtils.nowInNano();</span>
<span class="nc" id="L1270">        boolean success = false;</span>
        try {
<span class="nc" id="L1272">            LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1274">                LOG.trace(&quot;GetEntriesOfLedger {}&quot;, ledgerId);</span>
            }
<span class="nc" id="L1276">            OfLong entriesOfLedger = handle.getListOfEntriesOfLedger(ledgerId);</span>
<span class="nc" id="L1277">            success = true;</span>
<span class="nc" id="L1278">            return entriesOfLedger;</span>
        } finally {
<span class="nc" id="L1280">            long elapsedNanos = MathUtils.elapsedNanos(requestNanos);</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">            if (success) {</span>
<span class="nc" id="L1282">                bookieStats.getReadEntryStats().registerSuccessfulEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
            } else {
<span class="nc" id="L1284">                bookieStats.getReadEntryStats().registerFailedEvent(elapsedNanos, TimeUnit.NANOSECONDS);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>