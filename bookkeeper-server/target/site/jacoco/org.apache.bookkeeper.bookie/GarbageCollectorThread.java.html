<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GarbageCollectorThread.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">GarbageCollectorThread.java</span></div><h1>GarbageCollectorThread.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.bookkeeper.bookie;

import static org.apache.bookkeeper.util.BookKeeperConstants.METADATA_CACHE;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.netty.util.concurrent.DefaultThreadFactory;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import lombok.Getter;
import org.apache.bookkeeper.bookie.BookieException.EntryLogMetadataMapException;
import org.apache.bookkeeper.bookie.GarbageCollector.GarbageCleaner;
import org.apache.bookkeeper.bookie.stats.GarbageCollectorStats;
import org.apache.bookkeeper.bookie.storage.EntryLogger;
import org.apache.bookkeeper.bookie.storage.ldb.PersistentEntryLogMetadataMap;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.meta.LedgerManager;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.util.MathUtils;
import org.apache.commons.lang3.mutable.MutableBoolean;
import org.apache.commons.lang3.mutable.MutableLong;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This is the garbage collector thread that runs in the background to
 * remove any entry log files that no longer contains any active ledger.
 */
public class GarbageCollectorThread implements Runnable {
<span class="nc" id="L59">    private static final Logger LOG = LoggerFactory.getLogger(GarbageCollectorThread.class);</span>
    private static final int SECOND = 1000;

    // Maps entry log files to the set of ledgers that comprise the file and the size usage per ledger
    private EntryLogMetadataMap entryLogMetaMap;

    private final ScheduledExecutorService gcExecutor;
<span class="nc" id="L66">    Future&lt;?&gt; scheduledFuture = null;</span>

    // This is how often we want to run the Garbage Collector Thread (in milliseconds).
    final long gcWaitTime;

    // Compaction parameters
<span class="nc" id="L72">    boolean isForceMinorCompactionAllow = false;</span>
<span class="nc" id="L73">    boolean enableMinorCompaction = false;</span>
    final double minorCompactionThreshold;
    final long minorCompactionInterval;
    final long minorCompactionMaxTimeMillis;
    long lastMinorCompactionTime;

<span class="nc" id="L79">    boolean isForceMajorCompactionAllow = false;</span>
<span class="nc" id="L80">    boolean enableMajorCompaction = false;</span>
    final double majorCompactionThreshold;
    final long majorCompactionInterval;
    long majorCompactionMaxTimeMillis;
    long lastMajorCompactionTime;

<span class="nc" id="L86">    @Getter</span>
    final boolean isForceGCAllowWhenNoSpace;

    // Entry Logger Handle
    final EntryLogger entryLogger;
    final AbstractLogCompactor compactor;

    // Stats loggers for garbage collection operations
    private final GarbageCollectorStats gcStats;

    private volatile long totalEntryLogSize;
    private volatile int numActiveEntryLogs;

    final CompactableLedgerStorage ledgerStorage;

    // flag to ensure gc thread will not be interrupted during compaction
    // to reduce the risk getting entry log corrupted
<span class="nc" id="L103">    final AtomicBoolean compacting = new AtomicBoolean(false);</span>

    // use to get the compacting status
<span class="nc" id="L106">    final AtomicBoolean minorCompacting = new AtomicBoolean(false);</span>
<span class="nc" id="L107">    final AtomicBoolean majorCompacting = new AtomicBoolean(false);</span>

<span class="nc" id="L109">    volatile boolean running = true;</span>

    // Boolean to trigger a forced GC.
<span class="nc" id="L112">    final AtomicBoolean forceGarbageCollection = new AtomicBoolean(false);</span>
    // Boolean to disable major compaction, when disk is almost full
<span class="nc" id="L114">    final AtomicBoolean suspendMajorCompaction = new AtomicBoolean(false);</span>
    // Boolean to disable minor compaction, when disk is full
<span class="nc" id="L116">    final AtomicBoolean suspendMinorCompaction = new AtomicBoolean(false);</span>

    final ScanAndCompareGarbageCollector garbageCollector;
    final GarbageCleaner garbageCleaner;

    final ServerConfiguration conf;
    final LedgerDirsManager ledgerDirsManager;

<span class="nc" id="L124">    private static final AtomicLong threadNum = new AtomicLong(0);</span>
    final AbstractLogCompactor.Throttler throttler;

    /**
     * Create a garbage collector thread.
     *
     * @param conf
     *          Server Configuration Object.
     * @throws IOException
     */
    public GarbageCollectorThread(ServerConfiguration conf, LedgerManager ledgerManager,
                                  final LedgerDirsManager ledgerDirsManager,
                                  final CompactableLedgerStorage ledgerStorage,
                                  EntryLogger entryLogger,
                                  StatsLogger statsLogger) throws IOException {
<span class="nc" id="L139">        this(conf, ledgerManager, ledgerDirsManager, ledgerStorage, entryLogger, statsLogger,</span>
<span class="nc" id="L140">                Executors.newSingleThreadScheduledExecutor(new DefaultThreadFactory(&quot;GarbageCollectorThread&quot;)));</span>
<span class="nc" id="L141">    }</span>

    /**
     * Create a garbage collector thread.
     *
     * @param conf
     *          Server Configuration Object.
     * @throws IOException
     */
    public GarbageCollectorThread(ServerConfiguration conf,
                                  LedgerManager ledgerManager,
                                  final LedgerDirsManager ledgerDirsManager,
                                  final CompactableLedgerStorage ledgerStorage,
                                  EntryLogger entryLogger,
                                  StatsLogger statsLogger,
                                  ScheduledExecutorService gcExecutor)
<span class="nc" id="L157">        throws IOException {</span>
<span class="nc" id="L158">        this.gcExecutor = gcExecutor;</span>
<span class="nc" id="L159">        this.conf = conf;</span>

<span class="nc" id="L161">        this.ledgerDirsManager = ledgerDirsManager;</span>
<span class="nc" id="L162">        this.entryLogger = entryLogger;</span>
<span class="nc" id="L163">        this.entryLogMetaMap = createEntryLogMetadataMap();</span>
<span class="nc" id="L164">        this.ledgerStorage = ledgerStorage;</span>
<span class="nc" id="L165">        this.gcWaitTime = conf.getGcWaitTime();</span>

<span class="nc" id="L167">        this.numActiveEntryLogs = 0;</span>
<span class="nc" id="L168">        this.totalEntryLogSize = 0L;</span>
<span class="nc" id="L169">        this.garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, ledgerStorage, conf, statsLogger);</span>
<span class="nc" id="L170">        this.gcStats = new GarbageCollectorStats(</span>
            statsLogger,
<span class="nc" id="L172">            () -&gt; numActiveEntryLogs,</span>
<span class="nc" id="L173">            () -&gt; totalEntryLogSize,</span>
<span class="nc" id="L174">            () -&gt; garbageCollector.getNumActiveLedgers()</span>
        );

<span class="nc" id="L177">        this.garbageCleaner = ledgerId -&gt; {</span>
            try {
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L180">                    LOG.debug(&quot;delete ledger : &quot; + ledgerId);</span>
                }
<span class="nc" id="L182">                gcStats.getDeletedLedgerCounter().inc();</span>
<span class="nc" id="L183">                ledgerStorage.deleteLedger(ledgerId);</span>
<span class="nc" id="L184">            } catch (IOException e) {</span>
<span class="nc" id="L185">                LOG.error(&quot;Exception when deleting the ledger index file on the Bookie: &quot;, e);</span>
<span class="nc" id="L186">            }</span>
<span class="nc" id="L187">        };</span>

        // compaction parameters
<span class="nc" id="L190">        minorCompactionThreshold = conf.getMinorCompactionThreshold();</span>
<span class="nc" id="L191">        minorCompactionInterval = conf.getMinorCompactionInterval() * SECOND;</span>
<span class="nc" id="L192">        majorCompactionThreshold = conf.getMajorCompactionThreshold();</span>
<span class="nc" id="L193">        majorCompactionInterval = conf.getMajorCompactionInterval() * SECOND;</span>
<span class="nc" id="L194">        isForceGCAllowWhenNoSpace = conf.getIsForceGCAllowWhenNoSpace();</span>
<span class="nc" id="L195">        majorCompactionMaxTimeMillis = conf.getMajorCompactionMaxTimeMillis();</span>
<span class="nc" id="L196">        minorCompactionMaxTimeMillis = conf.getMinorCompactionMaxTimeMillis();</span>

<span class="nc" id="L198">        boolean isForceAllowCompaction = conf.isForceAllowCompaction();</span>

<span class="nc" id="L200">        AbstractLogCompactor.LogRemovalListener remover = new AbstractLogCompactor.LogRemovalListener() {</span>
            @Override
            public void removeEntryLog(long logToRemove) {
                try {
<span class="nc" id="L204">                    GarbageCollectorThread.this.removeEntryLog(logToRemove);</span>
<span class="nc" id="L205">                } catch (EntryLogMetadataMapException e) {</span>
                    // Ignore and continue because ledger will not be cleaned up
                    // from entry-logger in this pass and will be taken care in
                    // next schedule task
<span class="nc" id="L209">                    LOG.warn(&quot;Failed to remove entry-log metadata {}&quot;, logToRemove, e);</span>
<span class="nc" id="L210">                }</span>
<span class="nc" id="L211">            }</span>
        };
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (conf.getUseTransactionalCompaction()) {</span>
<span class="nc" id="L214">            this.compactor = new TransactionalEntryLogCompactor(conf, entryLogger, ledgerStorage, remover);</span>
        } else {
<span class="nc" id="L216">            this.compactor = new EntryLogCompactor(conf, entryLogger, ledgerStorage, remover);</span>
        }

<span class="nc" id="L219">        this.throttler = new AbstractLogCompactor.Throttler(conf);</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">        if (minorCompactionInterval &gt; 0 &amp;&amp; minorCompactionThreshold &gt; 0) {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (minorCompactionThreshold &gt; 1.0d) {</span>
<span class="nc" id="L222">                throw new IOException(&quot;Invalid minor compaction threshold &quot;</span>
                                    + minorCompactionThreshold);
            }
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (minorCompactionInterval &lt; gcWaitTime) {</span>
<span class="nc" id="L226">                throw new IOException(&quot;Too short minor compaction interval : &quot;</span>
                                    + minorCompactionInterval);
            }
<span class="nc" id="L229">            enableMinorCompaction = true;</span>
        }

<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (isForceAllowCompaction) {</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">            if (minorCompactionThreshold &gt; 0 &amp;&amp; minorCompactionThreshold &lt; 1.0d) {</span>
<span class="nc" id="L234">                isForceMinorCompactionAllow = true;</span>
            }
<span class="nc bnc" id="L236" title="All 4 branches missed.">            if (majorCompactionThreshold &gt; 0 &amp;&amp; majorCompactionThreshold &lt; 1.0d) {</span>
<span class="nc" id="L237">                isForceMajorCompactionAllow = true;</span>
            }
        }

<span class="nc bnc" id="L241" title="All 4 branches missed.">        if (majorCompactionInterval &gt; 0 &amp;&amp; majorCompactionThreshold &gt; 0) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (majorCompactionThreshold &gt; 1.0d) {</span>
<span class="nc" id="L243">                throw new IOException(&quot;Invalid major compaction threshold &quot;</span>
                                    + majorCompactionThreshold);
            }
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (majorCompactionInterval &lt; gcWaitTime) {</span>
<span class="nc" id="L247">                throw new IOException(&quot;Too short major compaction interval : &quot;</span>
                                    + majorCompactionInterval);
            }
<span class="nc" id="L250">            enableMajorCompaction = true;</span>
        }

<span class="nc bnc" id="L253" title="All 4 branches missed.">        if (enableMinorCompaction &amp;&amp; enableMajorCompaction) {</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">            if (minorCompactionInterval &gt;= majorCompactionInterval</span>
                || minorCompactionThreshold &gt;= majorCompactionThreshold) {
<span class="nc" id="L256">                throw new IOException(&quot;Invalid minor/major compaction settings : minor (&quot;</span>
                                    + minorCompactionThreshold + &quot;, &quot; + minorCompactionInterval
                                    + &quot;), major (&quot; + majorCompactionThreshold + &quot;, &quot;
                                    + majorCompactionInterval + &quot;)&quot;);
            }
        }

<span class="nc" id="L263">        LOG.info(&quot;Minor Compaction : enabled=&quot; + enableMinorCompaction + &quot;, threshold=&quot;</span>
               + minorCompactionThreshold + &quot;, interval=&quot; + minorCompactionInterval);
<span class="nc" id="L265">        LOG.info(&quot;Major Compaction : enabled=&quot; + enableMajorCompaction + &quot;, threshold=&quot;</span>
               + majorCompactionThreshold + &quot;, interval=&quot; + majorCompactionInterval);

<span class="nc" id="L268">        lastMinorCompactionTime = lastMajorCompactionTime = System.currentTimeMillis();</span>
<span class="nc" id="L269">    }</span>

    private EntryLogMetadataMap createEntryLogMetadataMap() throws IOException {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (conf.isGcEntryLogMetadataCacheEnabled()) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            String baseDir = Strings.isNullOrEmpty(conf.getGcEntryLogMetadataCachePath())</span>
<span class="nc" id="L274">                ? this.ledgerDirsManager.getAllLedgerDirs().get(0).getPath() : conf.getGcEntryLogMetadataCachePath();</span>
            try {
<span class="nc" id="L276">                return new PersistentEntryLogMetadataMap(baseDir, conf);</span>
<span class="nc" id="L277">            } catch (IOException e) {</span>
<span class="nc" id="L278">                LOG.error(&quot;Failed to initialize persistent-metadata-map , clean up {}&quot;,</span>
                    baseDir + &quot;/&quot; + METADATA_CACHE, e);
<span class="nc" id="L280">                throw e;</span>
            }
        } else {
<span class="nc" id="L283">            return new InMemoryEntryLogMetadataMap();</span>
        }
    }

    public void enableForceGC() {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(false, true)) {</span>
<span class="nc" id="L289">            LOG.info(&quot;Forced garbage collection triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
<span class="nc" id="L290">            triggerGC(true, suspendMajorCompaction.get(),</span>
<span class="nc" id="L291">                      suspendMinorCompaction.get());</span>
        }
<span class="nc" id="L293">    }</span>

    public void enableForceGC(Boolean forceMajor, Boolean forceMinor) {
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(false, true)) {</span>
<span class="nc" id="L297">            LOG.info(&quot;Forced garbage collection triggered by thread: {}, forceMajor: {}, forceMinor: {}&quot;,</span>
<span class="nc" id="L298">                Thread.currentThread().getName(), forceMajor, forceMinor);</span>
<span class="nc bnc" id="L299" title="All 4 branches missed.">            triggerGC(true, forceMajor == null ? suspendMajorCompaction.get() : !forceMajor,</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">                forceMinor == null ? suspendMinorCompaction.get() : !forceMinor);</span>
        }
<span class="nc" id="L302">    }</span>

    public void disableForceGC() {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(true, false)) {</span>
<span class="nc" id="L306">            LOG.info(&quot;{} disabled force garbage collection since bookie has enough space now.&quot;, Thread</span>
<span class="nc" id="L307">                    .currentThread().getName());</span>
        }
<span class="nc" id="L309">    }</span>

    Future&lt;?&gt; triggerGC(final boolean force,
                        final boolean suspendMajor,
                        final boolean suspendMinor) {
<span class="nc" id="L314">        return gcExecutor.submit(() -&gt; {</span>
<span class="nc" id="L315">                runWithFlags(force, suspendMajor, suspendMinor);</span>
<span class="nc" id="L316">            });</span>
    }

    Future&lt;?&gt; triggerGC() {
<span class="nc" id="L320">        final boolean force = forceGarbageCollection.get();</span>
<span class="nc" id="L321">        final boolean suspendMajor = suspendMajorCompaction.get();</span>
<span class="nc" id="L322">        final boolean suspendMinor = suspendMinorCompaction.get();</span>

<span class="nc" id="L324">        return gcExecutor.submit(() -&gt; {</span>
<span class="nc" id="L325">                runWithFlags(force, suspendMajor, suspendMinor);</span>
<span class="nc" id="L326">            });</span>
    }

    public boolean isInForceGC() {
<span class="nc" id="L330">        return forceGarbageCollection.get();</span>
    }

    public boolean isMajorGcSuspend() {
<span class="nc" id="L334">        return suspendMajorCompaction.get();</span>
    }

    public boolean isMinorGcSuspend() {
<span class="nc" id="L338">        return suspendMinorCompaction.get();</span>
    }

    public void suspendMajorGC() {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (suspendMajorCompaction.compareAndSet(false, true)) {</span>
<span class="nc" id="L343">            LOG.info(&quot;Suspend Major Compaction triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
        }
<span class="nc" id="L345">    }</span>

    public void resumeMajorGC() {
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (suspendMajorCompaction.compareAndSet(true, false)) {</span>
<span class="nc" id="L349">            LOG.info(&quot;{} Major Compaction back to normal since bookie has enough space now.&quot;,</span>
<span class="nc" id="L350">                    Thread.currentThread().getName());</span>
        }
<span class="nc" id="L352">    }</span>

    public void suspendMinorGC() {
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (suspendMinorCompaction.compareAndSet(false, true)) {</span>
<span class="nc" id="L356">            LOG.info(&quot;Suspend Minor Compaction triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
        }
<span class="nc" id="L358">    }</span>

    public void resumeMinorGC() {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (suspendMinorCompaction.compareAndSet(true, false)) {</span>
<span class="nc" id="L362">            LOG.info(&quot;{} Minor Compaction back to normal since bookie has enough space now.&quot;,</span>
<span class="nc" id="L363">                    Thread.currentThread().getName());</span>
        }
<span class="nc" id="L365">    }</span>

    public void start() {
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (scheduledFuture != null) {</span>
<span class="nc" id="L369">            scheduledFuture.cancel(false);</span>
        }
<span class="nc" id="L371">        long initialDelay = getModInitialDelay();</span>
<span class="nc" id="L372">        scheduledFuture = gcExecutor.scheduleAtFixedRate(this, initialDelay, gcWaitTime, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L373">    }</span>

    /**
     * when number of ledger's Dir are more than 1,the same of GarbageCollectorThread will do the same thing,
     * Especially
     * 1) deleting ledger, then SyncThread will be timed to do rocksDB compact
     * 2) compact: entry, cost cpu.
     * then get Mod initial Delay time to simply avoid GarbageCollectorThread working at the same time
     */
    public long getModInitialDelay() {
<span class="nc" id="L383">        int ledgerDirsNum = conf.getLedgerDirs().length;</span>
<span class="nc" id="L384">        long splitTime = gcWaitTime / ledgerDirsNum;</span>
<span class="nc" id="L385">        long currentThreadNum = threadNum.incrementAndGet();</span>
<span class="nc" id="L386">        return gcWaitTime + currentThreadNum * splitTime;</span>
    }

    @Override
    public void run() {
<span class="nc" id="L391">        boolean force = forceGarbageCollection.get();</span>
<span class="nc" id="L392">        boolean suspendMajor = suspendMajorCompaction.get();</span>
<span class="nc" id="L393">        boolean suspendMinor = suspendMinorCompaction.get();</span>

<span class="nc" id="L395">        runWithFlags(force, suspendMajor, suspendMinor);</span>

<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (force) {</span>
            // only set force to false if it had been true when the garbage
            // collection cycle started
<span class="nc" id="L400">            forceGarbageCollection.set(false);</span>
        }
<span class="nc" id="L402">    }</span>

    public void runWithFlags(boolean force, boolean suspendMajor, boolean suspendMinor) {
<span class="nc" id="L405">        long threadStart = MathUtils.nowInNano();</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (force) {</span>
<span class="nc" id="L407">            LOG.info(&quot;Garbage collector thread forced to perform GC before expiry of wait time.&quot;);</span>
        }
        // Recover and clean up previous state if using transactional compaction
<span class="nc" id="L410">        compactor.cleanUpAndRecover();</span>

        try {
            // gc inactive/deleted ledgers
            // this is used in extractMetaFromEntryLogs to calculate the usage of entry log
<span class="nc" id="L415">            doGcLedgers();</span>

            // Extract all of the ledger ID's that comprise all of the entry logs
            // (except for the current new one which is still being written to).
<span class="nc" id="L419">            extractMetaFromEntryLogs();</span>

            // gc entry logs
<span class="nc" id="L422">            doGcEntryLogs();</span>

<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (suspendMajor) {</span>
<span class="nc" id="L425">                LOG.info(&quot;Disk almost full, suspend major compaction to slow down filling disk.&quot;);</span>
            }
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (suspendMinor) {</span>
<span class="nc" id="L428">                LOG.info(&quot;Disk full, suspend minor compaction to slow down filling disk.&quot;);</span>
            }

<span class="nc" id="L431">            long curTime = System.currentTimeMillis();</span>
<span class="nc bnc" id="L432" title="All 12 branches missed.">            if (((isForceMajorCompactionAllow &amp;&amp; force) || (enableMajorCompaction</span>
                    &amp;&amp; (force || curTime - lastMajorCompactionTime &gt; majorCompactionInterval)))
                    &amp;&amp; (!suspendMajor)) {
                // enter major compaction
<span class="nc" id="L436">                LOG.info(&quot;Enter major compaction, suspendMajor {}&quot;, suspendMajor);</span>
<span class="nc" id="L437">                majorCompacting.set(true);</span>
                try {
<span class="nc" id="L439">                    doCompactEntryLogs(majorCompactionThreshold, majorCompactionMaxTimeMillis);</span>
                } finally {
<span class="nc" id="L441">                    lastMajorCompactionTime = System.currentTimeMillis();</span>
                    // and also move minor compaction time
<span class="nc" id="L443">                    lastMinorCompactionTime = lastMajorCompactionTime;</span>
<span class="nc" id="L444">                    gcStats.getMajorCompactionCounter().inc();</span>
<span class="nc" id="L445">                    majorCompacting.set(false);</span>
<span class="nc" id="L446">                }</span>
<span class="nc bnc" id="L447" title="All 12 branches missed.">            } else if (((isForceMinorCompactionAllow &amp;&amp; force) || (enableMinorCompaction</span>
                    &amp;&amp; (force || curTime - lastMinorCompactionTime &gt; minorCompactionInterval)))
                    &amp;&amp; (!suspendMinor)) {
                // enter minor compaction
<span class="nc" id="L451">                LOG.info(&quot;Enter minor compaction, suspendMinor {}&quot;, suspendMinor);</span>
<span class="nc" id="L452">                minorCompacting.set(true);</span>
                try {
<span class="nc" id="L454">                    doCompactEntryLogs(minorCompactionThreshold, minorCompactionMaxTimeMillis);</span>
                } finally {
<span class="nc" id="L456">                    lastMinorCompactionTime = System.currentTimeMillis();</span>
<span class="nc" id="L457">                    gcStats.getMinorCompactionCounter().inc();</span>
<span class="nc" id="L458">                    minorCompacting.set(false);</span>
                }
            }
<span class="nc" id="L461">            gcStats.getGcThreadRuntime().registerSuccessfulEvent(</span>
<span class="nc" id="L462">                    MathUtils.nowInNano() - threadStart, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L463">        } catch (EntryLogMetadataMapException e) {</span>
<span class="nc" id="L464">            LOG.error(&quot;Error in entryLog-metadatamap, Failed to complete GC/Compaction due to entry-log {}&quot;,</span>
<span class="nc" id="L465">                    e.getMessage(), e);</span>
<span class="nc" id="L466">            gcStats.getGcThreadRuntime().registerFailedEvent(</span>
<span class="nc" id="L467">                    MathUtils.nowInNano() - threadStart, TimeUnit.NANOSECONDS);</span>
        } finally {
<span class="nc bnc" id="L469" title="All 4 branches missed.">            if (force &amp;&amp; forceGarbageCollection.compareAndSet(true, false)) {</span>
<span class="nc" id="L470">                LOG.info(&quot;{} Set forceGarbageCollection to false after force GC to make it forceGC-able again.&quot;,</span>
<span class="nc" id="L471">                        Thread.currentThread().getName());</span>
            }
        }

<span class="nc" id="L475">    }</span>

    /**
     * Do garbage collection ledger index files.
     */
    private void doGcLedgers() {
<span class="nc" id="L481">        garbageCollector.gc(garbageCleaner);</span>
<span class="nc" id="L482">    }</span>

    /**
     * Garbage collect those entry loggers which are not associated with any active ledgers.
     */
    private void doGcEntryLogs() throws EntryLogMetadataMapException {
        // Get a cumulative count, don't update until complete
<span class="nc" id="L489">        AtomicLong totalEntryLogSizeAcc = new AtomicLong(0L);</span>

        // Loop through all of the entry logs and remove the non-active ledgers.
<span class="nc" id="L492">        entryLogMetaMap.forEach((entryLogId, meta) -&gt; {</span>
            try {
<span class="nc" id="L494">                boolean modified = removeIfLedgerNotExists(meta);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">                if (meta.isEmpty()) {</span>
                    // This means the entry log is not associated with any active
                    // ledgers anymore.
                    // We can remove this entry log file now.
<span class="nc" id="L499">                    LOG.info(&quot;Deleting entryLogId {} as it has no active ledgers!&quot;, entryLogId);</span>
<span class="nc" id="L500">                    removeEntryLog(entryLogId);</span>
<span class="nc" id="L501">                    gcStats.getReclaimedSpaceViaDeletes().addCount(meta.getTotalSize());</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                } else if (modified) {</span>
                    // update entryLogMetaMap only when the meta modified.
<span class="nc" id="L504">                    entryLogMetaMap.put(meta.getEntryLogId(), meta);</span>
                }
<span class="nc" id="L506">            } catch (EntryLogMetadataMapException e) {</span>
                // Ignore and continue because ledger will not be cleaned up
                // from entry-logger in this pass and will be taken care in next
                // schedule task
<span class="nc" id="L510">                LOG.warn(&quot;Failed to remove ledger from entry-log metadata {}&quot;, entryLogId, e);</span>
<span class="nc" id="L511">            }</span>
<span class="nc" id="L512">           totalEntryLogSizeAcc.getAndAdd(meta.getRemainingSize());</span>
<span class="nc" id="L513">        });</span>

<span class="nc" id="L515">        this.totalEntryLogSize = totalEntryLogSizeAcc.get();</span>
<span class="nc" id="L516">        this.numActiveEntryLogs = entryLogMetaMap.size();</span>
<span class="nc" id="L517">    }</span>

    private boolean removeIfLedgerNotExists(EntryLogMetadata meta) throws EntryLogMetadataMapException {
<span class="nc" id="L520">        MutableBoolean modified = new MutableBoolean(false);</span>
<span class="nc" id="L521">        meta.removeLedgerIf((entryLogLedger) -&gt; {</span>
            // Remove the entry log ledger from the set if it isn't active.
            try {
<span class="nc" id="L524">                boolean exist = ledgerStorage.ledgerExists(entryLogLedger);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                if (!exist) {</span>
<span class="nc" id="L526">                    modified.setTrue();</span>
                }
<span class="nc bnc" id="L528" title="All 2 branches missed.">                return !exist;</span>
<span class="nc" id="L529">            } catch (IOException e) {</span>
<span class="nc" id="L530">                LOG.error(&quot;Error reading from ledger storage&quot;, e);</span>
<span class="nc" id="L531">                return false;</span>
            }
        });

<span class="nc" id="L535">        return modified.getValue();</span>
    }

    /**
     * Compact entry logs if necessary.
     *
     * &lt;p&gt;
     * Compaction will be executed from low unused space to high unused space.
     * Those entry log files whose remaining size percentage is higher than threshold
     * would not be compacted.
     * &lt;/p&gt;
     */
    @VisibleForTesting
    void doCompactEntryLogs(double threshold, long maxTimeMillis) throws EntryLogMetadataMapException {
<span class="nc" id="L549">        LOG.info(&quot;Do compaction to compact those files lower than {}&quot;, threshold);</span>

<span class="nc" id="L551">        final int numBuckets = 10;</span>
<span class="nc" id="L552">        int[] entryLogUsageBuckets = new int[numBuckets];</span>
<span class="nc" id="L553">        int[] compactedBuckets = new int[numBuckets];</span>

<span class="nc" id="L555">        ArrayList&lt;LinkedList&lt;Long&gt;&gt; compactableBuckets = new ArrayList&lt;&gt;(numBuckets);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        for (int i = 0; i &lt; numBuckets; i++) {</span>
<span class="nc" id="L557">            compactableBuckets.add(new LinkedList&lt;&gt;());</span>
        }

<span class="nc" id="L560">        long start = System.currentTimeMillis();</span>
<span class="nc" id="L561">        MutableLong end = new MutableLong(start);</span>
<span class="nc" id="L562">        MutableLong timeDiff = new MutableLong(0);</span>

<span class="nc" id="L564">        entryLogMetaMap.forEach((entryLogId, meta) -&gt; {</span>
<span class="nc" id="L565">            double usage = meta.getUsage();</span>
<span class="nc bnc" id="L566" title="All 4 branches missed.">            if (conf.isUseTargetEntryLogSizeForGc() &amp;&amp; usage &lt; 1.0d) {</span>
<span class="nc" id="L567">                usage = (double) meta.getRemainingSize() / Math.max(meta.getTotalSize(), conf.getEntryLogSizeLimit());</span>
            }
<span class="nc" id="L569">            int bucketIndex = calculateUsageIndex(numBuckets, usage);</span>
<span class="nc" id="L570">            entryLogUsageBuckets[bucketIndex]++;</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (timeDiff.getValue() &lt; maxTimeMillis) {</span>
<span class="nc" id="L573">                end.setValue(System.currentTimeMillis());</span>
<span class="nc" id="L574">                timeDiff.setValue(end.getValue() - start);</span>
            }
<span class="nc bnc" id="L576" title="All 4 branches missed.">            if ((usage &gt;= threshold</span>
<span class="nc bnc" id="L577" title="All 4 branches missed.">                || (maxTimeMillis &gt; 0 &amp;&amp; timeDiff.getValue() &gt;= maxTimeMillis)</span>
                || !running)) {
                // We allow the usage limit calculation to continue so that we get an accurate
                // report of where the usage was prior to running compaction.
<span class="nc" id="L581">                return;</span>
            }

<span class="nc" id="L584">            compactableBuckets.get(bucketIndex).add(meta.getEntryLogId());</span>
<span class="nc" id="L585">        });</span>

<span class="nc" id="L587">        LOG.info(</span>
                &quot;Compaction: entry log usage buckets before compaction [10% 20% 30% 40% 50% 60% 70% 80% 90% 100%] = {}&quot;,
                entryLogUsageBuckets);

<span class="nc" id="L591">        final int maxBucket = calculateUsageIndex(numBuckets, threshold);</span>
        stopCompaction:
<span class="nc bnc" id="L593" title="All 2 branches missed.">        for (int currBucket = 0; currBucket &lt;= maxBucket; currBucket++) {</span>
<span class="nc" id="L594">            LinkedList&lt;Long&gt; entryLogIds = compactableBuckets.get(currBucket);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            while (!entryLogIds.isEmpty()) {</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                if (timeDiff.getValue() &lt; maxTimeMillis) {</span>
<span class="nc" id="L597">                    end.setValue(System.currentTimeMillis());</span>
<span class="nc" id="L598">                    timeDiff.setValue(end.getValue() - start);</span>
                }

<span class="nc bnc" id="L601" title="All 6 branches missed.">                if ((maxTimeMillis &gt; 0 &amp;&amp; timeDiff.getValue() &gt;= maxTimeMillis) || !running) {</span>
                    // We allow the usage limit calculation to continue so that we get an accurate
                    // report of where the usage was prior to running compaction.
<span class="nc" id="L604">                    break stopCompaction;</span>
                }

<span class="nc" id="L607">                final int bucketIndex = currBucket;</span>
<span class="nc" id="L608">                final long logId = entryLogIds.remove();</span>

<span class="nc" id="L610">                entryLogMetaMap.forKey(logId, (entryLogId, meta) -&gt; {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                    if (meta == null) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L613">                            LOG.debug(&quot;Metadata for entry log {} already deleted&quot;, logId);</span>
                        }
<span class="nc" id="L615">                        return;</span>
                    }
<span class="nc bnc" id="L617" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L618">                        LOG.debug(&quot;Compacting entry log {} with usage {} below threshold {}&quot;,</span>
<span class="nc" id="L619">                                meta.getEntryLogId(), meta.getUsage(), threshold);</span>
                    }

<span class="nc" id="L622">                    long priorRemainingSize = meta.getRemainingSize();</span>
<span class="nc" id="L623">                    compactEntryLog(meta);</span>
<span class="nc" id="L624">                    gcStats.getReclaimedSpaceViaCompaction().addCount(meta.getTotalSize() - priorRemainingSize);</span>
<span class="nc" id="L625">                    compactedBuckets[bucketIndex]++;</span>
<span class="nc" id="L626">                });</span>
<span class="nc" id="L627">            }</span>
        }

<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (!running) {</span>
<span class="nc" id="L632">                LOG.debug(&quot;Compaction exited due to gc not running&quot;);</span>
            }
<span class="nc bnc" id="L634" title="All 4 branches missed.">            if (maxTimeMillis &gt; 0 &amp;&amp; timeDiff.getValue() &gt; maxTimeMillis) {</span>
<span class="nc" id="L635">                LOG.debug(&quot;Compaction ran for {}ms but was limited by {}ms&quot;, timeDiff, maxTimeMillis);</span>
            }
        }
<span class="nc" id="L638">        LOG.info(</span>
                &quot;Compaction: entry log usage buckets[10% 20% 30% 40% 50% 60% 70% 80% 90% 100%] = {}, compacted {}&quot;,
                entryLogUsageBuckets, compactedBuckets);
<span class="nc" id="L641">    }</span>

    /**
     * Calculate the index for the batch based on the usage between 0 and 1.
     *
     * @param numBuckets Number of reporting buckets.
     * @param usage 0.0 - 1.0 value representing the usage of the entry log.
     * @return index based on the number of buckets The last bucket will have the 1.0 if added.
     */
    int calculateUsageIndex(int numBuckets, double usage) {
<span class="nc" id="L651">        return Math.min(</span>
                numBuckets - 1,
<span class="nc" id="L653">                (int) Math.floor(usage * numBuckets));</span>
    }

    /**
     * Shutdown the garbage collector thread.
     *
     * @throws InterruptedException if there is an exception stopping gc thread.
     */
    @SuppressFBWarnings(&quot;SWL_SLEEP_WITH_LOCK_HELD&quot;)
    public synchronized void shutdown() throws InterruptedException {
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (!this.running) {</span>
<span class="nc" id="L664">            return;</span>
        }
<span class="nc" id="L666">        LOG.info(&quot;Shutting down GarbageCollectorThread&quot;);</span>

<span class="nc" id="L668">        throttler.cancelledAcquire();</span>
<span class="nc" id="L669">        compactor.throttler.cancelledAcquire();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        while (!compacting.compareAndSet(false, true)) {</span>
            // Wait till the thread stops compacting
<span class="nc" id="L672">            Thread.sleep(100);</span>
        }

<span class="nc" id="L675">        this.running = false;</span>
        // Interrupt GC executor thread
<span class="nc" id="L677">        gcExecutor.shutdownNow();</span>
        try {
<span class="nc" id="L679">            entryLogMetaMap.close();</span>
<span class="nc" id="L680">        } catch (Exception e) {</span>
<span class="nc" id="L681">            LOG.warn(&quot;Failed to close entryLog metadata-map&quot;, e);</span>
<span class="nc" id="L682">        }</span>
<span class="nc" id="L683">    }</span>

    /**
     * Remove entry log.
     *
     * @param entryLogId
     *          Entry Log File Id
     * @throws EntryLogMetadataMapException
     */
    protected void removeEntryLog(long entryLogId) throws EntryLogMetadataMapException {
        // remove entry log file successfully
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (entryLogger.removeEntryLog(entryLogId)) {</span>
<span class="nc" id="L695">            LOG.info(&quot;Removing entry log metadata for {}&quot;, entryLogId);</span>
<span class="nc" id="L696">            entryLogMetaMap.remove(entryLogId);</span>
        }
<span class="nc" id="L698">    }</span>

    /**
     * Compact an entry log.
     *
     * @param entryLogMeta
     */
    protected void compactEntryLog(EntryLogMetadata entryLogMeta) {
        // Similar with Sync Thread
        // try to mark compacting flag to make sure it would not be interrupted
        // by shutdown during compaction. otherwise it will receive
        // ClosedByInterruptException which may cause index file &amp; entry logger
        // closed and corrupted.
<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (!compacting.compareAndSet(false, true)) {</span>
            // set compacting flag failed, means compacting is true now
            // indicates that compaction is in progress for this EntryLogId.
<span class="nc" id="L714">            return;</span>
        }

        try {
            // Do the actual compaction
<span class="nc" id="L719">            compactor.compact(entryLogMeta);</span>
<span class="nc" id="L720">        } catch (Exception e) {</span>
<span class="nc" id="L721">            LOG.error(&quot;Failed to compact entry log {} due to unexpected error&quot;, entryLogMeta.getEntryLogId(), e);</span>
        } finally {
            // Mark compaction done
<span class="nc" id="L724">            compacting.set(false);</span>
        }
<span class="nc" id="L726">    }</span>

    /**
     * Method to read in all of the entry logs (those that we haven't done so yet),
     * and find the set of ledger ID's that make up each entry log file.
     *
     * @throws EntryLogMetadataMapException
     */
    protected void extractMetaFromEntryLogs() throws EntryLogMetadataMapException {
<span class="nc bnc" id="L735" title="All 2 branches missed.">        for (long entryLogId : entryLogger.getFlushedLogIds()) {</span>
            // Comb the current entry log file if it has not already been extracted.
<span class="nc bnc" id="L737" title="All 2 branches missed.">            if (entryLogMetaMap.containsKey(entryLogId)) {</span>
<span class="nc" id="L738">                continue;</span>
            }

            // check whether log file exists or not
            // if it doesn't exist, this log file might have been garbage collected.
<span class="nc bnc" id="L743" title="All 2 branches missed.">            if (!entryLogger.logExists(entryLogId)) {</span>
<span class="nc" id="L744">                continue;</span>
            }

<span class="nc" id="L747">            LOG.info(&quot;Extracting entry log meta from entryLogId: {}&quot;, entryLogId);</span>

            try {
                // Read through the entry log file and extract the entry log meta
<span class="nc" id="L751">                EntryLogMetadata entryLogMeta = entryLogger.getEntryLogMetadata(entryLogId, throttler);</span>
<span class="nc" id="L752">                removeIfLedgerNotExists(entryLogMeta);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if (entryLogMeta.isEmpty()) {</span>
<span class="nc" id="L754">                    LOG.info(&quot;Entry log file {} is empty, delete it from disk.&quot;, Long.toHexString(entryLogId));</span>
<span class="nc" id="L755">                    entryLogger.removeEntryLog(entryLogId);</span>
                    // remove it from entrylogmetadata-map if it is present in
                    // the map
<span class="nc" id="L758">                    entryLogMetaMap.remove(entryLogId);</span>
                } else {
<span class="nc" id="L760">                    entryLogMetaMap.put(entryLogId, entryLogMeta);</span>
                }
<span class="nc" id="L762">            } catch (IOException e) {</span>
<span class="nc" id="L763">                LOG.warn(&quot;Premature exception when processing &quot; + entryLogId</span>
                         + &quot; recovery will take care of the problem&quot;, e);
<span class="nc" id="L765">            }</span>
<span class="nc" id="L766">        }</span>
<span class="nc" id="L767">    }</span>

    CompactableLedgerStorage getLedgerStorage() {
<span class="nc" id="L770">        return ledgerStorage;</span>
    }

    @VisibleForTesting
    EntryLogMetadataMap getEntryLogMetaMap() {
<span class="nc" id="L775">        return entryLogMetaMap;</span>
    }

    public GarbageCollectionStatus getGarbageCollectionStatus() {
<span class="nc" id="L779">        return GarbageCollectionStatus.builder()</span>
<span class="nc" id="L780">            .forceCompacting(forceGarbageCollection.get())</span>
<span class="nc" id="L781">            .majorCompacting(majorCompacting.get())</span>
<span class="nc" id="L782">            .minorCompacting(minorCompacting.get())</span>
<span class="nc" id="L783">            .lastMajorCompactionTime(lastMajorCompactionTime)</span>
<span class="nc" id="L784">            .lastMinorCompactionTime(lastMinorCompactionTime)</span>
<span class="nc" id="L785">            .majorCompactionCounter(gcStats.getMajorCompactionCounter().get())</span>
<span class="nc" id="L786">            .minorCompactionCounter(gcStats.getMinorCompactionCounter().get())</span>
<span class="nc" id="L787">            .build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>