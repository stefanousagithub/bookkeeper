<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteBufList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.util</a> &gt; <span class="el_source">ByteBufList.java</span></div><h1>ByteBufList.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.util;

import com.google.common.annotations.VisibleForTesting;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.CompositeByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.util.AbstractReferenceCounted;
import io.netty.util.Recycler;
import io.netty.util.Recycler.Handle;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.ReferenceCounted;
import java.util.ArrayList;

/**
 * ByteBufList is a holder of a sequence of {@link ByteBuf} objects.
 *
 * &lt;p&gt;This class doesn't trying to mimic the {@link ByteBuf}, but rather exposes itself just like a regular object which
 * will need to be encoded on the channel. There are 2 utility encoders:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #ENCODER}: regular encode that will write all the buffers in the {@link ByteBufList} on the channel&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Example:
 *
 * &lt;pre&gt;
 * bootstrap.handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
 *     public void initChannel(SocketChannel ch) throws Exception {
 *         ChannelPipeline pipeline = ch.pipeline();
 *         pipeline.addLast(&quot;bytebufList&quot;, ByteBufList.ENCODER);
 *         pipeline.addLast(&quot;mainhandler&quot;, MyHandler.class);
 *     }
 * });
 * &lt;/pre&gt;
 *
 * &lt;p&gt;ByteBufList is pooling the instances and uses ref-counting to release them.
 */
public class ByteBufList extends AbstractReferenceCounted {
    private final ArrayList&lt;ByteBuf&gt; buffers;
    private final Handle&lt;ByteBufList&gt; recyclerHandle;

    private static final int INITIAL_LIST_SIZE = 4;

<span class="nc" id="L67">    private static final Recycler&lt;ByteBufList&gt; RECYCLER = new Recycler&lt;ByteBufList&gt;() {</span>
        @Override
        protected ByteBufList newObject(Recycler.Handle&lt;ByteBufList&gt; handle) {
<span class="nc" id="L70">            return new ByteBufList(handle);</span>
        }
    };

<span class="nc" id="L74">    private ByteBufList(Handle&lt;ByteBufList&gt; recyclerHandle) {</span>
<span class="nc" id="L75">        this.recyclerHandle = recyclerHandle;</span>
<span class="nc" id="L76">        this.buffers = new ArrayList&lt;&gt;(INITIAL_LIST_SIZE);</span>
<span class="nc" id="L77">    }</span>

    /**
     * Get a new {@link ByteBufList} from the pool and assign 2 buffers to it.
     *
     * &lt;p&gt;The buffers b1 and b2 lifecycles are now managed by the ByteBufList: when the {@link ByteBufList} is
     * deallocated, b1 and b2 will be released as well.
     *
     * @param b1
     *            first buffer
     * @param b2
     *            second buffer
     * @return a {@link ByteBufList} instance from the pool
     */
    public static ByteBufList get(ByteBuf b1, ByteBuf b2) {
<span class="nc" id="L92">        ByteBufList buf = get();</span>
<span class="nc" id="L93">        buf.add(b1);</span>
<span class="nc" id="L94">        buf.add(b2);</span>
<span class="nc" id="L95">        return buf;</span>
    }

    /**
     * Get a new {@link ByteBufList} from the pool and assign 1 buffer to it.
     *
     * &lt;p&gt;The buffer b1 lifecycle is now managed by the ByteBufList: when the {@link ByteBufList} is
     * deallocated, b1 will be released as well.
     *
     * @param b1
     *            first buffer
     * @return a {@link ByteBufList} instance from the pool
     */
    public static ByteBufList get(ByteBuf b1) {
<span class="nc" id="L109">        ByteBufList buf = get();</span>
<span class="nc" id="L110">        buf.add(b1);</span>
<span class="nc" id="L111">        return buf;</span>
    }

    /**
     * Get a new {@link ByteBufList} instance from the pool that is the clone of an already existing instance.
     */
    public static ByteBufList clone(ByteBufList other) {
<span class="nc" id="L118">        ByteBufList buf = get();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        for (int i = 0; i &lt; other.buffers.size(); i++) {</span>
            // Create a duplicate of the buffer so that there is no interference from other threads
<span class="nc" id="L121">            buf.add(other.buffers.get(i).retainedDuplicate());</span>
        }
<span class="nc" id="L123">        return buf;</span>
    }

    private static ByteBufList get() {
<span class="nc" id="L127">        ByteBufList buf = RECYCLER.get();</span>
<span class="nc" id="L128">        buf.setRefCnt(1);</span>
<span class="nc" id="L129">        return buf;</span>
    }

    /**
     * Append a {@link ByteBuf} at the end of this {@link ByteBufList}.
     */
    public void add(ByteBuf buf) {
<span class="nc bnc" id="L136" title="All 4 branches missed.">        final ByteBuf unwrapped = buf.unwrap() != null &amp;&amp; buf.unwrap() instanceof CompositeByteBuf</span>
<span class="nc" id="L137">                ? buf.unwrap() : buf;</span>
<span class="nc" id="L138">        ReferenceCountUtil.retain(unwrapped);</span>
<span class="nc" id="L139">        ReferenceCountUtil.release(buf);</span>

<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (unwrapped instanceof CompositeByteBuf) {</span>
<span class="nc" id="L142">            ((CompositeByteBuf) unwrapped).forEach(b -&gt; {</span>
<span class="nc" id="L143">                ReferenceCountUtil.retain(b);</span>
<span class="nc" id="L144">                buffers.add(b);</span>
<span class="nc" id="L145">            });</span>
<span class="nc" id="L146">            ReferenceCountUtil.release(unwrapped);</span>
        } else {
<span class="nc" id="L148">            buffers.add(unwrapped);</span>
        }
<span class="nc" id="L150">    }</span>

    /**
     * Prepend a {@link ByteBuf} at the beginning of this {@link ByteBufList}.
     */
    public void prepend(ByteBuf buf) {
        // don't unwrap slices
<span class="nc bnc" id="L157" title="All 4 branches missed.">        final ByteBuf unwrapped = buf.unwrap() != null &amp;&amp; buf.unwrap() instanceof CompositeByteBuf</span>
<span class="nc" id="L158">                ? buf.unwrap() : buf;</span>
<span class="nc" id="L159">        ReferenceCountUtil.retain(unwrapped);</span>
<span class="nc" id="L160">        ReferenceCountUtil.release(buf);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (unwrapped instanceof CompositeByteBuf) {</span>
<span class="nc" id="L163">            CompositeByteBuf composite = (CompositeByteBuf) unwrapped;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">            for (int i = composite.numComponents() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L165">                ByteBuf b = composite.component(i);</span>
<span class="nc" id="L166">                ReferenceCountUtil.retain(b);</span>
<span class="nc" id="L167">                buffers.add(0, b);</span>
            }
<span class="nc" id="L169">            ReferenceCountUtil.release(unwrapped);</span>
<span class="nc" id="L170">        } else {</span>
<span class="nc" id="L171">            buffers.add(0, unwrapped);</span>
        }
<span class="nc" id="L173">    }</span>

    /**
     * @return the total amount of readable bytes across all the {@link ByteBuf} included in the list
     */
    public int readableBytes() {
<span class="nc" id="L179">        int readableBytes = 0;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (int i = 0; i &lt; buffers.size(); i++) {</span>
<span class="nc" id="L181">            readableBytes += buffers.get(i).readableBytes();</span>
        }
<span class="nc" id="L183">        return readableBytes;</span>
    }

    /**
     * Get access to a particular buffer in the list.
     *
     * @param index
     *            the index of the buffer
     * @return the buffer
     */
    public ByteBuf getBuffer(int index) {
<span class="nc" id="L194">        return buffers.get(index);</span>
    }

    /**
     * @return the number of buffers included in the {@link ByteBufList}
     */
    public int size() {
<span class="nc" id="L201">        return buffers.size();</span>
    }

    /**
     * Write bytes from the current {@link ByteBufList} into a byte array.
     *
     * &lt;p&gt;This won't modify the reader index of the internal buffers.
     *
     * @param dst
     *            the destination byte array
     * @return the number of copied bytes
     */
    public int getBytes(byte[] dst) {
<span class="nc" id="L214">        int copied = 0;</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">        for (int idx = 0; idx &lt; buffers.size() &amp;&amp; copied &lt; dst.length; idx++) {</span>
<span class="nc" id="L216">            ByteBuf b = buffers.get(idx);</span>
<span class="nc" id="L217">            int len = Math.min(b.readableBytes(), dst.length - copied);</span>
<span class="nc" id="L218">            b.getBytes(b.readerIndex(), dst, copied, len);</span>

<span class="nc" id="L220">            copied += len;</span>
        }

<span class="nc" id="L223">        return copied;</span>
    }

    /**
     * Creates a copy of the readable content of the internal buffers and returns the copy.
     * @return an array containing all the internal buffers content
     */
    public byte[] toArray() {
<span class="nc" id="L231">        byte[] a = new byte[readableBytes()];</span>
<span class="nc" id="L232">        getBytes(a);</span>
<span class="nc" id="L233">        return a;</span>
    }

    /**
     * Returns {@code true} if this buffer has a single backing byte array.
     * If this method returns true, you can safely call {@link #array()} and
     * {@link #arrayOffset()}.
     * @return true, if this {@link ByteBufList} is backed by a single array
     */
    public boolean hasArray() {
<span class="nc bnc" id="L243" title="All 4 branches missed.">        return buffers.size() == 1 &amp;&amp; buffers.get(0).hasArray();</span>
    }

    /**
     * Returns a reference to the array backing this {@link ByteBufList}.
     * This method must only be called if {@link #hasArray()} returns {@code true}.
     * @return the array backing this {@link ByteBufList}
     */
    public byte[] array() {
<span class="nc" id="L252">        return buffers.get(0).array();</span>
    }

    /**
     * Returns the offset of the first byte within the backing byte array of
     * this buffer.
     * This method must only be called if {@link #hasArray()} returns {@code true}.
     * @return the offset of the first byte within the backing byte array.
     */
    public int arrayOffset() {
<span class="nc" id="L262">        return buffers.get(0).arrayOffset();</span>
    }

    /**
     * @return a single buffer with the content of both individual buffers
     */
    @VisibleForTesting
    public static ByteBuf coalesce(ByteBufList list) {
<span class="nc" id="L270">        ByteBuf res = Unpooled.buffer(list.readableBytes());</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        for (int i = 0; i &lt; list.buffers.size(); i++) {</span>
<span class="nc" id="L272">            ByteBuf b = list.buffers.get(i);</span>
<span class="nc" id="L273">            res.writeBytes(b, b.readerIndex(), b.readableBytes());</span>
        }

<span class="nc" id="L276">        return res;</span>
    }

    @Override
    public ByteBufList retain() {
<span class="nc" id="L281">        super.retain();</span>
<span class="nc" id="L282">        return this;</span>
    }

    @Override
    protected void deallocate() {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        for (int i = 0; i &lt; buffers.size(); i++) {</span>
<span class="nc" id="L288">            ReferenceCountUtil.release(buffers.get(i));</span>
        }

<span class="nc" id="L291">        buffers.clear();</span>
<span class="nc" id="L292">        recyclerHandle.recycle(this);</span>
<span class="nc" id="L293">    }</span>

    @Override
    public ReferenceCounted touch(Object hint) {
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for (int i = 0; i &lt; buffers.size(); i++) {</span>
<span class="nc" id="L298">            buffers.get(i).touch(hint);</span>
        }
<span class="nc" id="L300">        return this;</span>
    }

    /**
     * Encoder for the {@link ByteBufList} that doesn't prepend any size header.
     */
<span class="nc" id="L306">    public static final Encoder ENCODER = new Encoder();</span>

    /**
     * {@link ByteBufList} encoder.
     */
    @Sharable
<span class="nc" id="L312">    public static class Encoder extends ChannelOutboundHandlerAdapter {</span>

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (msg instanceof ByteBufList) {</span>
<span class="nc" id="L317">                ByteBufList b = (ByteBufList) msg;</span>

                try {
                    // Write each buffer individually on the socket. The retain() here is needed to preserve the fact
                    // that ByteBuf are automatically released after a write. If the ByteBufPair ref count is increased
                    // and it gets written multiple times, the individual buffers refcount should be reflected as well.
<span class="nc" id="L323">                    int buffersCount = b.buffers.size();</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">                    for (int i = 0; i &lt; buffersCount; i++) {</span>
<span class="nc" id="L325">                        ByteBuf bx = b.buffers.get(i);</span>
                        // Last buffer will carry on the final promise to notify when everything was written on the
                        // socket
<span class="nc bnc" id="L328" title="All 2 branches missed.">                        ctx.write(bx.retainedDuplicate(), i == (buffersCount - 1) ? promise : ctx.voidPromise());</span>
                    }
                } finally {
<span class="nc" id="L331">                    ReferenceCountUtil.release(b);</span>
                }
<span class="nc" id="L333">            } else {</span>
<span class="nc" id="L334">                ctx.write(msg, promise);</span>
            }
<span class="nc" id="L336">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>