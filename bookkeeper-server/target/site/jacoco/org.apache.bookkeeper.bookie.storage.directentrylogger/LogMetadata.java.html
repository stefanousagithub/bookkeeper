<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogMetadata.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie.storage.directentrylogger</a> &gt; <span class="el_source">LogMetadata.java</span></div><h1>LogMetadata.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.bookie.storage.directentrylogger;

import static org.apache.bookkeeper.common.util.ExceptionMessageHelper.exMsg;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.util.ReferenceCountUtil;
import java.io.IOException;
import org.apache.bookkeeper.bookie.EntryLogMetadata;
import org.apache.bookkeeper.util.collections.ConcurrentLongLongHashMap;
import org.apache.bookkeeper.util.collections.ConcurrentLongLongHashMap.BiConsumerLong;

<span class="nc" id="L33">class LogMetadata {</span>

    /**
     * Ledgers map is composed of multiple parts that can be split into separated entries. Each of them is composed of:
     *
     * &lt;pre&gt;
     * length: (4 bytes) [0-3]
     * ledger id (-1): (8 bytes) [4 - 11]
     * entry id: (8 bytes) [12-19]
     * num ledgers stored in current metadata entry: (4 bytes) [20 - 23]
     * ledger entries: sequence of (ledgerid, size) (8 + 8 bytes each) [24..]
     * &lt;/pre&gt;
     */
    static final int LEDGERS_MAP_HEADER_SIZE = 4 + 8 + 8 + 4;
    static final int LEDGERS_MAP_ENTRY_SIZE = 8 + 8;

    // Break the ledgers map into multiple batches, each of which can contain up to 10K ledgers
    static final int LEDGERS_MAP_MAX_BATCH_SIZE = 10000;
    static final int LEDGERS_MAP_MAX_MAP_SIZE =
        LEDGERS_MAP_HEADER_SIZE + LEDGERS_MAP_ENTRY_SIZE * LEDGERS_MAP_MAX_BATCH_SIZE;

    static final long INVALID_LID = -1L;
    // EntryId used to mark an entry (belonging to INVALID_ID)
    // as a component of the serialized ledgers map
    static final long LEDGERS_MAP_ENTRY_ID = -2L;

    static void write(LogWriter writer,
                      EntryLogMetadata metadata,
                      ByteBufAllocator allocator)
            throws IOException {
<span class="nc" id="L63">        long ledgerMapOffset = writer.position();</span>
<span class="nc" id="L64">        ConcurrentLongLongHashMap ledgersMap = metadata.getLedgersMap();</span>
<span class="nc" id="L65">        int numberOfLedgers = (int) ledgersMap.size();</span>

        // Write the ledgers map into several batches
<span class="nc" id="L68">        final ByteBuf serializedMap = allocator.buffer(LEDGERS_MAP_MAX_BATCH_SIZE);</span>
<span class="nc" id="L69">        BiConsumerLong writingConsumer = new BiConsumerLong() {</span>
<span class="nc" id="L70">                int remainingLedgers = numberOfLedgers;</span>
<span class="nc" id="L71">                boolean startNewBatch = true;</span>
<span class="nc" id="L72">                int remainingInBatch = 0;</span>

                @Override
                public void accept(long ledgerId, long size) {
<span class="nc bnc" id="L76" title="All 2 branches missed.">                    if (startNewBatch) {</span>
<span class="nc" id="L77">                        int batchSize = Math.min(remainingLedgers, LEDGERS_MAP_MAX_BATCH_SIZE);</span>
<span class="nc" id="L78">                        serializedMap.clear();</span>
<span class="nc" id="L79">                        serializedMap.writeLong(INVALID_LID);</span>
<span class="nc" id="L80">                        serializedMap.writeLong(LEDGERS_MAP_ENTRY_ID);</span>
<span class="nc" id="L81">                        serializedMap.writeInt(batchSize);</span>

<span class="nc" id="L83">                        startNewBatch = false;</span>
<span class="nc" id="L84">                        remainingInBatch = batchSize;</span>
                    }
                    // Dump the ledger in the current batch
<span class="nc" id="L87">                    serializedMap.writeLong(ledgerId);</span>
<span class="nc" id="L88">                    serializedMap.writeLong(size);</span>
<span class="nc" id="L89">                    --remainingLedgers;</span>

<span class="nc bnc" id="L91" title="All 2 branches missed.">                    if (--remainingInBatch == 0) {</span>
                        // Close current batch
                        try {
<span class="nc" id="L94">                            writer.writeDelimited(serializedMap);</span>
<span class="nc" id="L95">                        } catch (IOException e) {</span>
<span class="nc" id="L96">                            throw new RuntimeException(e);</span>
<span class="nc" id="L97">                        }</span>
<span class="nc" id="L98">                        startNewBatch = true;</span>
                    }
<span class="nc" id="L100">                }</span>
            };
        try {
<span class="nc" id="L103">            ledgersMap.forEach(writingConsumer);</span>
<span class="nc" id="L104">        } catch (RuntimeException e) {</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (e.getCause() instanceof IOException) {</span>
<span class="nc" id="L106">                throw (IOException) e.getCause();</span>
            } else {
<span class="nc" id="L108">                throw e;</span>
            }
        } finally {
<span class="nc" id="L111">            ReferenceCountUtil.release(serializedMap);</span>
        }
<span class="nc" id="L113">        ByteBuf buf = allocator.buffer(Buffer.ALIGNMENT);</span>
        try {
<span class="nc" id="L115">            Header.writeHeader(buf, ledgerMapOffset, numberOfLedgers);</span>
<span class="nc" id="L116">            writer.writeAt(0, buf);</span>
        } finally {
<span class="nc" id="L118">            ReferenceCountUtil.release(buf);</span>
        }
<span class="nc" id="L120">        writer.flush();</span>
<span class="nc" id="L121">    }</span>

    static EntryLogMetadata read(LogReader reader) throws IOException {
<span class="nc" id="L124">        ByteBuf header = reader.readBufferAt(0, Header.LOGFILE_LEGACY_HEADER_SIZE);</span>
        try {
<span class="nc" id="L126">            int headerVersion = Header.extractVersion(header);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            if (headerVersion &lt; Header.HEADER_V1) {</span>
<span class="nc" id="L128">                throw new IOException(exMsg(&quot;Old log file header&quot;).kv(&quot;headerVersion&quot;, headerVersion).toString());</span>
            }
<span class="nc" id="L130">            long ledgerMapOffset = Header.extractLedgerMapOffset(header);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if (ledgerMapOffset &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L132">                throw new IOException(exMsg(&quot;ledgerMapOffset too high&quot;).kv(&quot;ledgerMapOffset&quot;, ledgerMapOffset)</span>
<span class="nc" id="L133">                                      .kv(&quot;maxOffset&quot;, Integer.MAX_VALUE).toString());</span>
            }
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if (ledgerMapOffset &lt;= 0) {</span>
<span class="nc" id="L136">                throw new IOException(exMsg(&quot;ledgerMap never written&quot;).kv(&quot;ledgerMapOffset&quot;, ledgerMapOffset)</span>
<span class="nc" id="L137">                                      .toString());</span>
            }

<span class="nc" id="L140">            long offset = ledgerMapOffset;</span>
<span class="nc" id="L141">            EntryLogMetadata meta = new EntryLogMetadata(reader.logId());</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">            while (offset &lt; reader.maxOffset()) {</span>
<span class="nc" id="L143">                int mapSize = reader.readIntAt((int) offset);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                if (mapSize &gt;= LogMetadata.LEDGERS_MAP_MAX_MAP_SIZE) {</span>
<span class="nc" id="L145">                    throw new IOException(exMsg(&quot;ledgerMap too large&quot;)</span>
<span class="nc" id="L146">                                          .kv(&quot;maxSize&quot;, LogMetadata.LEDGERS_MAP_MAX_MAP_SIZE)</span>
<span class="nc" id="L147">                                          .kv(&quot;mapSize&quot;, mapSize).toString());</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                } else if (mapSize &lt;= 0) {</span>
<span class="nc" id="L149">                    break;</span>
                }
<span class="nc" id="L151">                offset += Integer.BYTES;</span>

<span class="nc" id="L153">                ByteBuf ledgerMapBuffer = reader.readBufferAt(offset, mapSize);</span>
                try {
<span class="nc" id="L155">                    offset += mapSize;</span>

<span class="nc" id="L157">                    long ledgerId = ledgerMapBuffer.readLong();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">                    if (ledgerId != LogMetadata.INVALID_LID) {</span>
<span class="nc" id="L159">                        throw new IOException(exMsg(&quot;Bad ledgerID&quot;).kv(&quot;ledgerId&quot;, ledgerId).toString());</span>
                    }
<span class="nc" id="L161">                    long entryId = ledgerMapBuffer.readLong();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (entryId != LogMetadata.LEDGERS_MAP_ENTRY_ID) {</span>
<span class="nc" id="L163">                        throw new IOException(exMsg(&quot;Unexpected entry ID. Expected special value&quot;)</span>
<span class="nc" id="L164">                                              .kv(&quot;entryIdRead&quot;, entryId)</span>
<span class="nc" id="L165">                                              .kv(&quot;entryIdExpected&quot;, LogMetadata.LEDGERS_MAP_ENTRY_ID).toString());</span>
                    }
<span class="nc" id="L167">                    int countInBatch = ledgerMapBuffer.readInt();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                    for (int i = 0; i &lt; countInBatch; i++) {</span>
<span class="nc" id="L169">                        ledgerId = ledgerMapBuffer.readLong();</span>
<span class="nc" id="L170">                        long size = ledgerMapBuffer.readLong();</span>
<span class="nc" id="L171">                        meta.addLedgerSize(ledgerId, size);</span>
                    }
<span class="nc bnc" id="L173" title="All 2 branches missed.">                    if (ledgerMapBuffer.isReadable()) {</span>
<span class="nc" id="L174">                        throw new IOException(exMsg(&quot;ledgerMapSize didn't match content&quot;)</span>
<span class="nc" id="L175">                                              .kv(&quot;expectedCount&quot;, countInBatch)</span>
<span class="nc" id="L176">                                              .kv(&quot;bufferSize&quot;, mapSize)</span>
<span class="nc" id="L177">                                              .kv(&quot;bytesRemaining&quot;, ledgerMapBuffer.readableBytes())</span>
<span class="nc" id="L178">                                              .toString());</span>
                    }
                } finally {
<span class="nc" id="L181">                    ReferenceCountUtil.release(ledgerMapBuffer);</span>
                }
<span class="nc" id="L183">            }</span>
<span class="nc" id="L184">            return meta;</span>
<span class="nc" id="L185">        } catch (IOException ioe) {</span>
<span class="nc" id="L186">            throw new IOException(exMsg(&quot;Error reading index&quot;).kv(&quot;logId&quot;, reader.logId())</span>
<span class="nc" id="L187">                                  .kv(&quot;reason&quot;, ioe.getMessage()).toString(), ioe);</span>
        } finally {
<span class="nc" id="L189">            ReferenceCountUtil.release(header);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>