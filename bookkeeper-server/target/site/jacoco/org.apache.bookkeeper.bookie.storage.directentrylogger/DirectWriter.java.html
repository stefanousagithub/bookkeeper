<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirectWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie.storage.directentrylogger</a> &gt; <span class="el_source">DirectWriter.java</span></div><h1>DirectWriter.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.bookie.storage.directentrylogger;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static org.apache.bookkeeper.common.util.ExceptionMessageHelper.exMsg;

import io.netty.buffer.ByteBuf;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import org.apache.bookkeeper.common.util.nativeio.NativeIO;
import org.apache.bookkeeper.common.util.nativeio.NativeIOException;
import org.apache.bookkeeper.slogger.Slogger;
import org.apache.commons.lang3.SystemUtils;

class DirectWriter implements LogWriter {
    final NativeIO nativeIO;
    final int fd;
    final int id;
    final String filename;
    final BufferPool bufferPool;
    final ExecutorService writeExecutor;
<span class="nc" id="L46">    final Object bufferLock = new Object();</span>
<span class="nc" id="L47">    final List&lt;Future&lt;?&gt;&gt; outstandingWrites = new ArrayList&lt;Future&lt;?&gt;&gt;();</span>
    Buffer nativeBuffer;
    long offset;
<span class="nc" id="L50">    private static volatile boolean useFallocate = true;</span>

    DirectWriter(int id,
                 String filename,
                 long maxFileSize,
                 ExecutorService writeExecutor,
                 BufferPool bufferPool,
<span class="nc" id="L57">                 NativeIO nativeIO, Slogger slog) throws IOException {</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        checkArgument(maxFileSize &gt; 0, &quot;Max file size (%d) must be positive&quot;);</span>
<span class="nc" id="L59">        this.id = id;</span>
<span class="nc" id="L60">        this.filename = filename;</span>
<span class="nc" id="L61">        this.writeExecutor = writeExecutor;</span>
<span class="nc" id="L62">        this.nativeIO = nativeIO;</span>

<span class="nc" id="L64">        offset = 0;</span>

        try {
<span class="nc" id="L67">            fd = nativeIO.open(filename,</span>
                               NativeIO.O_CREAT | NativeIO.O_WRONLY | NativeIO.O_DIRECT,
                               00644);
<span class="nc bnc" id="L70" title="All 2 branches missed.">            checkState(fd &gt;= 0, &quot;Open should have thrown exception, fd is invalid : %d&quot;, fd);</span>
<span class="nc" id="L71">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L72">            throw new IOException(exMsg(ne.getMessage()).kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L73">                                  .kv(&quot;errno&quot;, ne.getErrno()).toString(), ne);</span>
<span class="nc" id="L74">        }</span>

<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (useFallocate) {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">            if (!SystemUtils.IS_OS_LINUX) {</span>
<span class="nc" id="L78">                disableUseFallocate();</span>
<span class="nc" id="L79">                slog.warn(Events.FALLOCATE_NOT_AVAILABLE);</span>
            } else {
                try {
<span class="nc" id="L82">                    int ret = nativeIO.fallocate(fd, NativeIO.FALLOC_FL_ZERO_RANGE, 0, maxFileSize);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">                    checkState(ret == 0, &quot;Exception should have been thrown on non-zero ret: %d&quot;, ret);</span>
<span class="nc" id="L84">                } catch (NativeIOException ex) {</span>
                    // fallocate(2) is not supported on all filesystems.  Since this is an optimization, disable
                    // subsequent usage instead of failing the operation.
<span class="nc" id="L87">                    disableUseFallocate();</span>
<span class="nc" id="L88">                    slog.kv(&quot;message&quot;, ex.getMessage())</span>
<span class="nc" id="L89">                        .kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L90">                        .kv(&quot;errno&quot;, ex.getErrno())</span>
<span class="nc" id="L91">                        .warn(Events.FALLOCATE_NOT_AVAILABLE);</span>
<span class="nc" id="L92">                }</span>
            }
        }

<span class="nc" id="L96">        this.bufferPool = bufferPool;</span>
<span class="nc" id="L97">        this.nativeBuffer = bufferPool.acquire();</span>
<span class="nc" id="L98">    }</span>

    private static void disableUseFallocate() {
<span class="nc" id="L101">        DirectWriter.useFallocate = false;</span>
<span class="nc" id="L102">    }</span>

    @Override
    public int logId() {
<span class="nc" id="L106">        return id;</span>
    }

    @Override
    public void writeAt(long offset, ByteBuf buf) throws IOException {
<span class="nc" id="L111">        checkArgument(Buffer.isAligned(offset),</span>
                      &quot;Offset to writeAt must be aligned to %d: %d is not&quot;, Buffer.ALIGNMENT, offset);
<span class="nc" id="L113">        checkArgument(Buffer.isAligned(buf.readableBytes()),</span>
                      &quot;Buffer must write multiple of alignment bytes (%d), %d is not&quot;,
<span class="nc" id="L115">                      Buffer.ALIGNMENT, buf.readableBytes());</span>

<span class="nc" id="L117">        int bytesToWrite = buf.readableBytes();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (bytesToWrite &lt;= 0) {</span>
<span class="nc" id="L119">            return;</span>
        }

<span class="nc" id="L122">        Buffer tmpBuffer = bufferPool.acquire();</span>
<span class="nc" id="L123">        tmpBuffer.reset();</span>
<span class="nc" id="L124">        tmpBuffer.writeByteBuf(buf);</span>
<span class="nc" id="L125">        Future&lt;?&gt; f = writeExecutor.submit(() -&gt; {</span>
<span class="nc" id="L126">            writeByteBuf(tmpBuffer, bytesToWrite, offset);</span>
<span class="nc" id="L127">            return null;</span>
            });
<span class="nc" id="L129">        addOutstandingWrite(f);</span>
<span class="nc" id="L130">    }</span>

    private void writeByteBuf(Buffer buffer, int bytesToWrite, long offsetToWrite) throws IOException{
        try {
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (bytesToWrite &lt;= 0) {</span>
<span class="nc" id="L135">                return;</span>
            }
<span class="nc" id="L137">            int ret = nativeIO.pwrite(fd, buffer.pointer(), bytesToWrite, offsetToWrite);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (ret != bytesToWrite) {</span>
<span class="nc" id="L139">                throw new IOException(exMsg(&quot;Incomplete write&quot;)</span>
<span class="nc" id="L140">                    .kv(&quot;filename&quot;, filename)</span>
<span class="nc" id="L141">                    .kv(&quot;pointer&quot;, buffer.pointer())</span>
<span class="nc" id="L142">                    .kv(&quot;offset&quot;, offsetToWrite)</span>
<span class="nc" id="L143">                    .kv(&quot;writeSize&quot;, bytesToWrite)</span>
<span class="nc" id="L144">                    .kv(&quot;bytesWritten&quot;, ret)</span>
<span class="nc" id="L145">                    .toString());</span>
            }
<span class="nc" id="L147">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L148">            throw new IOException(exMsg(&quot;Write error&quot;)</span>
<span class="nc" id="L149">                .kv(&quot;filename&quot;, filename)</span>
<span class="nc" id="L150">                .kv(&quot;offset&quot;, offsetToWrite)</span>
<span class="nc" id="L151">                .kv(&quot;writeSize&quot;, bytesToWrite)</span>
<span class="nc" id="L152">                .kv(&quot;pointer&quot;, buffer.pointer())</span>
<span class="nc" id="L153">                .kv(&quot;errno&quot;, ne.getErrno())</span>
<span class="nc" id="L154">                .toString());</span>
        } finally {
<span class="nc" id="L156">            bufferPool.release(buffer);</span>
        }
<span class="nc" id="L158">    }</span>

    @Override
    public int writeDelimited(ByteBuf buf) throws IOException {
<span class="nc" id="L162">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (!nativeBuffer.hasSpace(serializedSize(buf))) {</span>
<span class="nc" id="L164">                flushBuffer();</span>
            }

<span class="nc" id="L167">            int readable = buf.readableBytes();</span>
<span class="nc" id="L168">            long bufferPosition = position() + Integer.BYTES;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (bufferPosition &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L170">                throw new IOException(exMsg(&quot;Cannot write past max int&quot;)</span>
<span class="nc" id="L171">                                      .kv(&quot;filename&quot;, filename)</span>
<span class="nc" id="L172">                                      .kv(&quot;writeSize&quot;, readable)</span>
<span class="nc" id="L173">                                      .kv(&quot;position&quot;, bufferPosition)</span>
<span class="nc" id="L174">                                      .toString());</span>
            }
<span class="nc" id="L176">            nativeBuffer.writeInt(readable);</span>
<span class="nc" id="L177">            nativeBuffer.writeByteBuf(buf);</span>
<span class="nc" id="L178">            return (int) bufferPosition;</span>
        }
    }

    @Override
    public void position(long offset) throws IOException {
<span class="nc" id="L184">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">            if (nativeBuffer != null &amp;&amp; nativeBuffer.position() &gt; 0) {</span>
<span class="nc" id="L186">                flushBuffer();</span>
            }
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if ((offset % Buffer.ALIGNMENT) != 0) {</span>
<span class="nc" id="L189">                throw new IOException(exMsg(&quot;offset must be multiple of alignment&quot;)</span>
<span class="nc" id="L190">                                      .kv(&quot;offset&quot;, offset)</span>
<span class="nc" id="L191">                                      .kv(&quot;alignment&quot;, Buffer.ALIGNMENT)</span>
<span class="nc" id="L192">                                      .toString());</span>
            }
<span class="nc" id="L194">            this.offset = offset;</span>
<span class="nc" id="L195">        }</span>
<span class="nc" id="L196">    }</span>

    @Override
    public long position() {
<span class="nc" id="L200">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            return this.offset + (nativeBuffer != null ? nativeBuffer.position() : 0);</span>
        }
    }

    @Override
    public void flush() throws IOException {
<span class="nc" id="L207">        flushBuffer();</span>

<span class="nc" id="L209">        waitForOutstandingWrites();</span>

        try {
<span class="nc" id="L212">            int ret = nativeIO.fsync(fd);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            checkState(ret == 0, &quot;Fsync should throw exception on non-zero return (%d)&quot;, ret);</span>
<span class="nc" id="L214">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L215">            throw new IOException(exMsg(ne.getMessage())</span>
<span class="nc" id="L216">                                  .kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L217">                                  .kv(&quot;errno&quot;, ne.getErrno()).toString());</span>
<span class="nc" id="L218">        }</span>
<span class="nc" id="L219">    }</span>

    @Override
    public void close() throws IOException {
<span class="nc" id="L223">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">            if (nativeBuffer != null &amp;&amp; nativeBuffer.position() &gt; 0) {</span>
<span class="nc" id="L225">                flush();</span>
            }
<span class="nc" id="L227">        }</span>

        try {
<span class="nc" id="L230">            int ret = nativeIO.close(fd);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            checkState(ret == 0, &quot;Close should throw exception on non-zero return (%d)&quot;, ret);</span>
<span class="nc" id="L232">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L233">            throw new IOException(exMsg(ne.getMessage())</span>
<span class="nc" id="L234">                                  .kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L235">                                  .kv(&quot;errno&quot;, ne.getErrno()).toString());</span>
<span class="nc" id="L236">        }</span>
<span class="nc" id="L237">        synchronized (bufferLock) {</span>
<span class="nc" id="L238">            bufferPool.release(nativeBuffer);</span>
<span class="nc" id="L239">            nativeBuffer = null;</span>
<span class="nc" id="L240">        }</span>
<span class="nc" id="L241">    }</span>

    private void addOutstandingWrite(Future&lt;?&gt; toAdd) throws IOException {
<span class="nc" id="L244">        synchronized (outstandingWrites) {</span>
<span class="nc" id="L245">            outstandingWrites.add(toAdd);</span>

<span class="nc" id="L247">            Iterator&lt;Future&lt;?&gt;&gt; iter = outstandingWrites.iterator();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            while (iter.hasNext()) { // clear out completed futures</span>
<span class="nc" id="L249">                Future&lt;?&gt; f = iter.next();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                if (f.isDone()) {</span>
<span class="nc" id="L251">                    waitForFuture(f);</span>
<span class="nc" id="L252">                    iter.remove();</span>
                } else {
                    break;
                }
<span class="nc" id="L256">            }</span>
<span class="nc" id="L257">        }</span>
<span class="nc" id="L258">    }</span>

    private void waitForOutstandingWrites() throws IOException {
<span class="nc" id="L261">        synchronized (outstandingWrites) {</span>
<span class="nc" id="L262">            Iterator&lt;Future&lt;?&gt;&gt; iter = outstandingWrites.iterator();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            while (iter.hasNext()) { // clear out completed futures</span>
<span class="nc" id="L264">                Future&lt;?&gt; f = iter.next();</span>
<span class="nc" id="L265">                waitForFuture(f);</span>
<span class="nc" id="L266">                iter.remove();</span>
<span class="nc" id="L267">            }</span>
<span class="nc" id="L268">        }</span>
<span class="nc" id="L269">    }</span>

    private void waitForFuture(Future&lt;?&gt; f) throws IOException {
        try {
<span class="nc" id="L273">            f.get();</span>
<span class="nc" id="L274">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L275">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L276">            throw new IOException(ie);</span>
<span class="nc" id="L277">        } catch (Throwable t) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (t.getCause() instanceof IOException) {</span>
<span class="nc" id="L279">                throw (IOException) t.getCause();</span>
            } else {
<span class="nc" id="L281">                throw new IOException(t);</span>
            }
<span class="nc" id="L283">        }</span>
<span class="nc" id="L284">    }</span>

    private void flushBuffer() throws IOException {
<span class="nc" id="L287">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (this.nativeBuffer != null) {</span>
<span class="nc" id="L289">                int bytesToWrite = this.nativeBuffer.padToAlignment();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if (bytesToWrite == 0) {</span>
<span class="nc" id="L291">                    return;</span>
                }

<span class="nc" id="L294">                Buffer bufferToFlush = this.nativeBuffer;</span>
<span class="nc" id="L295">                this.nativeBuffer = null;</span>

<span class="nc" id="L297">                long offsetToWrite = offset;</span>
<span class="nc" id="L298">                offset += bytesToWrite;</span>

<span class="nc" id="L300">                Future&lt;?&gt; f = writeExecutor.submit(() -&gt; {</span>
<span class="nc" id="L301">                    writeByteBuf(bufferToFlush, bytesToWrite, offsetToWrite);</span>
<span class="nc" id="L302">                    return null;</span>
                });
<span class="nc" id="L304">                addOutstandingWrite(f);</span>

                // must acquire after triggering the write
                // otherwise it could try to acquire a buffer without kicking off
                // a subroutine that will free another
<span class="nc" id="L309">                this.nativeBuffer = bufferPool.acquire();</span>
            }
<span class="nc" id="L311">        }</span>
<span class="nc" id="L312">    }</span>

    @Override
    public int serializedSize(ByteBuf buf) {
<span class="nc" id="L316">        return buf.readableBytes() + Integer.BYTES;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>