<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EntryCopierImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie.datainteg</a> &gt; <span class="el_source">EntryCopierImpl.java</span></div><h1>EntryCopierImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.bookkeeper.bookie.datainteg;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Ticker;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedMap;
import io.netty.buffer.ByteBuf;
import io.netty.util.ReferenceCountUtil;
import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import lombok.extern.slf4j.Slf4j;
import org.apache.bookkeeper.bookie.LedgerStorage;
import org.apache.bookkeeper.client.BKException;
import org.apache.bookkeeper.client.api.LedgerMetadata;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.proto.BookieClient;
import org.apache.bookkeeper.proto.BookieProtocol;

/**
 * Implementation for the EntryCopier interface. Handles the reading of entries
 * from peer bookies.
 */
<span class="nc" id="L55">@Slf4j</span>
public class EntryCopierImpl implements EntryCopier {
<span class="nc" id="L57">    private static final long SINBIN_DURATION_MS = TimeUnit.MINUTES.toMillis(1);</span>
    private final BookieId bookieId;
    private final BookieClient bookieClient;
    private final LedgerStorage storage;
    private final Ticker ticker;
    private final SinBin sinBin;

    public EntryCopierImpl(BookieId bookieId,
                    BookieClient bookieClient,
                    LedgerStorage storage,
<span class="nc" id="L67">                    Ticker ticker) {</span>
<span class="nc" id="L68">        this.bookieId = bookieId;</span>
<span class="nc" id="L69">        this.bookieClient = bookieClient;</span>
<span class="nc" id="L70">        this.storage = storage;</span>
<span class="nc" id="L71">        this.ticker = ticker;</span>
<span class="nc" id="L72">        this.sinBin = new SinBin(ticker);</span>
<span class="nc" id="L73">    }</span>

    @Override
    public Batch newBatch(long ledgerId, LedgerMetadata metadata) throws IOException {
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (!storage.ledgerExists(ledgerId)) {</span>
<span class="nc" id="L78">            storage.setMasterKey(ledgerId, metadata.getPassword());</span>
        }
<span class="nc" id="L80">        return new BatchImpl(bookieId, ledgerId, metadata, sinBin);</span>
    }

    @VisibleForTesting
    class BatchImpl implements Batch {
        private final long ledgerId;
        private final LedgerMetadata metadata;
        private final SinBin sinBin;
        private volatile ImmutableSortedMap&lt;Long, WriteSets&gt; writeSets;

        BatchImpl(BookieId bookieId,
                  long ledgerId, LedgerMetadata metadata,
<span class="nc" id="L92">                  SinBin sinBin) {</span>
<span class="nc" id="L93">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L94">            this.metadata = metadata;</span>
<span class="nc" id="L95">            this.sinBin = sinBin;</span>
<span class="nc" id="L96">            updateWriteSets();</span>
<span class="nc" id="L97">        }</span>

        private void updateWriteSets() {
            // clear non-erroring bookies

            // in theory we should be able to have a single set of writesets per ledger,
            // however, if there are multiple ensembles, bookies will move around, and we
            // still want to avoid erroring bookies
<span class="nc" id="L105">            this.writeSets = preferredBookieIndices(bookieId, metadata,</span>
<span class="nc" id="L106">                                                    sinBin.getErrorBookies(), ledgerId)</span>
<span class="nc" id="L107">                .entrySet().stream().collect(</span>
<span class="nc" id="L108">                        ImmutableSortedMap.toImmutableSortedMap(</span>
<span class="nc" id="L109">                                Comparator.naturalOrder(),</span>
<span class="nc" id="L110">                                e -&gt; e.getKey(),</span>
<span class="nc" id="L111">                                e -&gt; new WriteSets(e.getValue(),</span>
<span class="nc" id="L112">                                                   metadata.getEnsembleSize(),</span>
<span class="nc" id="L113">                                                   metadata.getWriteQuorumSize())));</span>
<span class="nc" id="L114">        }</span>

        @VisibleForTesting
        void notifyBookieError(BookieId bookie) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (sinBin.addFailed(bookie)) {</span>
<span class="nc" id="L119">                updateWriteSets();</span>
            }
<span class="nc" id="L121">        }</span>

        @Override
        public CompletableFuture&lt;Long&gt; copyFromAvailable(long entryId) {
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (entryId &lt; 0) {</span>
<span class="nc" id="L126">                throw new IllegalArgumentException(</span>
<span class="nc" id="L127">                        String.format(&quot;Entry ID (%d) can't be less than 0&quot;, entryId));</span>
            }
<span class="nc bnc" id="L129" title="All 4 branches missed.">            if (metadata.isClosed() &amp;&amp; entryId &gt; metadata.getLastEntryId()) {</span>
<span class="nc" id="L130">                throw new IllegalArgumentException(</span>
<span class="nc" id="L131">                        String.format(&quot;Invalid entry id (%d), last entry for ledger %d is %d&quot;,</span>
<span class="nc" id="L132">                                      entryId, ledgerId, metadata.getLastEntryId()));</span>
            }
<span class="nc" id="L134">            CompletableFuture&lt;Long&gt; promise = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L135">            fetchEntry(entryId).whenComplete((buffer, exception) -&gt; {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    if (exception != null) {</span>
<span class="nc" id="L137">                        promise.completeExceptionally(exception);</span>
                    } else {
                        try {
<span class="nc" id="L140">                            long length = buffer.readableBytes();</span>
<span class="nc" id="L141">                            storage.addEntry(buffer);</span>
<span class="nc" id="L142">                            promise.complete(length);</span>
<span class="nc" id="L143">                        } catch (Throwable t) {</span>
<span class="nc" id="L144">                            promise.completeExceptionally(t);</span>
                        } finally {
<span class="nc" id="L146">                            ReferenceCountUtil.release(buffer);</span>
                        }
                    }
<span class="nc" id="L149">                });</span>
<span class="nc" id="L150">            return promise;</span>
        }

        @VisibleForTesting
        CompletableFuture&lt;ByteBuf&gt; fetchEntry(long entryId) {
<span class="nc" id="L155">            List&lt;BookieId&gt; ensemble = metadata.getEnsembleAt(entryId);</span>
<span class="nc" id="L156">            final Map.Entry&lt;Long, WriteSets&gt; writeSetsForEntryId = this.writeSets</span>
<span class="nc" id="L157">                    .floorEntry(entryId);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (writeSetsForEntryId == null) {</span>
<span class="nc" id="L159">                log.error(&quot;writeSets for entryId {} not found, writeSets {}&quot;, entryId, writeSets);</span>
<span class="nc" id="L160">                throw new IllegalStateException(&quot;writeSets for entryId: &quot; + entryId + &quot; not found&quot;);</span>
            }
<span class="nc" id="L162">            ImmutableList&lt;Integer&gt; writeSet = writeSetsForEntryId</span>
<span class="nc" id="L163">                    .getValue()</span>
<span class="nc" id="L164">                    .getForEntry(entryId);</span>
<span class="nc" id="L165">            int attempt = 0;</span>
<span class="nc" id="L166">            CompletableFuture&lt;ByteBuf&gt; promise = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L167">            fetchRetryLoop(entryId, attempt,</span>
                           ensemble, writeSet,
<span class="nc" id="L169">                           promise, Optional.empty());</span>
<span class="nc" id="L170">            return promise;</span>
        }

        private void fetchRetryLoop(long entryId, int attempt,
                                    List&lt;BookieId&gt; ensemble,
                                    ImmutableList&lt;Integer&gt; writeSet,
                                    CompletableFuture&lt;ByteBuf&gt; promise,
                                    Optional&lt;Throwable&gt; firstException) {
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (attempt &gt;= writeSet.size()) {</span>
<span class="nc" id="L179">                promise.completeExceptionally(</span>
<span class="nc" id="L180">                        firstException.orElse(new BKException.BKReadException()));</span>
<span class="nc" id="L181">                return;</span>
            }
<span class="nc" id="L183">            BookieId bookie = ensemble.get(writeSet.get(attempt));</span>
<span class="nc" id="L184">            readEntry(bookie, ledgerId, entryId)</span>
<span class="nc" id="L185">                .whenComplete((buffer, exception) -&gt; {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                        if (exception != null) {</span>
<span class="nc" id="L187">                            notifyBookieError(bookie);</span>
                            Optional&lt;Throwable&gt; firstException1 =
<span class="nc bnc" id="L189" title="All 2 branches missed.">                                firstException.isPresent() ? firstException : Optional.of(exception);</span>
<span class="nc" id="L190">                            fetchRetryLoop(entryId, attempt + 1,</span>
                                           ensemble, writeSet, promise, firstException1);
<span class="nc" id="L192">                        } else {</span>
<span class="nc" id="L193">                            promise.complete(buffer);</span>
                        }
<span class="nc" id="L195">                    });</span>
<span class="nc" id="L196">        }</span>
    }

    // convert callback api to future api
    private CompletableFuture&lt;ByteBuf&gt; readEntry(BookieId bookieId,
                                                 long ledgerId, long entryId) {
<span class="nc" id="L202">        CompletableFuture&lt;ByteBuf&gt; promise = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L203">        bookieClient.readEntry(bookieId, ledgerId, entryId,</span>
                               (rc, ledgerId1, entryId1, buffer, ctx1) -&gt; {
<span class="nc bnc" id="L205" title="All 2 branches missed.">                                   if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L206">                                       promise.completeExceptionally(BKException.create(rc));</span>
                                   } else {
<span class="nc" id="L208">                                       buffer.retain();</span>
<span class="nc" id="L209">                                       promise.complete(buffer);</span>
                                   }
<span class="nc" id="L211">                               }, null, BookieProtocol.FLAG_NONE);</span>
<span class="nc" id="L212">        return promise;</span>
    }

    /**
     * Generate a map of preferred bookie indices. For each ensemble, generate the order
     * in which bookies should be tried for entries, notwithstanding errors.
     * For example, if a e5,w2,a2 ensemble has the bookies:
     * [bookie1, bookie2, bookie3, bookie4, bookie5]
     * and the current bookie is bookie2, then we should return something like:
     * [4, 2, 0, 3]
     * Then when retrieving an entry, even though it is only written to 2, we try the bookie
     * in the order from this list. This will cause more requests to go to the same bookie,
     * which should give us the benefit of read locality.
     * We don't want to simply sort by bookie id, as that would cause the same bookies to be
     * loaded for all ensembles.
     * Bookies which have presented errors are always tried last.
     */
    @VisibleForTesting
    static ImmutableSortedMap&lt;Long, ImmutableList&lt;Integer&gt;&gt; preferredBookieIndices(
            BookieId bookieId,
            LedgerMetadata metadata,
            Set&lt;BookieId&gt; errorBookies,
            long seed) {
<span class="nc" id="L235">        return metadata.getAllEnsembles().entrySet().stream()</span>
<span class="nc" id="L236">            .collect(ImmutableSortedMap.toImmutableSortedMap(</span>
<span class="nc" id="L237">                             Comparator.naturalOrder(),</span>
<span class="nc" id="L238">                             e -&gt; e.getKey(),</span>
                             e -&gt; {
<span class="nc" id="L240">                                 List&lt;BookieId&gt; ensemble = e.getValue();</span>
                                 // get indices of the interesting bookies
<span class="nc" id="L242">                                 int myIndex = ensemble.indexOf(bookieId);</span>
<span class="nc" id="L243">                                 Set&lt;Integer&gt; errorIndices = errorBookies.stream()</span>
<span class="nc" id="L244">                                     .map(b -&gt; ensemble.indexOf(b)).collect(Collectors.toSet());</span>

                                 // turn bookies into positions and filter out my own
                                 // bookie id (we're not going to try to read from outself)
<span class="nc" id="L248">                                 List&lt;Integer&gt; indices = IntStream.range(0, ensemble.size())</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                                     .filter(i -&gt; i != myIndex).boxed().collect(Collectors.toList());</span>

                                 // shuffle the indices based seed (normally ledgerId)
<span class="nc" id="L252">                                 Collections.shuffle(indices, new Random(seed));</span>

                                 // Move the error bookies to the end
                                 // Collections#sort is stable, so everything else remains the same
<span class="nc" id="L256">                                 Collections.sort(indices, (a, b) -&gt; {</span>
<span class="nc" id="L257">                                         boolean aErr = errorIndices.contains(a);</span>
<span class="nc" id="L258">                                         boolean bErr = errorIndices.contains(b);</span>
<span class="nc bnc" id="L259" title="All 4 branches missed.">                                         if (aErr &amp;&amp; !bErr) {</span>
<span class="nc" id="L260">                                             return 1;</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">                                         } else if (!aErr &amp;&amp; bErr) {</span>
<span class="nc" id="L262">                                             return -1;</span>
                                         } else {
<span class="nc" id="L264">                                             return 0;</span>
                                         }
                                     });
<span class="nc" id="L267">                                 return ImmutableList.copyOf(indices);</span>
                             }));
    }

    @VisibleForTesting
    static class SinBin {
        private final Ticker ticker;
<span class="nc" id="L274">        private final ConcurrentMap&lt;BookieId, Long&gt; errorBookies = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L276">        SinBin(Ticker ticker) {</span>
<span class="nc" id="L277">            this.ticker = ticker;</span>
<span class="nc" id="L278">        }</span>

        /**
         * Returns true if this is the first error for this bookie.
         */
        boolean addFailed(BookieId bookie) {
<span class="nc" id="L284">            long newDeadline = TimeUnit.NANOSECONDS.toMillis(ticker.read()) + SINBIN_DURATION_MS;</span>
<span class="nc" id="L285">            Long oldDeadline = errorBookies.put(bookie, newDeadline);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            return oldDeadline == null;</span>
        }

        Set&lt;BookieId&gt; getErrorBookies() {
<span class="nc" id="L290">            long now = TimeUnit.NANOSECONDS.toMillis(ticker.read());</span>
<span class="nc" id="L291">            Iterator&lt;Map.Entry&lt;BookieId, Long&gt;&gt; iterator = errorBookies.entrySet().iterator();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            while (iterator.hasNext()) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                if (iterator.next().getValue() &lt; now) {</span>
<span class="nc" id="L294">                    iterator.remove();</span>
                }
            }
<span class="nc" id="L297">            return errorBookies.keySet();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>