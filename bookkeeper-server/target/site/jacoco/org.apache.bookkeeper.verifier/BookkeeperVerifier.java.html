<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BookkeeperVerifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.verifier</a> &gt; <span class="el_source">BookkeeperVerifier.java</span></div><h1>BookkeeperVerifier.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.bookkeeper.verifier;

import static com.google.common.base.Preconditions.checkState;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import org.apache.bookkeeper.client.BKException;

/**
 * Encapsulates logic for playing and verifying operations against a bookkeeper-like
 * interface. The test state consists of a set of ledgers in 1 of several states:
 * 1) opening -- waiting for driver to complete open
 * 2) open -- valid targets for reads and writes
 * 3) live -- valid targets for reads
 * 4) deleting
 * Each ledger moves in sequence through these states.  See startWrite for the
 * code driving the lifecycle.
 */
public class BookkeeperVerifier {
<span class="nc" id="L50">    private final Queue&lt;Exception&gt; errors = new LinkedList&lt;&gt;();</span>

    private synchronized boolean checkReturn(long ledgerID, int rc) {
<span class="nc bnc" id="L53" title="All 2 branches missed.">        if (BKException.Code.OK != rc) {</span>
<span class="nc" id="L54">            String error = String.format(&quot;Got error %d on ledger %d&quot;, rc, ledgerID);</span>
<span class="nc" id="L55">            System.out.println(error);</span>
<span class="nc" id="L56">            propagateExceptionToMain(BKException.create(rc));</span>
<span class="nc" id="L57">            return true;</span>
        } else {
<span class="nc" id="L59">            return false;</span>
        }
    }

    private synchronized void propagateExceptionToMain(Exception e) {
<span class="nc" id="L64">        errors.add(e);</span>
<span class="nc" id="L65">        this.notifyAll();</span>
<span class="nc" id="L66">    }</span>

    private synchronized void printThrowExceptions() throws Exception {
<span class="nc bnc" id="L69" title="All 2 branches missed.">        if (!errors.isEmpty()) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">            for (Exception e: errors) {</span>
<span class="nc" id="L71">                System.out.format(&quot;Error found: %s%n&quot;, e.toString());</span>
<span class="nc" id="L72">                e.printStackTrace();</span>
<span class="nc" id="L73">            }</span>
<span class="nc" id="L74">            throw errors.poll();</span>
        }
<span class="nc" id="L76">    }</span>

    /**
     * Provides an interface for translating test operations into operations on a
     * cluster.
     */
    public interface BookkeeperDriver {
        void createLedger(
                long ledgerID, int enSize, int writeQSize, int ackQSize,
                Consumer&lt;Integer&gt; cb
        );

        void closeLedger(
                long ledgerID,
                Consumer&lt;Integer&gt; cb
        );

        void deleteLedger(
                long ledgerID,
                Consumer&lt;Integer&gt; cb
        );

        void writeEntry(
                long ledgerID,
                long entryID,
                byte[] data,
                Consumer&lt;Integer&gt; cb
        );

        /**
         * Callback for reads.
         */
        interface ReadCallback {
            void complete(
                    long ledgerID,
                    ArrayList&lt;byte[]&gt; results
            );
        }

        void readEntries(
                long ledgerID,
                long firstEntryID,
                long lastEntryID,
                BiConsumer&lt;Integer, ArrayList&lt;byte[]&gt;&gt; cb);
    }

    private final BookkeeperDriver driver;

    private final int ensembleSize;
    private final int writeQuorum;
    private final int ackQuorum;
    private final int duration;
    private final int drainTimeout;
    private final int targetConcurrentLedgers;
    private final int targetConcurrentWrites;
    private final int targetWriteGroup;
    private final int targetReadGroup;
    private final int targetLedgers;
    private final int targetEntrySize;
    private final int targetConcurrentReads;
    private final double coldToHotRatio;

    private final long targetLedgerEntries;

    BookkeeperVerifier(
            BookkeeperDriver driver,
            int ensembleSize,
            int writeQuorum,
            int ackQuorum,
            int duration,
            int drainTimeout,
            int targetConcurrentLedgers,
            int targetConcurrentWrites,
            int targetWriteGroup,
            int targetReadGroup,
            int targetLedgers,
            long targetLedgerSize,
            int targetEntrySize,
            int targetConcurrentReads,
<span class="nc" id="L155">            double coldToHotRatio) {</span>
<span class="nc" id="L156">        this.driver = driver;</span>
<span class="nc" id="L157">        this.ensembleSize = ensembleSize;</span>
<span class="nc" id="L158">        this.writeQuorum = writeQuorum;</span>
<span class="nc" id="L159">        this.ackQuorum = ackQuorum;</span>
<span class="nc" id="L160">        this.duration = duration;</span>
<span class="nc" id="L161">        this.drainTimeout = drainTimeout;</span>
<span class="nc" id="L162">        this.targetConcurrentLedgers = targetConcurrentLedgers;</span>
<span class="nc" id="L163">        this.targetConcurrentWrites = targetConcurrentWrites;</span>
<span class="nc" id="L164">        this.targetWriteGroup = targetWriteGroup;</span>
<span class="nc" id="L165">        this.targetReadGroup = targetReadGroup;</span>
<span class="nc" id="L166">        this.targetLedgers = targetLedgers;</span>
<span class="nc" id="L167">        this.targetEntrySize = targetEntrySize;</span>
<span class="nc" id="L168">        this.targetConcurrentReads = targetConcurrentReads;</span>
<span class="nc" id="L169">        this.coldToHotRatio = coldToHotRatio;</span>

<span class="nc" id="L171">        this.targetLedgerEntries = targetLedgerSize / targetEntrySize;</span>
<span class="nc" id="L172">    }</span>

<span class="nc" id="L174">    private int outstandingWriteCount = 0;</span>
<span class="nc" id="L175">    private int outstandingReadCount = 0;</span>
<span class="nc" id="L176">    private long nextLedger = 0;</span>
    private long getNextLedgerID() {
<span class="nc" id="L178">        return nextLedger++;</span>
    }

    /**
     * State required to regenerate an entry.
     */
    @SuppressFBWarnings(&quot;DMI_RANDOM_USED_ONLY_ONCE&quot;)
    class EntryInfo {
        private final long entryID;
        private final long seed;
<span class="nc" id="L188">        EntryInfo(long entryID, long seed) {</span>
<span class="nc" id="L189">            this.entryID = entryID;</span>
<span class="nc" id="L190">            this.seed = seed;</span>
<span class="nc" id="L191">        }</span>
        byte[] getBuffer() {
<span class="nc" id="L193">            Random rand = new Random(seed);</span>
<span class="nc" id="L194">            byte[] ret = new byte[targetEntrySize];</span>
<span class="nc" id="L195">            rand.nextBytes(ret);</span>
<span class="nc" id="L196">            return ret;</span>
        }
        long getEntryID() {
<span class="nc" id="L199">            return entryID;</span>
        }
    }

    /**
     * Contains the state required to reconstruct the contents of any entry in the ledger.
     * The seed value passed into the constructor fully determines the contents of the
     * ledger.  Each EntryInfo has its own seed generated sequentially from a Random instance
     * seeded from the original seed.  It then uses that seed to generate a secondary Random
     * instance for generating the bytes within the entry.  See EntryIterator for details.
     * Random(seed)
     *  |
     *  E0 -&gt; Random(E0) -&gt; getBuffer()
     *  |
     *  E1 -&gt; Random(E1) -&gt; getBuffer()
     *  |
     *  E2 -&gt; Random(E2) -&gt; getBuffer()
     *  |
     *  E3 -&gt; Random(E3) -&gt; getBuffer()
     *  |
     *  E4 -&gt; Random(E4) -&gt; getBuffer()
     *  |
     *  ...
     */
<span class="nc" id="L223">    class LedgerInfo {</span>
        private final long ledgerID;
        private final long seed;
<span class="nc" id="L226">        private long lastEntryIDCompleted = -1;</span>
<span class="nc" id="L227">        private long confirmedLAC = -1;</span>
<span class="nc" id="L228">        private boolean closed = false;</span>

<span class="nc" id="L230">        final TreeSet&lt;Long&gt; writesInProgress = new TreeSet&lt;&gt;();</span>
<span class="nc" id="L231">        final TreeSet&lt;Long&gt; writesCompleted = new TreeSet&lt;&gt;();</span>
<span class="nc" id="L232">        int readsInProgress = 0;</span>
<span class="nc" id="L233">        Consumer&lt;Consumer&lt;Integer&gt;&gt; onLastOp = null;</span>
<span class="nc" id="L234">        Consumer&lt;Consumer&lt;Integer&gt;&gt; onLastWrite = null;</span>

        EntryIterator iter;

<span class="nc" id="L238">        LedgerInfo(long ledgerID, long seed) {</span>
<span class="nc" id="L239">            this.ledgerID = ledgerID;</span>
<span class="nc" id="L240">            this.seed = seed;</span>
<span class="nc" id="L241">            iter = new EntryIterator();</span>
<span class="nc" id="L242">        }</span>

        long getLastEntryIDCompleted() {
<span class="nc" id="L245">            return lastEntryIDCompleted;</span>
        }

        long getConfirmedLAC() {
<span class="nc" id="L249">            return confirmedLAC;</span>
        }

        ArrayList&lt;EntryInfo&gt; getNextEntries(int num) {
<span class="nc" id="L253">            ArrayList&lt;EntryInfo&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">            for (int i = 0; i &lt; num &amp;&amp; iter.hasNext(); ++i) {</span>
<span class="nc" id="L255">                ret.add(iter.next());</span>
            }
<span class="nc" id="L257">            return ret;</span>
        }

        class EntryIterator implements Iterator&lt;EntryInfo&gt; {
            Random rand;
            long currentID;
            long currentSeed;

<span class="nc" id="L265">            EntryIterator() {</span>
<span class="nc" id="L266">                seek(-1);</span>
<span class="nc" id="L267">            }</span>

            void seek(long entryID) {
<span class="nc" id="L270">                currentID = -1;</span>
<span class="nc" id="L271">                currentSeed = seed;</span>
<span class="nc" id="L272">                rand = new Random(seed);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                while (currentID &lt; entryID) {</span>
<span class="nc" id="L274">                    advance();</span>
                }
<span class="nc" id="L276">            }</span>

            void advance() {
<span class="nc" id="L279">                currentSeed = rand.nextLong();</span>
<span class="nc" id="L280">                currentID++;</span>
<span class="nc" id="L281">            }</span>

            EntryInfo get() {
<span class="nc" id="L284">                return new EntryInfo(currentID, currentSeed);</span>
            }

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L289" title="All 2 branches missed.">                return currentID &lt; targetLedgerEntries;</span>
            }


            @Override
            public EntryInfo next() {
<span class="nc" id="L295">                advance();</span>
<span class="nc" id="L296">                return get();</span>
            }
        }

        EntryIterator getIterator() {
<span class="nc" id="L301">            return new EntryIterator();</span>
        }

        void openWrite(long entryID) {
<span class="nc" id="L305">            writesInProgress.add(entryID);</span>
<span class="nc" id="L306">            System.out.format(&quot;Open writes, %s%n&quot;, writesInProgress);</span>
<span class="nc" id="L307">        }</span>

        void incReads() {
<span class="nc" id="L310">            readsInProgress++;</span>
<span class="nc" id="L311">            System.out.format(&quot;Inc reads to %d%n&quot;, readsInProgress);</span>
<span class="nc" id="L312">        }</span>

        /**
         * The idea here is that we may need to register an operation which needs to run
         * whenever the final op completes on this Ledger (like deletion).  If there
         * are none, newOnLastOp should be called synchronously with cb.  Otherwise,
         * cb should be called synchronously with cb and newOnLastOp should be called
         * with the cb passed in with the decReads or closeWrite.
         * In the deletion case, cb would be the callback for the error from
         * the deletion operation (if it happens).  The reason for all of this is that
         * the delete case will need to chain an async call to delete into the async callback
         * chain for whatever the last operation to complete on this Ledger.  newOnLastOp
         * would invoke that delete.  The cb passed in allows it to pick up and continue
         * the original chain.
         * @param cb Callback to get result of newOnLastOp if called now
         * @param newOnLastOp Callback to be invoked on the last decReads or closeWrite,
         *                    should be passed the cb passed in with the final closeWrite
         *                    or decReads
         */
        void onLastOpComplete(
                Consumer&lt;Integer&gt; cb,
                Consumer&lt;Consumer&lt;Integer&gt;&gt; newOnLastOp) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">            checkState(onLastOp == null);</span>
<span class="nc" id="L335">            onLastOp = newOnLastOp;</span>
<span class="nc" id="L336">            checkOpComplete(cb);</span>
<span class="nc" id="L337">        }</span>

        /**
         * Very similar to onLastOpComplete, but gets called on the final call to closeWrite.
         * @param cb Callback to get result of newOnLastWrite if called now
         * @param newOnLastWrite Callback to be invoked on the last closeWrite,
         *                       should be passed the cb passed in with the final closeWrite.
         */
        void onLastWriteComplete(
                Consumer&lt;Integer&gt; cb,
                Consumer&lt;Consumer&lt;Integer&gt;&gt; newOnLastWrite) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">            assert (onLastWrite == null);</span>
<span class="nc" id="L349">            onLastWrite = newOnLastWrite;</span>
<span class="nc" id="L350">            checkWriteComplete(cb);</span>
<span class="nc" id="L351">        }</span>

        void closeWrite(long entryID, Consumer&lt;Integer&gt; cb) {
<span class="nc" id="L354">            writesInProgress.remove(entryID);</span>
<span class="nc" id="L355">            writesCompleted.add(entryID);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            long completedTo = writesInProgress.isEmpty() ? Long.MAX_VALUE : writesInProgress.first();</span>
<span class="nc bnc" id="L357" title="All 4 branches missed.">            while (!writesCompleted.isEmpty() &amp;&amp; writesCompleted.first() &lt; completedTo) {</span>
<span class="nc" id="L358">                lastEntryIDCompleted = writesCompleted.first();</span>
<span class="nc" id="L359">                writesCompleted.remove(writesCompleted.first());</span>
            }
<span class="nc" id="L361">            checkWriteComplete((rc) -&gt; {</span>
<span class="nc" id="L362">                checkReturn(ledgerID, rc);</span>
<span class="nc" id="L363">                checkOpComplete(cb);</span>
<span class="nc" id="L364">            });</span>
<span class="nc" id="L365">        }</span>

        void updateLAC(long lac) {
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (lac &gt; confirmedLAC) {</span>
<span class="nc" id="L369">                confirmedLAC = lac;</span>
            }
<span class="nc" id="L371">        }</span>

        void decReads(Consumer&lt;Integer&gt; cb) {
<span class="nc" id="L374">            --readsInProgress;</span>
<span class="nc" id="L375">            checkOpComplete(cb);</span>
<span class="nc" id="L376">        }</span>

        private void checkWriteComplete(Consumer&lt;Integer&gt; cb) {
<span class="nc bnc" id="L379" title="All 4 branches missed.">            if (writesInProgress.isEmpty() &amp;&amp; onLastWrite != null) {</span>
<span class="nc" id="L380">                System.out.format(&quot;checkWriteComplete: done%n&quot;);</span>
<span class="nc" id="L381">                onLastWrite.accept(cb);</span>
<span class="nc" id="L382">                onLastWrite = null;</span>
            } else {
<span class="nc" id="L384">                System.out.format(</span>
                        &quot;checkWriteComplete: ledger %d, writesInProgress %s%n&quot;,
<span class="nc" id="L386">                        ledgerID,</span>
                        writesInProgress);
<span class="nc" id="L388">                cb.accept(0);</span>
            }
<span class="nc" id="L390">        }</span>

        private void checkOpComplete(Consumer&lt;Integer&gt; cb) {
<span class="nc bnc" id="L393" title="All 6 branches missed.">            if (readsInProgress == 0 &amp;&amp; writesInProgress.isEmpty() &amp;&amp; onLastOp != null) {</span>
<span class="nc" id="L394">                System.out.format(&quot;checkOpComplete: done%n&quot;);</span>
<span class="nc" id="L395">                onLastOp.accept(cb);</span>
<span class="nc" id="L396">                onLastOp = null;</span>
            } else {
<span class="nc" id="L398">                System.out.format(</span>
                        &quot;checkOpComplete: ledger %d, writesInProgress %s, readsInProgress %d%n&quot;,
<span class="nc" id="L400">                        ledgerID,</span>
<span class="nc" id="L401">                        writesInProgress, readsInProgress);</span>
<span class="nc" id="L402">                cb.accept(0);</span>
            }
<span class="nc" id="L404">        }</span>

        public boolean isClosed() {
<span class="nc" id="L407">            return closed;</span>
        }
        public void setClosed() {
<span class="nc" id="L410">            closed = true;</span>
<span class="nc" id="L411">            confirmedLAC = lastEntryIDCompleted;</span>
<span class="nc" id="L412">        }</span>
    }

<span class="nc" id="L415">    private final Set&lt;LedgerInfo&gt; openingLedgers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L416">    private final Set&lt;LedgerInfo&gt; openLedgers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L417">    private final Set&lt;LedgerInfo&gt; liveLedgers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L418">    private final Random opRand = new Random();</span>

    private LedgerInfo getRandomLedger(Collection&lt;LedgerInfo&gt; ledgerCollection) {
<span class="nc" id="L421">        int elem = opRand.nextInt(ledgerCollection.size());</span>
<span class="nc" id="L422">        Iterator&lt;LedgerInfo&gt; iter = ledgerCollection.iterator();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (int i = 0; i &lt; elem; ++i) {</span>
<span class="nc" id="L424">            iter.next();</span>
        }
<span class="nc" id="L426">        return iter.next();</span>
    }

    private synchronized boolean startRead() {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (outstandingReadCount &gt; targetConcurrentReads) {</span>
<span class="nc" id="L431">            System.out.format(&quot;Not starting another read, enough in progress%n&quot;);</span>
            /* Caller should exit and wait for outstandingReadCount to fall */
<span class="nc" id="L433">            return false;</span>
        }
        LedgerInfo ledger;
<span class="nc bnc" id="L436" title="All 4 branches missed.">        if (!openLedgers.isEmpty() &amp;&amp; (opRand.nextDouble() &gt; coldToHotRatio)) {</span>
<span class="nc" id="L437">            ledger = getRandomLedger(openLedgers);</span>
<span class="nc" id="L438">            System.out.format(&quot;Reading from open ledger %d%n&quot;, ledger.ledgerID);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        } else if (!liveLedgers.isEmpty()) {</span>
<span class="nc" id="L440">            ledger = getRandomLedger(liveLedgers);</span>
<span class="nc" id="L441">            System.out.format(&quot;Reading from cold ledger %d%n&quot;, ledger.ledgerID);</span>
        } else {
            /* No readable ledgers, either startWrite can make progress, or there are already ledgers
             * opening.
             */
<span class="nc" id="L446">            return false;</span>
        }
<span class="nc" id="L448">        long lastEntryCompleted = ledger.getConfirmedLAC();</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (lastEntryCompleted &lt;= 0) {</span>
<span class="nc" id="L450">            System.out.format(&quot;No readable entries in ledger %d, let's wait%n&quot;, ledger.ledgerID);</span>
            /* Either startWrite can make progress or there are already a bunch in progress */
<span class="nc" id="L452">            return false;</span>
        }
<span class="nc" id="L454">        long start = Math.abs(opRand.nextLong() % lastEntryCompleted);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        long end = start + targetReadGroup &gt; lastEntryCompleted ? lastEntryCompleted : start + targetReadGroup;</span>
<span class="nc" id="L456">        System.out.format(&quot;Reading %d -&gt; %d from ledger %d%n&quot;, start, end, ledger.ledgerID);</span>
<span class="nc" id="L457">        LedgerInfo finalLedger = ledger;</span>
<span class="nc" id="L458">        ledger.incReads();</span>
<span class="nc" id="L459">        driver.readEntries(ledger.ledgerID, start, end, (rc, results) -&gt; {</span>
<span class="nc" id="L460">            synchronized (BookkeeperVerifier.this) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                if (checkReturn(ledger.ledgerID, rc)) {</span>
<span class="nc" id="L462">                    return;</span>
                }
<span class="nc" id="L464">                System.out.format(&quot;Read %d -&gt; %d from ledger %d complete%n&quot;, start, end, ledger.ledgerID);</span>
<span class="nc" id="L465">                long current = start;</span>
<span class="nc" id="L466">                LedgerInfo.EntryIterator iterator = finalLedger.getIterator();</span>
<span class="nc" id="L467">                iterator.seek(current - 1);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                for (byte[] result : results) {</span>
<span class="nc" id="L469">                    byte[] check = iterator.next().getBuffer();</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                    if (result.length != check.length) {</span>
<span class="nc" id="L471">                        propagateExceptionToMain(new Exception(String.format(</span>
                                &quot;Mismatched entry length on entry %d for ledger %d, read returned %d, should be %d&quot;,
<span class="nc" id="L473">                                current, ledger.ledgerID, result.length, check.length)</span>
                        ));
                    }
                    /* Verify contents */
<span class="nc bnc" id="L477" title="All 2 branches missed.">                    if (!Arrays.equals(check, result)) {</span>
<span class="nc" id="L478">                        int i = 0;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                        for (; i &lt; check.length; ++i) {</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                            if (check[i] != result[i]) {</span>
<span class="nc" id="L481">                                break;</span>
                            }
                        }
<span class="nc" id="L484">                        propagateExceptionToMain(new Exception(String.format(</span>
                                &quot;Mismatched entry contents on entry %d for ledger %d at offset %d, length %d&quot;,
<span class="nc" id="L486">                                current, ledger.ledgerID, i, check.length)</span>
                        ));
                    }
<span class="nc" id="L489">                    current++;</span>
<span class="nc" id="L490">                }</span>
<span class="nc" id="L491">                finalLedger.decReads((rc2) -&gt; {</span>
<span class="nc" id="L492">                    synchronized (BookkeeperVerifier.this) {</span>
<span class="nc" id="L493">                        checkReturn(ledger.ledgerID, rc2);</span>
<span class="nc" id="L494">                        System.out.format(&quot;Read %d -&gt; %d from ledger %d releasing read%n&quot;, start, end, ledger.ledgerID);</span>
<span class="nc" id="L495">                        outstandingReadCount--;</span>
<span class="nc" id="L496">                        BookkeeperVerifier.this.notifyAll();</span>
<span class="nc" id="L497">                    }</span>
<span class="nc" id="L498">                });</span>
<span class="nc" id="L499">            }</span>
<span class="nc" id="L500">        });</span>
<span class="nc" id="L501">        ++outstandingReadCount;</span>
<span class="nc" id="L502">        return true;</span>
    }

    class WriteCallback implements Consumer&lt;Integer&gt; {
<span class="nc" id="L506">        private int completed = 0;</span>
        private final int toWaitFor;
        private final LedgerInfo ledger;
        private final long lastEntry;
        private final long pendingLAC;
<span class="nc" id="L511">        WriteCallback(LedgerInfo ledger, long lastEntry, long pendingLAC, int toWaitFor) {</span>
<span class="nc" id="L512">            this.toWaitFor = toWaitFor;</span>
<span class="nc" id="L513">            this.ledger = ledger;</span>
<span class="nc" id="L514">            this.lastEntry = lastEntry;</span>
<span class="nc" id="L515">            this.pendingLAC = pendingLAC;</span>
<span class="nc" id="L516">        }</span>

        @Override
        public void accept(Integer rc) {
<span class="nc" id="L520">            synchronized (BookkeeperVerifier.this) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                if (checkReturn(ledger.ledgerID, rc)) {</span>
<span class="nc" id="L522">                    return;</span>
                }
<span class="nc" id="L524">                ++completed;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                if (toWaitFor == completed) {</span>
<span class="nc" id="L526">                    System.out.format(&quot;Writes ending at %d complete on ledger %d%n&quot;, lastEntry, ledger.ledgerID);</span>
<span class="nc" id="L527">                    ledger.closeWrite(lastEntry, (rc2) -&gt; {</span>
<span class="nc" id="L528">                        synchronized (BookkeeperVerifier.this) {</span>
<span class="nc" id="L529">                            checkReturn(ledger.ledgerID, rc2);</span>
<span class="nc" id="L530">                            System.out.format(&quot;Writes ending at %d complete on ledger %d releasing write%n&quot;,</span>
<span class="nc" id="L531">                                    lastEntry, ledger.ledgerID);</span>
<span class="nc" id="L532">                            --outstandingWriteCount;</span>
<span class="nc" id="L533">                            BookkeeperVerifier.this.notifyAll();</span>
<span class="nc" id="L534">                        }</span>
<span class="nc" id="L535">                    });</span>
<span class="nc" id="L536">                    ledger.updateLAC(pendingLAC);</span>
                }
<span class="nc" id="L538">            }</span>
<span class="nc" id="L539">        }</span>
    }

    /**
     * Attempt to start one more write, return false if too many are in progress.
     * @return false if unable to start more
     */
    private synchronized boolean startWrite() {
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (outstandingWriteCount &gt; targetConcurrentWrites) {</span>
<span class="nc" id="L548">            System.out.format(&quot;Write paused, too many outstanding writes%n&quot;);</span>
            /* Caller should release lock and wait for outstandingWriteCount to fall */
<span class="nc" id="L550">            return false;</span>
        }
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (openLedgers.size() + openingLedgers.size() &lt; targetConcurrentLedgers) {</span>
            /* Not enough open ledgers, open a new one -- counts as a write */
<span class="nc" id="L554">            long newID = getNextLedgerID();</span>
<span class="nc" id="L555">            System.out.format(&quot;Creating new ledger %d%n&quot;, newID);</span>
<span class="nc" id="L556">            LedgerInfo ledger = new LedgerInfo(newID, opRand.nextLong());</span>
<span class="nc" id="L557">            openingLedgers.add(ledger);</span>
<span class="nc" id="L558">            driver.createLedger(newID, ensembleSize, writeQuorum, ackQuorum, (rc) -&gt; {</span>
<span class="nc" id="L559">                synchronized (BookkeeperVerifier.this) {</span>
<span class="nc" id="L560">                    checkReturn(newID, rc);</span>
<span class="nc" id="L561">                    System.out.format(&quot;Created new ledger %d%n&quot;, newID);</span>
<span class="nc" id="L562">                    openingLedgers.remove(ledger);</span>
<span class="nc" id="L563">                    openLedgers.add(ledger);</span>
<span class="nc" id="L564">                    --outstandingWriteCount;</span>
<span class="nc" id="L565">                    BookkeeperVerifier.this.notifyAll();</span>
<span class="nc" id="L566">                }</span>
<span class="nc" id="L567">            });</span>
<span class="nc" id="L568">            ++outstandingWriteCount;</span>
<span class="nc" id="L569">            return true;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        } else if (openLedgers.isEmpty()) {</span>
<span class="nc" id="L571">            System.out.format(&quot;Not starting a write, no open ledgers, already opening the limit%n&quot;);</span>
            /* Caller should release lock and wait for openLedgers to be populated */
<span class="nc" id="L573">            return false;</span>
        } else {
<span class="nc" id="L575">            LedgerInfo ledger = getRandomLedger(openLedgers);</span>
<span class="nc" id="L576">            ArrayList&lt;EntryInfo&gt; toWrite = ledger.getNextEntries(targetWriteGroup);</span>
<span class="nc" id="L577">            long lastEntry = toWrite.get(toWrite.size() - 1).getEntryID();</span>
<span class="nc" id="L578">            System.out.format(</span>
                    &quot;Writing entries %d -&gt; %d to ledger %d%n&quot;,
<span class="nc" id="L580">                    toWrite.get(0).getEntryID(),</span>
<span class="nc" id="L581">                    lastEntry,</span>
<span class="nc" id="L582">                    ledger.ledgerID);</span>
<span class="nc" id="L583">            ledger.openWrite(lastEntry);</span>

<span class="nc" id="L585">            WriteCallback writeCB = new WriteCallback(</span>
<span class="nc" id="L586">                    ledger, lastEntry, ledger.getLastEntryIDCompleted(), toWrite.size());</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            for (EntryInfo entry: toWrite) {</span>
<span class="nc" id="L588">                driver.writeEntry(ledger.ledgerID, entry.getEntryID(), entry.getBuffer(), writeCB);</span>
<span class="nc" id="L589">            }</span>
<span class="nc" id="L590">            ++outstandingWriteCount;</span>

<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (lastEntry &gt;= targetLedgerEntries) {</span>
                /* Remove this ledger from the writable list, mark for closing once all open writes complete */
<span class="nc" id="L594">                System.out.format(&quot;Marking ledger %d for close%n&quot;, ledger.ledgerID);</span>
<span class="nc" id="L595">                openLedgers.remove(ledger);</span>
<span class="nc" id="L596">                liveLedgers.add(ledger);</span>
<span class="nc" id="L597">                ledger.onLastWriteComplete((rc) -&gt; checkReturn(ledger.ledgerID, rc), (Consumer&lt;Integer&gt; cb) -&gt; {</span>
<span class="nc" id="L598">                    System.out.format(&quot;Closing ledger %d%n&quot;, ledger.ledgerID);</span>
<span class="nc" id="L599">                    driver.closeLedger(ledger.ledgerID, (Integer rc) -&gt; {</span>
<span class="nc" id="L600">                        synchronized (BookkeeperVerifier.this) {</span>
<span class="nc" id="L601">                            ledger.setClosed();</span>
<span class="nc" id="L602">                            System.out.format(&quot;Closed ledger %d%n&quot;, ledger.ledgerID);</span>

<span class="nc bnc" id="L604" title="All 2 branches missed.">                            if (liveLedgers.size() &gt;= targetLedgers) {</span>
                                /* We've closed the ledger, but now we have too many closed but readable ledgers,
                                 * start deleting one. */
<span class="nc" id="L607">                                LedgerInfo toDelete = getRandomLedger(liveLedgers);</span>
<span class="nc" id="L608">                                final long ledgerID = toDelete.ledgerID;</span>
<span class="nc" id="L609">                                System.out.format(&quot;Marking ledger %d for deletion%n&quot;, ledgerID);</span>
<span class="nc" id="L610">                                liveLedgers.remove(toDelete);</span>
<span class="nc" id="L611">                                toDelete.onLastOpComplete(cb, (Consumer&lt;Integer&gt; cb2) -&gt; {</span>
<span class="nc" id="L612">                                    System.out.format(&quot;Deleting ledger %d%n&quot;, ledgerID);</span>
<span class="nc" id="L613">                                    driver.deleteLedger(ledgerID, (rc2) -&gt; {</span>
<span class="nc" id="L614">                                        synchronized (BookkeeperVerifier.this) {</span>
<span class="nc" id="L615">                                            System.out.format(&quot;Deleted ledger %d%n&quot;, ledgerID);</span>
<span class="nc" id="L616">                                            cb2.accept(rc2);</span>
<span class="nc" id="L617">                                        }</span>
<span class="nc" id="L618">                                    });</span>
<span class="nc" id="L619">                                });</span>
<span class="nc" id="L620">                            } else {</span>
<span class="nc" id="L621">                                cb.accept(rc);</span>
                            }
<span class="nc" id="L623">                        }</span>
<span class="nc" id="L624">                    });</span>
<span class="nc" id="L625">                });</span>
            }

<span class="nc" id="L628">            Collections.shuffle(toWrite);</span>
<span class="nc" id="L629">            return true;</span>
        }
    }

    /**
     * This is the method used to invoke the main loop of the IO driver.  run() will loop
     * starting IO requests until the time runs out on the test and all outstanding requests
     * complete.  Test execution state is accessed only under the instance lock for 'this'.
     * There is no fine grained locking, hence run() simply needs to be synchronized and
     * can wait for IOs to complete atomically with startWrite and startRead returning
     * false (see those comments).
     *
     * @throws Exception
     */
    public synchronized void run() throws Exception {
<span class="nc" id="L644">        long start = System.currentTimeMillis();</span>
<span class="nc" id="L645">        long testEnd = start + (duration * 1000);</span>
<span class="nc" id="L646">        long testDrainEnd = testEnd + (drainTimeout * 1000);</span>

        /* Keep IO running until testEnd */
<span class="nc bnc" id="L649" title="All 2 branches missed.">        while (System.currentTimeMillis() &lt; testEnd) {</span>

            /* see startRead and startWrite, they return false once no more IO can be started */
<span class="nc bnc" id="L652" title="All 4 branches missed.">            while (startRead() || startWrite()) {}</span>
<span class="nc" id="L653">            long toWait = testEnd - System.currentTimeMillis();</span>

            /* atomically wait for either IO to complete or the test to end */
<span class="nc bnc" id="L656" title="All 2 branches missed.">            this.wait(toWait &lt; 0 ? 0 : toWait);</span>
<span class="nc" id="L657">            printThrowExceptions();</span>
<span class="nc" id="L658">        }</span>

        /* Wait for all in progress ops to complete, outstanding*Count is updated under the lock */
<span class="nc bnc" id="L661" title="All 6 branches missed.">        while ((System.currentTimeMillis() &lt; testDrainEnd)</span>
                &amp;&amp; (outstandingReadCount &gt; 0 || outstandingWriteCount &gt; 0)) {
<span class="nc" id="L663">            System.out.format(&quot;reads: %d, writes: %d%n&quot;, outstandingReadCount, outstandingWriteCount);</span>
<span class="nc" id="L664">            System.out.format(&quot;openingLedgers:%n&quot;);</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">            for (LedgerInfo li: openingLedgers) {</span>
<span class="nc" id="L666">                System.out.format(</span>
                        &quot;Ledger %d has reads: %d, writes: %d%n&quot;,
<span class="nc" id="L668">                        li.ledgerID,</span>
<span class="nc" id="L669">                        li.readsInProgress,</span>
<span class="nc" id="L670">                        li.writesInProgress.size());</span>
<span class="nc" id="L671">            }</span>
<span class="nc" id="L672">            System.out.format(&quot;openLedgers:%n&quot;);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            for (LedgerInfo li: openLedgers) {</span>
<span class="nc" id="L674">                System.out.format(</span>
                        &quot;Ledger %d has reads: %d, writes: %d%n&quot;,
<span class="nc" id="L676">                        li.ledgerID,</span>
<span class="nc" id="L677">                        li.readsInProgress,</span>
<span class="nc" id="L678">                        li.writesInProgress.size());</span>
<span class="nc" id="L679">            }</span>
<span class="nc" id="L680">            System.out.format(&quot;liveLedgers:%n&quot;);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">            for (LedgerInfo li: liveLedgers) {</span>
<span class="nc" id="L682">                System.out.format(</span>
                        &quot;Ledger %d has reads: %d, writes: %d%n&quot;,
<span class="nc" id="L684">                        li.ledgerID,</span>
<span class="nc" id="L685">                        li.readsInProgress,</span>
<span class="nc" id="L686">                        li.writesInProgress.size());</span>
<span class="nc" id="L687">            }</span>
<span class="nc" id="L688">            long toWait = testDrainEnd - System.currentTimeMillis();</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            this.wait(toWait &lt; 0 ? 0 : toWait);</span>
<span class="nc" id="L690">            printThrowExceptions();</span>
<span class="nc" id="L691">        }</span>
<span class="nc bnc" id="L692" title="All 4 branches missed.">        if (outstandingReadCount &gt; 0 || outstandingWriteCount &gt; 0) {</span>
<span class="nc" id="L693">            throw new Exception(&quot;Failed to drain ops before timeout%n&quot;);</span>
        }
<span class="nc" id="L695">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>